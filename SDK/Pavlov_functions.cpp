// Name: Pavlov, Version: 1.0

#include "../pch.h"

/*!!DEFINE!!*/

/*!!HELPER_DEF!!*/

/*!!HELPER_INC!!*/

#ifdef _MSC_VER
	#pragma pack(push, 0x01)
#endif

namespace CG
{
//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------

// Function:
//		Offset -> 0x006718B0
//		Name   -> Function Pavlov.ActionGunState.SetAction
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UActionGunState::SetAction(float NewValue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ActionGunState.SetAction");

	UActionGunState_SetAction_Params params {};
	params.NewValue = NewValue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006715B0
//		Name   -> Function Pavlov.ActionGunState.OpenAction
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UActionGunState::OpenAction()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ActionGunState.OpenAction");

	UActionGunState_OpenAction_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670D50
//		Name   -> Function Pavlov.ActionGunState.CloseAction
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UActionGunState::CloseAction()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ActionGunState.CloseAction");

	UActionGunState_CloseAction_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670E40
//		Name   -> Function Pavlov.AirdropPlane.GeneratePath
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     DropLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AAirdropPlane::GeneratePath(const struct FVector& DropLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AirdropPlane.GeneratePath");

	AAirdropPlane_GeneratePath_Params params {};
	params.DropLocation = DropLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00672070
//		Name   -> Function Pavlov.AirplaneRoyale.StartTravel
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AAirplaneRoyale::StartTravel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AirplaneRoyale.StartTravel");

	AAirplaneRoyale_StartTravel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006719B0
//		Name   -> Function Pavlov.AirplaneRoyale.SetAsBase
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAirplaneRoyale::SetAsBase(class APavlovPawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AirplaneRoyale.SetAsBase");

	AAirplaneRoyale_SetAsBase_Params params {};
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671500
//		Name   -> Function Pavlov.AirplaneRoyale.OnRep_Traveled
//		Flags  -> (Final, Native, Private)
void AAirplaneRoyale::OnRep_Traveled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AirplaneRoyale.OnRep_Traveled");

	AAirplaneRoyale_OnRep_Traveled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670CB0
//		Name   -> Function Pavlov.AirplaneRoyale.ClearBase
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAirplaneRoyale::ClearBase(class APavlovPawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AirplaneRoyale.ClearBase");

	AAirplaneRoyale_ClearBase_Params params {};
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671930
//		Name   -> Function Pavlov.AmmoBox.SetAmmoCount
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewAmmoCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAmmoBox::SetAmmoCount(int NewAmmoCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AmmoBox.SetAmmoCount");

	AAmmoBox_SetAmmoCount_Params params {};
	params.NewAmmoCount = NewAmmoCount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006716E0
//		Name   -> Function Pavlov.AmmoBox.RemoveAmmo
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                RemoveAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAmmoBox::RemoveAmmo(int RemoveAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AmmoBox.RemoveAmmo");

	AAmmoBox_RemoveAmmo_Params params {};
	params.RemoveAmount = RemoveAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006714C0
//		Name   -> Function Pavlov.AmmoBox.OnRep_AmmoCount
//		Flags  -> (Final, Native, Private)
void AAmmoBox::OnRep_AmmoCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AmmoBox.OnRep_AmmoCount");

	AAmmoBox_OnRep_AmmoCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671370
//		Name   -> Function Pavlov.AmmoBox.OnAmmoCountChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void AAmmoBox::OnAmmoCountChanged()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AmmoBox.OnAmmoCountChanged");

	AAmmoBox_OnAmmoCountChanged_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670EE0
//		Name   -> Function Pavlov.AmmoBox.GetAmmoType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		VRFramework_EAmmoType                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
VRFramework_EAmmoType AAmmoBox::GetAmmoType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AmmoBox.GetAmmoType");

	AAmmoBox_GetAmmoType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670880
//		Name   -> Function Pavlov.AmmoBox.AddAmmo
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                AddAmount                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAmmoBox::AddAmmo(int AddAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AmmoBox.AddAmmo");

	AAmmoBox_AddAmmo_Params params {};
	params.AddAmount = AddAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00672090
//		Name   -> Function Pavlov.Attachment.TryAttach
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		unsigned char                                      SlideModeSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bPlayFailureSound                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bSliding                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachment::TryAttach(unsigned char SlideModeSlot, bool* bPlayFailureSound, bool bSliding)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.TryAttach");

	AAttachment_TryAttach_Params params {};
	params.SlideModeSlot = SlideModeSlot;
	params.bSliding = bSliding;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (bPlayFailureSound != nullptr)
		*bPlayFailureSound = params.bPlayFailureSound;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00671C80
//		Name   -> Function Pavlov.Attachment.SetSelectionEnable
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachment::SetSelectionEnable(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.SetSelectionEnable");

	AAttachment_SetSelectionEnable_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Attachment.OnSlideModeChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bSlideMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachment::OnSlideModeChanged(bool bSlideMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.OnSlideModeChanged");

	AAttachment_OnSlideModeChanged_Params params {};
	params.bSlideMode = bSlideMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671390
//		Name   -> Function Pavlov.Attachment.OnGunTickChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachment::OnGunTickChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.OnGunTickChanged");

	AAttachment_OnGunTickChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Attachment.OnAttachmentModeChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachment::OnAttachmentModeChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.OnAttachmentModeChanged");

	AAttachment_OnAttachmentModeChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671250
//		Name   -> Function Pavlov.Attachment.MakeSlideModeSlot
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AGun*                                        Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
unsigned char AAttachment::MakeSlideModeSlot(class AGun* Gun)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.MakeSlideModeSlot");

	AAttachment_MakeSlideModeSlot_Params params {};
	params.Gun = Gun;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006711A0
//		Name   -> Function Pavlov.Attachment.GunTick
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachment::GunTick(float DeltaTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.GunTick");

	AAttachment_GunTick_Params params {};
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006710C0
//		Name   -> Function Pavlov.Attachment.GetSlideTransform
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FTransform                                  SlideTransform                                             (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachment::GetSlideTransform(struct FTransform* SlideTransform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.GetSlideTransform");

	AAttachment_GetSlideTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SlideTransform != nullptr)
		*SlideTransform = params.SlideTransform;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00671020
//		Name   -> Function Pavlov.Attachment.GetSlideModeSlot
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		unsigned char                                      SlideModeSlot                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachment::GetSlideModeSlot(unsigned char* SlideModeSlot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.GetSlideModeSlot");

	AAttachment_GetSlideModeSlot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SlideModeSlot != nullptr)
		*SlideModeSlot = params.SlideModeSlot;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Attachment.GetGrabLoc
//		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector AAttachment::GetGrabLoc()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.GetGrabLoc");

	AAttachment_GetGrabLoc_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670D30
//		Name   -> Function Pavlov.Attachment.ClearSlideGun
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AAttachment::ClearSlideGun()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.ClearSlideGun");

	AAttachment_ClearSlideGun_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670BC0
//		Name   -> Function Pavlov.Attachment.CanAttach
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AGun*                                        Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bForceAttach                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachment::CanAttach(class AGun* Gun, bool bForceAttach)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.CanAttach");

	AAttachment_CanAttach_Params params {};
	params.Gun = Gun;
	params.bForceAttach = bForceAttach;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670AC0
//		Name   -> Function Pavlov.Attachment.AttachToGunServer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class AGun*                                        Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      SlideModeSlot                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachment::AttachToGunServer(class AGun* Gun, unsigned char SlideModeSlot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.AttachToGunServer");

	AAttachment_AttachToGunServer_Params params {};
	params.Gun = Gun;
	params.SlideModeSlot = SlideModeSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670A00
//		Name   -> Function Pavlov.Attachment.AttachToGun
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class AGun*                                        Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bForceAttach                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachment::AttachToGun(class AGun* Gun, bool bForceAttach)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Attachment.AttachToGun");

	AAttachment_AttachToGun_Params params {};
	params.Gun = Gun;
	params.bForceAttach = bForceAttach;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006717F0
//		Name   -> Function Pavlov.AttachmentAccessory.SetAccessoryActive_Server
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentAccessory::SetAccessoryActive_Server(bool bActive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory.SetAccessoryActive_Server");

	AAttachmentAccessory_SetAccessoryActive_Server_Params params {};
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671520
//		Name   -> Function Pavlov.AttachmentAccessory.SetAccessoryActive
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentAccessory::SetAccessoryActive(bool bActive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory.SetAccessoryActive");

	AAttachmentAccessory_SetAccessoryActive_Params params {};
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006714A0
//		Name   -> Function Pavlov.AttachmentAccessory.OnRep_AccessoryOn
//		Flags  -> (Final, Native, Protected)
void AAttachmentAccessory::OnRep_AccessoryOn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory.OnRep_AccessoryOn");

	AAttachmentAccessory_OnRep_AccessoryOn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006712E0
//		Name   -> Function Pavlov.AttachmentAccessory.OnAccessoryStateChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentAccessory::OnAccessoryStateChanged(bool bActive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory.OnAccessoryStateChanged");

	AAttachmentAccessory_OnAccessoryStateChanged_Params params {};
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671220
//		Name   -> Function Pavlov.AttachmentAccessory.IsAccessoryOn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachmentAccessory::IsAccessoryOn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory.IsAccessoryOn");

	AAttachmentAccessory_IsAccessoryOn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670C90
//		Name   -> Function Pavlov.AttachmentAccessory.CheckDropped
//		Flags  -> (Final, Native, Public)
void AAttachmentAccessory::CheckDropped()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory.CheckDropped");

	AAttachmentAccessory_CheckDropped_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671FE0
//		Name   -> Function Pavlov.AttachmentAccessory_Bayonet.StabPlayerMulti
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bSlashed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentAccessory_Bayonet::StabPlayerMulti(bool bSlashed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory_Bayonet.StabPlayerMulti");

	AAttachmentAccessory_Bayonet_StabPlayerMulti_Params params {};
	params.bSlashed = bSlashed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671EC0
//		Name   -> Function Pavlov.AttachmentAccessory_Bayonet.StabPlayer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FBayonetDamage                              BayonetDamage                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
void AAttachmentAccessory_Bayonet::StabPlayer(const struct FBayonetDamage& BayonetDamage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory_Bayonet.StabPlayer");

	AAttachmentAccessory_Bayonet_StabPlayer_Params params {};
	params.BayonetDamage = BayonetDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.AttachmentAccessory_Bayonet.OnSwitchToBlood
//		Flags  -> (Event, Public, BlueprintEvent)
void AAttachmentAccessory_Bayonet::OnSwitchToBlood()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentAccessory_Bayonet.OnSwitchToBlood");

	AAttachmentAccessory_Bayonet_OnSwitchToBlood_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006712E0
//		Name   -> Function Pavlov.AttachmentCanted.OnFlipCantedSight
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bRightHanded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentCanted::OnFlipCantedSight(bool bRightHanded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentCanted.OnFlipCantedSight");

	AAttachmentCanted_OnFlipCantedSight_Params params {};
	params.bRightHanded = bRightHanded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006721A0
//		Name   -> Function Pavlov.AttachmentSight.UpdateScopeHiddenActors
//		Flags  -> (Final, Native, Public)
void AAttachmentSight::UpdateScopeHiddenActors()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentSight.UpdateScopeHiddenActors");

	AAttachmentSight_UpdateScopeHiddenActors_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671BF0
//		Name   -> Function Pavlov.AttachmentSight.SetScopeActive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentSight::SetScopeActive(bool bActive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentSight.SetScopeActive");

	AAttachmentSight_SetScopeActive_Params params {};
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671520
//		Name   -> Function Pavlov.AttachmentSight.OnScopeExploit
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bExploit                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentSight::OnScopeExploit(bool bExploit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentSight.OnScopeExploit");

	AAttachmentSight_OnScopeExploit_Params params {};
	params.bExploit = bExploit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670F40
//		Name   -> Function Pavlov.AttachmentSight.GetLenseMesh
//		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		int                                                MaterialIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UMeshComponent*                              ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UMeshComponent* AAttachmentSight::GetLenseMesh(int* MaterialIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentSight.GetLenseMesh");

	AAttachmentSight_GetLenseMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (MaterialIndex != nullptr)
		*MaterialIndex = params.MaterialIndex;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670E00
//		Name   -> Function Pavlov.AttachmentSight.DebugFOVAngle
//		Flags  -> (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AAttachmentSight::DebugFOVAngle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentSight.DebugFOVAngle");

	AAttachmentSight_DebugFOVAngle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670980
//		Name   -> Function Pavlov.AttachmentSight.ApplyZeroing
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
//		float                                              Delta                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachmentSight::ApplyZeroing(float Delta)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachmentSight.ApplyZeroing");

	AAttachmentSight_ApplyZeroing_Params params {};
	params.Delta = Delta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671D90
//		Name   -> Function Pavlov.AttachProxy.SetupOwnerAttachment
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		struct FAttachProxyInfo                            NewAttachInfo                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AAttachProxy::SetupOwnerAttachment(const struct FAttachProxyInfo& NewAttachInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachProxy.SetupOwnerAttachment");

	AAttachProxy_SetupOwnerAttachment_Params params {};
	params.NewAttachInfo = NewAttachInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00671A30
//		Name   -> Function Pavlov.AttachProxy.SetAttachInfo
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FAttachProxyInfo                            NewAttachInfo                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void AAttachProxy::SetAttachInfo(const struct FAttachProxyInfo& NewAttachInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachProxy.SetAttachInfo");

	AAttachProxy_SetAttachInfo_Params params {};
	params.NewAttachInfo = NewAttachInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671660
//		Name   -> Function Pavlov.AttachProxy.OwnerKilled
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Killed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachProxy::OwnerKilled(class AActor* Killed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachProxy.OwnerKilled");

	AAttachProxy_OwnerKilled_Params params {};
	params.Killed = Killed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006714E0
//		Name   -> Function Pavlov.AttachProxy.OnRep_AttachInfo
//		Flags  -> (Final, Native, Private)
void AAttachProxy::OnRep_AttachInfo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachProxy.OnRep_AttachInfo");

	AAttachProxy_OnRep_AttachInfo_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671420
//		Name   -> Function Pavlov.AttachProxy.OnParentDestroyed
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AAttachProxy::OnParentDestroyed(class AActor* DestroyedActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AttachProxy.OnParentDestroyed");

	AAttachProxy_OnParentDestroyed_Params params {};
	params.DestroyedActor = DestroyedActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00217B10
//		Name   -> Function Pavlov.AvatarSkin.Update
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
void UAvatarSkin::Update()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.Update");

	UAvatarSkin_Update_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671D10
//		Name   -> Function Pavlov.AvatarSkin.SetStencilValue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UAvatarSkin::SetStencilValue(unsigned char Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.SetStencilValue");

	UAvatarSkin_SetStencilValue_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671B60
//		Name   -> Function Pavlov.AvatarSkin.SetRenderToCustomDepth
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UAvatarSkin::SetRenderToCustomDepth(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.SetRenderToCustomDepth");

	UAvatarSkin_SetRenderToCustomDepth_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671770
//		Name   -> Function Pavlov.AvatarSkin.RemoveUsedComponent
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UAvatarSkin::RemoveUsedComponent(class UActorComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.RemoveUsedComponent");

	UAvatarSkin_RemoveUsedComponent_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006715D0
//		Name   -> Function Pavlov.AvatarSkin.OptimizeAvatar
//		Flags  -> (Native, Public)
// Parameters:
//		class USkeletalMeshComponent*                      PawnAvatar                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UAvatarSkin::OptimizeAvatar(class USkeletalMeshComponent* PawnAvatar)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.OptimizeAvatar");

	UAvatarSkin_OptimizeAvatar_Params params {};
	params.PawnAvatar = PawnAvatar;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00670FF0
//		Name   -> Function Pavlov.AvatarSkin.GetPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APavlovPawn*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPawn* UAvatarSkin::GetPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.GetPawn");

	UAvatarSkin_GetPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670F10
//		Name   -> Function Pavlov.AvatarSkin.GetBaseMeshComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class USkeletalMeshComponent*                      ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USkeletalMeshComponent* UAvatarSkin::GetBaseMeshComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.GetBaseMeshComponent");

	UAvatarSkin_GetBaseMeshComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670D70
//		Name   -> Function Pavlov.AvatarSkin.CreateChildSkeletalMeshComponent
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		class USkeletalMesh*                               SkeletalMesh                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USkeletalMeshComponent*                      ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USkeletalMeshComponent* UAvatarSkin::CreateChildSkeletalMeshComponent(class USkeletalMesh* SkeletalMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.CreateChildSkeletalMeshComponent");

	UAvatarSkin_CreateChildSkeletalMeshComponent_Params params {};
	params.SkeletalMesh = SkeletalMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670900
//		Name   -> Function Pavlov.AvatarSkin.AddUsedComponent
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		class UActorComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UAvatarSkin::AddUsedComponent(class UActorComponent* Component)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkin.AddUsedComponent");

	UAvatarSkin_AddUsedComponent_Params params {};
	params.Component = Component;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006764A0
//		Name   -> Function Pavlov.AvatarSkinCustom.SetCustomMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       MeshName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USkeletalMesh*                               CustomHandMesh                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UAvatarSkinCustom::SetCustomMesh(const struct FName& MeshName, class USkeletalMesh* CustomHandMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AvatarSkinCustom.SetCustomMesh");

	UAvatarSkinCustom_SetCustomMesh_Params params {};
	params.MeshName = MeshName;
	params.CustomHandMesh = CustomHandMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006765F0
//		Name   -> Function Pavlov.AzureGameMode.Travel
//		Flags  -> (Final, Native, Public)
void AAzureGameMode::Travel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AzureGameMode.Travel");

	AAzureGameMode_Travel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.AzureServer.SoftTick
//		Flags  -> (Final, Native, Public)
void UAzureServer::SoftTick()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.AzureServer.SoftTick");

	UAzureServer_SoftTick_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069E1F0
//		Name   -> Function Pavlov.PavlovGameMode.TerminateGameSession
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::TerminateGameSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.TerminateGameSession");

	APavlovGameMode_TerminateGameSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069E170
//		Name   -> Function Pavlov.PavlovGameMode.SwitchTeam
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SwitchTeam(class AController* Controller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SwitchTeam");

	APavlovGameMode_SwitchTeam_Params params {};
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069E0F0
//		Name   -> Function Pavlov.PavlovGameMode.Suicide
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::Suicide(class AController* Controller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.Suicide");

	APavlovGameMode_Suicide_Params params {};
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069E0D0
//		Name   -> Function Pavlov.PavlovGameMode.StopReplayRecording
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
void APavlovGameMode::StopReplayRecording()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.StopReplayRecording");

	APavlovGameMode_StopReplayRecording_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069E0B0
//		Name   -> Function Pavlov.PavlovGameMode.StartReplayRecording
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
void APavlovGameMode::StartReplayRecording()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.StartReplayRecording");

	APavlovGameMode_StartReplayRecording_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069DF50
//		Name   -> Function Pavlov.PavlovGameMode.SpawnVehicleWRef
//		Flags  -> (Native, Public)
// Parameters:
//		struct FAsyncVehicleSpawnData                      AsyncVehicleSpawnData                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::SpawnVehicleWRef(const struct FAsyncVehicleSpawnData& AsyncVehicleSpawnData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SpawnVehicleWRef");

	APavlovGameMode_SpawnVehicleWRef_Params params {};
	params.AsyncVehicleSpawnData = AsyncVehicleSpawnData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069DE80
//		Name   -> Function Pavlov.PavlovGameMode.SpawnVehicleForPawn
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::SpawnVehicleForPawn(class APavlovPawn* Pawn, const struct FName& Vehicle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SpawnVehicleForPawn");

	APavlovGameMode_SpawnVehicleForPawn_Params params {};
	params.Pawn = Pawn;
	params.Vehicle = Vehicle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069DD40
//		Name   -> Function Pavlov.PavlovGameMode.SpawnVehicle
//		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		struct FName                                       VehicleID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::SpawnVehicle(const struct FTransform& SpawnTransform, const struct FName& VehicleID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SpawnVehicle");

	APavlovGameMode_SpawnVehicle_Params params {};
	params.SpawnTransform = SpawnTransform;
	params.VehicleID = VehicleID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069DCB0
//		Name   -> Function Pavlov.PavlovGameMode.SpawnPlayer
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SpawnPlayer(class AController* Controller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SpawnPlayer");

	APavlovGameMode_SpawnPlayer_Params params {};
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069DB90
//		Name   -> Function Pavlov.PavlovGameMode.SpawnPavlovPawn
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPawn* APavlovGameMode::SpawnPavlovPawn(class AController* Controller, const struct FTransform& Transform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SpawnPavlovPawn");

	APavlovGameMode_SpawnPavlovPawn_Params params {};
	params.Controller = Controller;
	params.Transform = Transform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069DB70
//		Name   -> Function Pavlov.PavlovGameMode.SpawnAndPossesPawns
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::SpawnAndPossesPawns()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SpawnAndPossesPawns");

	APavlovGameMode_SpawnAndPossesPawns_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069DB50
//		Name   -> Function Pavlov.PavlovGameMode.ShuffleTeams
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::ShuffleTeams()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.ShuffleTeams");

	APavlovGameMode_ShuffleTeams_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovGameMode.SetTTTRoundEndSoundEnabled
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetTTTRoundEndSoundEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetTTTRoundEndSoundEnabled");

	APavlovGameMode_SetTTTRoundEndSoundEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069DAD0
//		Name   -> Function Pavlov.PavlovGameMode.SetTeamLockTime
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              LockTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetTeamLockTime(float LockTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetTeamLockTime");

	APavlovGameMode_SetTeamLockTime_Params params {};
	params.LockTime = LockTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069DA10
//		Name   -> Function Pavlov.PavlovGameMode.SetTeamCash
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                CashAmmount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetTeamCash(int TeamId, int CashAmmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetTeamCash");

	APavlovGameMode_SetTeamCash_Params params {};
	params.TeamId = TeamId;
	params.CashAmmount = CashAmmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D990
//		Name   -> Function Pavlov.PavlovGameMode.SetRoundState
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		PavlovProxy_EPavlovRoundState                      State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetRoundState(PavlovProxy_EPavlovRoundState State)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetRoundState");

	APavlovGameMode_SetRoundState_Params params {};
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D8D0
//		Name   -> Function Pavlov.PavlovGameMode.SetPlayerScore
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetPlayerScore(class APlayerState* PlayerState, int Score)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetPlayerScore");

	APavlovGameMode_SetPlayerScore_Params params {};
	params.PlayerState = PlayerState;
	params.Score = Score;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D840
//		Name   -> Function Pavlov.PavlovGameMode.SetPawnsInvulnerable
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetPawnsInvulnerable(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetPawnsInvulnerable");

	APavlovGameMode_SetPawnsInvulnerable_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D7B0
//		Name   -> Function Pavlov.PavlovGameMode.SetMovement
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetMovement(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetMovement");

	APavlovGameMode_SetMovement_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D730
//		Name   -> Function Pavlov.PavlovGameMode.SetLimitedAmmoMode
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		unsigned char                                      LimitedAmmoType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetLimitedAmmoMode(unsigned char LimitedAmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetLimitedAmmoMode");

	APavlovGameMode_SetLimitedAmmoMode_Params params {};
	params.LimitedAmmoType = LimitedAmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D670
//		Name   -> Function Pavlov.PavlovGameMode.SetInactivityThresholds
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewInactivityThreashold                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                NewInactivityDormantThreashold                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetInactivityThresholds(int NewInactivityThreashold, int NewInactivityDormantThreashold)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetInactivityThresholds");

	APavlovGameMode_SetInactivityThresholds_Params params {};
	params.NewInactivityThreashold = NewInactivityThreashold;
	params.NewInactivityDormantThreashold = NewInactivityDormantThreashold;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D5E0
//		Name   -> Function Pavlov.PavlovGameMode.SetGrenadePinPrevention
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bPreventGrenadePins                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetGrenadePinPrevention(bool bPreventGrenadePins)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetGrenadePinPrevention");

	APavlovGameMode_SetGrenadePinPrevention_Params params {};
	params.bPreventGrenadePins = bPreventGrenadePins;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D4D0
//		Name   -> Function Pavlov.PavlovGameMode.SetEveryoneCash
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                CashAmmount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetEveryoneCash(int CashAmmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetEveryoneCash");

	APavlovGameMode_SetEveryoneCash_Params params {};
	params.CashAmmount = CashAmmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D3C0
//		Name   -> Function Pavlov.PavlovGameMode.SetAttackingTeam
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::SetAttackingTeam(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.SetAttackingTeam");

	APavlovGameMode_SetAttackingTeam_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D3A0
//		Name   -> Function Pavlov.PavlovGameMode.RotateMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::RotateMap()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.RotateMap");

	APavlovGameMode_RotateMap_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovGameMode.ResetSNDMatch
//		Flags  -> (Event, Public, BlueprintEvent)
void APavlovGameMode::ResetSNDMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.ResetSNDMatch");

	APavlovGameMode_ResetSNDMatch_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D380
//		Name   -> Function Pavlov.PavlovGameMode.ResetScore
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::ResetScore()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.ResetScore");

	APavlovGameMode_ResetScore_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D2B0
//		Name   -> Function Pavlov.PavlovGameMode.ReplenishPlayersAmmo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::ReplenishPlayersAmmo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.ReplenishPlayersAmmo");

	APavlovGameMode_ReplenishPlayersAmmo_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D290
//		Name   -> Function Pavlov.PavlovGameMode.ReplaceVehicleSpawners
//		Flags  -> (Native, Public)
void APavlovGameMode::ReplaceVehicleSpawners()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.ReplaceVehicleSpawners");

	APavlovGameMode_ReplaceVehicleSpawners_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D270
//		Name   -> Function Pavlov.PavlovGameMode.RefreshOutOfBounds
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::RefreshOutOfBounds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.RefreshOutOfBounds");

	APavlovGameMode_RefreshOutOfBounds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D1F0
//		Name   -> Function Pavlov.PavlovGameMode.PunishTeamKiller
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          TeamKiller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::PunishTeamKiller(class APavlovPlayerState* TeamKiller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.PunishTeamKiller");

	APavlovGameMode_PunishTeamKiller_Params params {};
	params.TeamKiller = TeamKiller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D110
//		Name   -> Function Pavlov.PavlovGameMode.PostStats
//		Flags  -> (Final, Native, Protected)
void APavlovGameMode::PostStats()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.PostStats");

	APavlovGameMode_PostStats_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D0F0
//		Name   -> Function Pavlov.PavlovGameMode.PostRoundCleanUp
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::PostRoundCleanUp()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.PostRoundCleanUp");

	APavlovGameMode_PostRoundCleanUp_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069CD90
//		Name   -> Function Pavlov.PavlovGameMode.OnSteamTicketValidation
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FString                                     SteamUserId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Steamworks_ESteamAuthResponse                      Response                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     OwnerSteamUserId                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnSteamTicketValidation(const struct FString& SteamUserId, Steamworks_ESteamAuthResponse Response, const struct FString& OwnerSteamUserId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnSteamTicketValidation");

	APavlovGameMode_OnSteamTicketValidation_Params params {};
	params.SteamUserId = SteamUserId;
	params.Response = Response;
	params.OwnerSteamUserId = OwnerSteamUserId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069CF30
//		Name   -> Function Pavlov.PavlovGameMode.OnspawnVehicleWRefAsync
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UClass*                                      VehicleClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FAsyncVehicleSpawnData                      AsyncVehicleSpawnData                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void APavlovGameMode::OnspawnVehicleWRefAsync(class UClass* VehicleClass, const struct FAsyncVehicleSpawnData& AsyncVehicleSpawnData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnspawnVehicleWRefAsync");

	APavlovGameMode_OnspawnVehicleWRefAsync_Params params {};
	params.VehicleClass = VehicleClass;
	params.AsyncVehicleSpawnData = AsyncVehicleSpawnData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069CC10
//		Name   -> Function Pavlov.PavlovGameMode.OnSpawnVehicleAsync
//		Flags  -> (Final, Native, Public, HasDefaults)
// Parameters:
//		class UClass*                                      VehicleClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnSpawnVehicleAsync(class UClass* VehicleClass, const struct FTransform& SpawnTransform, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnSpawnVehicleAsync");

	APavlovGameMode_OnSpawnVehicleAsync_Params params {};
	params.VehicleClass = VehicleClass;
	params.SpawnTransform = SpawnTransform;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C8B0
//		Name   -> Function Pavlov.PavlovGameMode.OnRoundStateChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		PavlovProxy_EPavlovRoundState                      OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		PavlovProxy_EPavlovRoundState                      NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnRoundStateChanged(PavlovProxy_EPavlovRoundState OldState, PavlovProxy_EPavlovRoundState NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnRoundStateChanged");

	APavlovGameMode_OnRoundStateChanged_Params params {};
	params.OldState = OldState;
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C770
//		Name   -> Function Pavlov.PavlovGameMode.OnPlayerSpawned
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnPlayerSpawned(class APavlovPlayerState* PlayerState, class AController* Controller, class APavlovPawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnPlayerSpawned");

	APavlovGameMode_OnPlayerSpawned_Params params {};
	params.PlayerState = PlayerState;
	params.Controller = Controller;
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C670
//		Name   -> Function Pavlov.PavlovGameMode.OnPlayerKilled
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnPlayerKilled(class APavlovPlayerState* PlayerState, class AController* Controller, class APavlovPawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnPlayerKilled");

	APavlovGameMode_OnPlayerKilled_Params params {};
	params.PlayerState = PlayerState;
	params.Controller = Controller;
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C5F0
//		Name   -> Function Pavlov.PavlovGameMode.OnPawnKilled
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnPawnKilled(class AActor* OwnerActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnPawnKilled");

	APavlovGameMode_OnPawnKilled_Params params {};
	params.OwnerActor = OwnerActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C530
//		Name   -> Function Pavlov.PavlovGameMode.OnOutOfBoundsOverlap
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnOutOfBoundsOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnOutOfBoundsOverlap");

	APavlovGameMode_OnOutOfBoundsOverlap_Params params {};
	params.OverlappedActor = OverlappedActor;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C470
//		Name   -> Function Pavlov.PavlovGameMode.OnOutOfBoundsEndOverlap
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnOutOfBoundsEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnOutOfBoundsEndOverlap");

	APavlovGameMode_OnOutOfBoundsEndOverlap_Params params {};
	params.OverlappedActor = OverlappedActor;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C300
//		Name   -> Function Pavlov.PavlovGameMode.OnLimitedAmmoModeChanged
//		Flags  -> (Final, Native, Public)
// Parameters:
//		PavlovProxy_ELimitedAmmoType                       LimitedAmmoType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnLimitedAmmoModeChanged(PavlovProxy_ELimitedAmmoType LimitedAmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnLimitedAmmoModeChanged");

	APavlovGameMode_OnLimitedAmmoModeChanged_Params params {};
	params.LimitedAmmoType = LimitedAmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C240
//		Name   -> Function Pavlov.PavlovGameMode.OnKillVolumeOverlap
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      OverlappedActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::OnKillVolumeOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.OnKillVolumeOverlap");

	APavlovGameMode_OnKillVolumeOverlap_Params params {};
	params.OverlappedActor = OverlappedActor;
	params.OtherActor = OtherActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687280
//		Name   -> Function Pavlov.PavlovGameMode.MakeNavmeshStatic
//		Flags  -> (Final, Native, Protected)
void APavlovGameMode::MakeNavmeshStatic()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.MakeNavmeshStatic");

	APavlovGameMode_MakeNavmeshStatic_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069BDA0
//		Name   -> Function Pavlov.PavlovGameMode.LogSNDWinner
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		int                                                LogRound                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                LogTeamID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::LogSNDWinner(int LogRound, int LogTeamID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.LogSNDWinner");

	APavlovGameMode_LogSNDWinner_Params params {};
	params.LogRound = LogRound;
	params.LogTeamID = LogTeamID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069BD80
//		Name   -> Function Pavlov.PavlovGameMode.LogBombExplosion
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
void APavlovGameMode::LogBombExplosion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.LogBombExplosion");

	APavlovGameMode_LogBombExplosion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069BCB0
//		Name   -> Function Pavlov.PavlovGameMode.LogBomb
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		class AController*                                 Interactor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bBombPlanted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::LogBomb(class AController* Interactor, bool bBombPlanted)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.LogBomb");

	APavlovGameMode_LogBomb_Params params {};
	params.Interactor = Interactor;
	params.bBombPlanted = bBombPlanted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B300
//		Name   -> Function Pavlov.PavlovGameMode.KickByStringId
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FText                                       KickReason                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
//		bool                                               bBan                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::KickByStringId(const struct FString& ID, const struct FText& KickReason, bool bBan)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.KickByStringId");

	APavlovGameMode_KickByStringId_Params params {};
	params.ID = ID;
	params.KickReason = KickReason;
	params.bBan = bBan;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B150
//		Name   -> Function Pavlov.PavlovGameMode.KickByPlayerState
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FText                                       KickReason                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
//		bool                                               bBan                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bAddToBlacklist                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::KickByPlayerState(class APavlovPlayerState* PlayerState, const struct FText& KickReason, bool bBan, bool bAddToBlacklist)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.KickByPlayerState");

	APavlovGameMode_KickByPlayerState_Params params {};
	params.PlayerState = PlayerState;
	params.KickReason = KickReason;
	params.bBan = bBan;
	params.bAddToBlacklist = bAddToBlacklist;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B030
//		Name   -> Function Pavlov.PavlovGameMode.IsTeamDead
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::IsTeamDead(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.IsTeamDead");

	APavlovGameMode_IsTeamDead_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovGameMode.InitializedVehicleSpawners
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bHasSpawners                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::InitializedVehicleSpawners(bool bHasSpawners)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.InitializedVehicleSpawners");

	APavlovGameMode_InitializedVehicleSpawners_Params params {};
	params.bHasSpawners = bHasSpawners;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069ADD0
//		Name   -> Function Pavlov.PavlovGameMode.IncrementTeamScore
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::IncrementTeamScore(int TeamId, int Score)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.IncrementTeamScore");

	APavlovGameMode_IncrementTeamScore_Params params {};
	params.TeamId = TeamId;
	params.Score = Score;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069AD10
//		Name   -> Function Pavlov.PavlovGameMode.IncrementPlayerScore
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Score                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::IncrementPlayerScore(class APlayerState* PlayerState, int Score)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.IncrementPlayerScore");

	APavlovGameMode_IncrementPlayerScore_Params params {};
	params.PlayerState = PlayerState;
	params.Score = Score;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069AC50
//		Name   -> Function Pavlov.PavlovGameMode.GiveTeamCash
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                CashAmmount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::GiveTeamCash(int TeamId, int CashAmmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GiveTeamCash");

	APavlovGameMode_GiveTeamCash_Params params {};
	params.TeamId = TeamId;
	params.CashAmmount = CashAmmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069AB10
//		Name   -> Function Pavlov.PavlovGameMode.GiveItem
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              BlockDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bLoaded                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::GiveItem(class APavlovPawn* Pawn, class UClass* ItemClass, float BlockDuration, bool bLoaded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GiveItem");

	APavlovGameMode_GiveItem_Params params {};
	params.Pawn = Pawn;
	params.ItemClass = ItemClass;
	params.BlockDuration = BlockDuration;
	params.bLoaded = bLoaded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069AA80
//		Name   -> Function Pavlov.PavlovGameMode.GiveEveryoneCash
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                CashAmmount                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::GiveEveryoneCash(int CashAmmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GiveEveryoneCash");

	APavlovGameMode_GiveEveryoneCash_Params params {};
	params.CashAmmount = CashAmmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069A460
//		Name   -> Function Pavlov.PavlovGameMode.GetTeamStatus
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Num                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Casualties                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::GetTeamStatus(int TeamId, int* Num, int* Casualties)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetTeamStatus");

	APavlovGameMode_GetTeamStatus_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Num != nullptr)
		*Num = params.Num;
	if (Casualties != nullptr)
		*Casualties = params.Casualties;

}


// Function:
//		Offset -> 0x0069A330
//		Name   -> Function Pavlov.PavlovGameMode.GetTeamRealPlayerCount
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameMode::GetTeamRealPlayerCount(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetTeamRealPlayerCount");

	APavlovGameMode_GetTeamRealPlayerCount_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A1C0
//		Name   -> Function Pavlov.PavlovGameMode.GetSteamAudioGun
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString APavlovGameMode::GetSteamAudioGun()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetSteamAudioGun");

	APavlovGameMode_GetSteamAudioGun_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A070
//		Name   -> Function Pavlov.PavlovGameMode.GetSpawnPointsForQuery
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		int                                                NumOfSpawnPoints                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<class APlayerSpawnPoint*>                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<class APlayerSpawnPoint*> APavlovGameMode::GetSpawnPointsForQuery(int NumOfSpawnPoints)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetSpawnPointsForQuery");

	APavlovGameMode_GetSpawnPointsForQuery_Params params {};
	params.NumOfSpawnPoints = NumOfSpawnPoints;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699F50
//		Name   -> Function Pavlov.PavlovGameMode.GetRoundNumber
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameMode::GetRoundNumber()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetRoundNumber");

	APavlovGameMode_GetRoundNumber_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699F20
//		Name   -> Function Pavlov.PavlovGameMode.GetRealPlayerCount
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameMode::GetRealPlayerCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetRealPlayerCount");

	APavlovGameMode_GetRealPlayerCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699E60
//		Name   -> Function Pavlov.PavlovGameMode.GetRandomController
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamFilter                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bRealPlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AController* APavlovGameMode::GetRandomController(int TeamFilter, bool bRealPlayer)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetRandomController");

	APavlovGameMode_GetRandomController_Params params {};
	params.TeamFilter = TeamFilter;
	params.bRealPlayer = bRealPlayer;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699B50
//		Name   -> Function Pavlov.PavlovGameMode.GetMaxPlayerCount
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameMode::GetMaxPlayerCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetMaxPlayerCount");

	APavlovGameMode_GetMaxPlayerCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006999F0
//		Name   -> Function Pavlov.PavlovGameMode.GetKillZHeight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float APavlovGameMode::GetKillZHeight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetKillZHeight");

	APavlovGameMode_GetKillZHeight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006998C0
//		Name   -> Function Pavlov.PavlovGameMode.GetKillReward
//		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPlayerState*                          Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FDamageTrackInfo                            LastHitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameMode::GetKillReward(class APavlovPlayerState* Killer, class APavlovPlayerState* Victim, const struct FDamageTrackInfo& LastHitInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetKillReward");

	APavlovGameMode_GetKillReward_Params params {};
	params.Killer = Killer;
	params.Victim = Victim;
	params.LastHitInfo = LastHitInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699120
//		Name   -> Function Pavlov.PavlovGameMode.GetDynamicSpawnPointForTeam
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APlayerSpawnPoint*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APlayerSpawnPoint* APavlovGameMode::GetDynamicSpawnPointForTeam(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetDynamicSpawnPointForTeam");

	APavlovGameMode_GetDynamicSpawnPointForTeam_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699090
//		Name   -> Function Pavlov.PavlovGameMode.GetDynamicOccludedSpawnPoint
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APlayerSpawnPoint*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APlayerSpawnPoint* APavlovGameMode::GetDynamicOccludedSpawnPoint(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.GetDynamicOccludedSpawnPoint");

	APavlovGameMode_GetDynamicOccludedSpawnPoint_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699050
//		Name   -> Function Pavlov.PavlovGameMode.FinalizeMapSwitch
//		Flags  -> (Native, Protected)
void APavlovGameMode::FinalizeMapSwitch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.FinalizeMapSwitch");

	APavlovGameMode_FinalizeMapSwitch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3FF0
//		Name   -> Function Pavlov.PavlovGameMode.FinalizeMapRotation
//		Flags  -> (Native, Protected)
void APavlovGameMode::FinalizeMapRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.FinalizeMapRotation");

	APavlovGameMode_FinalizeMapRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovGameMode.EndTTTRound
//		Flags  -> (Event, Public, BlueprintEvent)
void APavlovGameMode::EndTTTRound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.EndTTTRound");

	APavlovGameMode_EndTTTRound_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698FC0
//		Name   -> Function Pavlov.PavlovGameMode.EnableFallDamage
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		bool                                               bFallEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::EnableFallDamage(bool bFallEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.EnableFallDamage");

	APavlovGameMode_EnableFallDamage_Params params {};
	params.bFallEnabled = bFallEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698F10
//		Name   -> Function Pavlov.PavlovGameMode.DestroyPushSpawns
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void APavlovGameMode::DestroyPushSpawns()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.DestroyPushSpawns");

	APavlovGameMode_DestroyPushSpawns_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698E90
//		Name   -> Function Pavlov.PavlovGameMode.DestroyBot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::DestroyBot(class AController* Controller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.DestroyBot");

	APavlovGameMode_DestroyBot_Params params {};
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovGameMode.CreateDedicatedServerSession
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::CreateDedicatedServerSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.CreateDedicatedServerSession");

	APavlovGameMode_CreateDedicatedServerSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698E00
//		Name   -> Function Pavlov.PavlovGameMode.CreateBot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AController* APavlovGameMode::CreateBot(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.CreateBot");

	APavlovGameMode_CreateBot_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovGameMode.CleanUpItems
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameMode::CleanUpItems()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.CleanUpItems");

	APavlovGameMode_CleanUpItems_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698DD0
//		Name   -> Function Pavlov.PavlovGameMode.CanRotateMap
//		Flags  -> (Native, Protected, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::CanRotateMap()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.CanRotateMap");

	APavlovGameMode_CanRotateMap_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00698D70
//		Name   -> Function Pavlov.PavlovGameMode.CanChangeScore
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::CanChangeScore()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.CanChangeScore");

	APavlovGameMode_CanChangeScore_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00698CA0
//		Name   -> Function Pavlov.PavlovGameMode.AssignPlayerSkin
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::AssignPlayerSkin(class APavlovPlayerState* PlayerState, class APavlovPawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.AssignPlayerSkin");

	APavlovGameMode_AssignPlayerSkin_Params params {};
	params.PlayerState = PlayerState;
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698B50
//		Name   -> Function Pavlov.PavlovGameMode.AddTTTGameInfo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      TTTGameInfoClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTTTGameInfo*                                ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTTTGameInfo* APavlovGameMode::AddTTTGameInfo(class UClass* TTTGameInfoClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.AddTTTGameInfo");

	APavlovGameMode_AddTTTGameInfo_Params params {};
	params.TTTGameInfoClass = TTTGameInfoClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00698A90
//		Name   -> Function Pavlov.PavlovGameMode.AddStatByController
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EPlayerStats                                PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::AddStatByController(class AController* Controller, Pavlov_EPlayerStats PlayerStat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.AddStatByController");

	APavlovGameMode_AddStatByController_Params params {};
	params.Controller = Controller;
	params.PlayerStat = PlayerStat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006989D0
//		Name   -> Function Pavlov.PavlovGameMode.AddStat
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PavPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EPlayerStats                                PlayerStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameMode::AddStat(class APavlovPlayerState* PavPlayerState, Pavlov_EPlayerStats PlayerStat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.AddStat");

	APavlovGameMode_AddStat_Params params {};
	params.PavPlayerState = PavPlayerState;
	params.PlayerStat = PlayerStat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00698950
//		Name   -> Function Pavlov.PavlovGameMode.AddExtraRoundTime
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ExtraTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::AddExtraRoundTime(float ExtraTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.AddExtraRoundTime");

	APavlovGameMode_AddExtraRoundTime_Params params {};
	params.ExtraTime = ExtraTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006988D0
//		Name   -> Function Pavlov.PavlovGameMode.AddAssist
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameMode::AddAssist(class APavlovPlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameMode.AddAssist");

	APavlovGameMode_AddAssist_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676290
//		Name   -> Function Pavlov.BattlegroundsGameMode.PerformWaitingHeartBeat
//		Flags  -> (Final, Native, Protected)
void ABattlegroundsGameMode::PerformWaitingHeartBeat()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BattlegroundsGameMode.PerformWaitingHeartBeat");

	ABattlegroundsGameMode_PerformWaitingHeartBeat_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676270
//		Name   -> Function Pavlov.BattlegroundsGameMode.PerformGameHeartBeat
//		Flags  -> (Final, Native, Protected)
void ABattlegroundsGameMode::PerformGameHeartBeat()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BattlegroundsGameMode.PerformGameHeartBeat");

	ABattlegroundsGameMode_PerformGameHeartBeat_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.BloodPuddle.OnPour
//		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void ABloodPuddle::OnPour(const struct FTransform& Transform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BloodPuddle.OnPour");

	ABloodPuddle_OnPour_Params params {};
	params.Transform = Transform;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006760E0
//		Name   -> Function Pavlov.BloodPuddle.OnOwnerEndPlay
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TEnumAsByte<Engine_EEndPlayReason>                 Reason                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABloodPuddle::OnOwnerEndPlay(class AActor* OwnerActor, TEnumAsByte<Engine_EEndPlayReason> Reason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BloodPuddle.OnOwnerEndPlay");

	ABloodPuddle_OnOwnerEndPlay_Params params {};
	params.OwnerActor = OwnerActor;
	params.Reason = Reason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675610
//		Name   -> Function Pavlov.BloodSplatGeometry.FadeOut
//		Flags  -> (Final, Native, Protected)
void ABloodSplatGeometry::FadeOut()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BloodSplatGeometry.FadeOut");

	ABloodSplatGeometry_FadeOut_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676440
//		Name   -> Function Pavlov.Bomb.ResetBombPosition
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void ABomb::ResetBombPosition()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.ResetBombPosition");

	ABomb_ResetBombPosition_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006762B0
//		Name   -> Function Pavlov.Bomb.PlantAt
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class ABombPlantSpot*                              Spot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::PlantAt(class ABombPlantSpot* Spot, bool bForce)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.PlantAt");

	ABomb_PlantAt_Params params {};
	params.Spot = Spot;
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006761A0
//		Name   -> Function Pavlov.Bomb.OnPlayerOcclusionChange
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bNewOccluded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::OnPlayerOcclusionChange(bool bNewOccluded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnPlayerOcclusionChange");

	ABomb_OnPlayerOcclusionChange_Params params {};
	params.bNewOccluded = bNewOccluded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3DB0
//		Name   -> Function Pavlov.Bomb.OnPlanted
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ABomb::OnPlanted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnPlanted");

	ABomb_OnPlanted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA540
//		Name   -> Function Pavlov.Bomb.OnGrace
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ABomb::OnGrace()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnGrace");

	ABomb_OnGrace_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA560
//		Name   -> Function Pavlov.Bomb.OnDetonation
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ABomb::OnDetonation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnDetonation");

	ABomb_OnDetonation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675ED0
//		Name   -> Function Pavlov.Bomb.OnDefuse
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ABomb::OnDefuse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnDefuse");

	ABomb_OnDefuse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA520
//		Name   -> Function Pavlov.Bomb.OnCodeReset
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ABomb::OnCodeReset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnCodeReset");

	ABomb_OnCodeReset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675C30
//		Name   -> Function Pavlov.Bomb.OnButtonPressed
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::OnButtonPressed(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnButtonPressed");

	ABomb_OnButtonPressed_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3C00
//		Name   -> Function Pavlov.Bomb.OnBeep
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void ABomb::OnBeep()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.OnBeep");

	ABomb_OnBeep_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675B80
//		Name   -> Function Pavlov.Bomb.MulticastOnPlantAt
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		class ABombPlantSpot*                              Spot                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::MulticastOnPlantAt(class ABombPlantSpot* Spot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnPlantAt");

	ABomb_MulticastOnPlantAt_Params params {};
	params.Spot = Spot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675B60
//		Name   -> Function Pavlov.Bomb.MulticastOnGrace
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void ABomb::MulticastOnGrace()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnGrace");

	ABomb_MulticastOnGrace_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675AD0
//		Name   -> Function Pavlov.Bomb.MulticastOnEnterCode
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::MulticastOnEnterCode(bool bSucceed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnEnterCode");

	ABomb_MulticastOnEnterCode_Params params {};
	params.bSucceed = bSucceed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675AB0
//		Name   -> Function Pavlov.Bomb.MulticastOnDetonation
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void ABomb::MulticastOnDetonation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnDetonation");

	ABomb_MulticastOnDetonation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA610
//		Name   -> Function Pavlov.Bomb.MulticastOnDefuse
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void ABomb::MulticastOnDefuse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnDefuse");

	ABomb_MulticastOnDefuse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671370
//		Name   -> Function Pavlov.Bomb.MulticastOnCodeReset
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void ABomb::MulticastOnCodeReset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnCodeReset");

	ABomb_MulticastOnCodeReset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675A90
//		Name   -> Function Pavlov.Bomb.MulticastOnBeep
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void ABomb::MulticastOnBeep()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.MulticastOnBeep");

	ABomb_MulticastOnBeep_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675910
//		Name   -> Function Pavlov.Bomb.IsWireCut
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ABomb::IsWireCut(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.IsWireCut");

	ABomb_IsWireCut_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00675880
//		Name   -> Function Pavlov.Bomb.IsButtonPressed
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ABomb::IsButtonPressed(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.IsButtonPressed");

	ABomb_IsButtonPressed_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006757E0
//		Name   -> Function Pavlov.Bomb.GetWireLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector ABomb::GetWireLocation(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.GetWireLocation");

	ABomb_GetWireLocation_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00675660
//		Name   -> Function Pavlov.Bomb.GetClosestValidWireIndex
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int ABomb::GetClosestValidWireIndex(const struct FVector& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.GetClosestValidWireIndex");

	ABomb_GetClosestValidWireIndex_Params params {};
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006755F0
//		Name   -> Function Pavlov.Bomb.ExpireCode
//		Flags  -> (Final, Native, Protected)
void ABomb::ExpireCode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.ExpireCode");

	ABomb_ExpireCode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675530
//		Name   -> Function Pavlov.Bomb.EnterDigit
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Digit                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 Presser                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::EnterDigit(int Digit, class AController* Presser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.EnterDigit");

	ABomb_EnterDigit_Params params {};
	params.Digit = Digit;
	params.Presser = Presser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3C20
//		Name   -> Function Pavlov.Bomb.Detonate
//		Flags  -> (Native, Public, BlueprintCallable)
void ABomb::Detonate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.Detonate");

	ABomb_Detonate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675490
//		Name   -> Function Pavlov.Bomb.Defuse
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AController*                                 Defuser                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::Defuse(class AController* Defuser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.Defuse");

	ABomb_Defuse_Params params {};
	params.Defuser = Defuser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006753B0
//		Name   -> Function Pavlov.Bomb.CutWire
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 Defuser                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::CutWire(int Index, class AController* Defuser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.CutWire");

	ABomb_CutWire_Params params {};
	params.Index = Index;
	params.Defuser = Defuser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006751F0
//		Name   -> Function Pavlov.Bomb.AllowAutoResetBomb
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bAutoReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABomb::AllowAutoResetBomb(bool bAutoReset)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bomb.AllowAutoResetBomb");

	ABomb_AllowAutoResetBomb_Params params {};
	params.bAutoReset = bAutoReset;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676610
//		Name   -> Function Pavlov.BombPlantSpot.UpdateEnabledState
//		Flags  -> (Final, Native, Private)
void ABombPlantSpot::UpdateEnabledState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BombPlantSpot.UpdateEnabledState");

	ABombPlantSpot_UpdateEnabledState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676560
//		Name   -> Function Pavlov.BombPlantSpot.SetSpotEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABombPlantSpot::SetSpotEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BombPlantSpot.SetSpotEnabled");

	ABombPlantSpot_SetSpotEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676480
//		Name   -> Function Pavlov.BombPlantSpot.ResetSpot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ABombPlantSpot::ResetSpot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BombPlantSpot.ResetSpot");

	ABombPlantSpot_ResetSpot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676250
//		Name   -> Function Pavlov.BombPlantSpot.OnRep_PlantedHere
//		Flags  -> (Final, Native, Private)
void ABombPlantSpot::OnRep_PlantedHere()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BombPlantSpot.OnRep_PlantedHere");

	ABombPlantSpot_OnRep_PlantedHere_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671390
//		Name   -> Function Pavlov.BombPlantSpot.MulticastOnPlantStateChanged
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bPlanted                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABombPlantSpot::MulticastOnPlantStateChanged(bool bPlanted)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BombPlantSpot.MulticastOnPlantStateChanged");

	ABombPlantSpot_MulticastOnPlantStateChanged_Params params {};
	params.bPlanted = bPlanted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675C10
//		Name   -> Function Pavlov.BootGameMode.OnAsyncLoadCompleted
//		Flags  -> (Final, Native, Public)
void ABootGameMode::OnAsyncLoadCompleted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BootGameMode.OnAsyncLoadCompleted");

	ABootGameMode_OnAsyncLoadCompleted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675630
//		Name   -> Function Pavlov.Bullet.GetBulletMesh
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class UStaticMeshComponent*                        ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UStaticMeshComponent* ABullet::GetBulletMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Bullet.GetBulletMesh");

	ABullet_GetBulletMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CF580
//		Name   -> Function Pavlov.UberWheel.SetEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AUberWheel::SetEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UberWheel.SetEnabled");

	AUberWheel_SetEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEBE0
//		Name   -> Function Pavlov.UberWheel.IsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AUberWheel::IsEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UberWheel.IsEnabled");

	AUberWheel_IsEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0023D6B0
//		Name   -> Function Pavlov.BuyMenu.OnScriptingReady
//		Flags  -> (Final, Native, Private)
void ABuyMenu::OnScriptingReady()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenu.OnScriptingReady");

	ABuyMenu_OnScriptingReady_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676230
//		Name   -> Function Pavlov.BuyMenu.OnReadyForBindings
//		Flags  -> (Final, Native, Private)
void ABuyMenu::OnReadyForBindings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenu.OnReadyForBindings");

	ABuyMenu_OnReadyForBindings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675D50
//		Name   -> Function Pavlov.BuyMenu.OnCashUpdated
//		Flags  -> (Final, Native, Private)
// Parameters:
//		int                                                Cash                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABuyMenu::OnCashUpdated(int Cash)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenu.OnCashUpdated");

	ABuyMenu_OnCashUpdated_Params params {};
	params.Cash = Cash;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675CC0
//		Name   -> Function Pavlov.BuyMenu.OnBuyingChanged
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ABuyMenu::OnBuyingChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenu.OnBuyingChanged");

	ABuyMenu_OnBuyingChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006763B0
//		Name   -> Function Pavlov.BuyMenuData.RemoveBuyMenuSlot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UBuyMenuData::RemoveBuyMenuSlot(const struct FName& ItemName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenuData.RemoveBuyMenuSlot");

	UBuyMenuData_RemoveBuyMenuSlot_Params params {};
	params.ItemName = ItemName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00676380
//		Name   -> Function Pavlov.BuyMenuData.PropertiesToJson
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UJsonUtilsObj*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UJsonUtilsObj* UBuyMenuData::PropertiesToJson()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenuData.PropertiesToJson");

	UBuyMenuData_PropertiesToJson_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006759A0
//		Name   -> Function Pavlov.BuyMenuData.JsonStringToBuyWheelData
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     JsonString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UBuyMenuData::JsonStringToBuyWheelData(const struct FString& JsonString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenuData.JsonStringToBuyWheelData");

	UBuyMenuData_JsonStringToBuyWheelData_Params params {};
	params.JsonString = JsonString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00675700
//		Name   -> Function Pavlov.BuyMenuData.GetFilteredList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<struct FBuyMenuSlot>                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FBuyMenuSlot> UBuyMenuData::GetFilteredList(class APavlovPlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenuData.GetFilteredList");

	UBuyMenuData_GetFilteredList_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006752C0
//		Name   -> Function Pavlov.BuyMenuData.CreateBuyMenuData
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     JsonString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UBuyMenuData*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UBuyMenuData* UBuyMenuData::CreateBuyMenuData(const struct FString& JsonString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenuData.CreateBuyMenuData");

	UBuyMenuData_CreateBuyMenuData_Params params {};
	params.JsonString = JsonString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00675110
//		Name   -> Function Pavlov.BuyMenuData.AddBuyMenuSlot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FBuyMenuSlot                                Slot                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
void UBuyMenuData::AddBuyMenuSlot(const struct FBuyMenuSlot& Slot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.BuyMenuData.AddBuyMenuSlot");

	UBuyMenuData_AddBuyMenuSlot_Params params {};
	params.Slot = Slot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676460
//		Name   -> Function Pavlov.ChamberComponent.ResetChamber
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UChamberComponent::ResetChamber()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.ResetChamber");

	UChamberComponent_ResetChamber_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675EF0
//		Name   -> Function Pavlov.ChamberComponent.OnOverlap
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void UChamberComponent::OnOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.OnOverlap");

	UChamberComponent_OnOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675DD0
//		Name   -> Function Pavlov.ChamberComponent.OnChamberStateChanged
//		Flags  -> (Final, Native, Private)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		VRFramework_EVRGunChamberState                     OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		VRFramework_EVRGunChamberState                     NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UChamberComponent::OnChamberStateChanged(int Index, VRFramework_EVRGunChamberState OldState, VRFramework_EVRGunChamberState NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.OnChamberStateChanged");

	UChamberComponent_OnChamberStateChanged_Params params {};
	params.Index = Index;
	params.OldState = OldState;
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675510
//		Name   -> Function Pavlov.ChamberComponent.DestroyConstrainedMesh
//		Flags  -> (Final, Native, Private)
void UChamberComponent::DestroyConstrainedMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.DestroyConstrainedMesh");

	UChamberComponent_DestroyConstrainedMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675470
//		Name   -> Function Pavlov.ChamberComponent.DebugDraw
//		Flags  -> (Final, Native, Public, BlueprintCallable, Const)
void UChamberComponent::DebugDraw()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.DebugDraw");

	UChamberComponent_DebugDraw_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.ChamberComponent.CheckConstraintBreakThreshold
//		Flags  -> (Final, Native, Private)
void UChamberComponent::CheckConstraintBreakThreshold()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.CheckConstraintBreakThreshold");

	UChamberComponent_CheckConstraintBreakThreshold_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006752A0
//		Name   -> Function Pavlov.ChamberComponent.BreakCheck
//		Flags  -> (Final, Native, Private)
void UChamberComponent::BreakCheck()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.BreakCheck");

	UChamberComponent_BreakCheck_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675280
//		Name   -> Function Pavlov.ChamberComponent.AllowRemoval
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UChamberComponent::AllowRemoval()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ChamberComponent.AllowRemoval");

	UChamberComponent_AllowRemoval_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002A7830
//		Name   -> Function Pavlov.UIView.OnScriptingReady
//		Flags  -> (Native, Protected)
void AUIView::OnScriptingReady()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIView.OnScriptingReady");

	AUIView_OnScriptingReady_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218B10
//		Name   -> Function Pavlov.UIView.OnReadyForBindings
//		Flags  -> (Native, Protected)
void AUIView::OnReadyForBindings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIView.OnReadyForBindings");

	AUIView_OnReadyForBindings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002A56D0
//		Name   -> Function Pavlov.MenuUniverseView.SetVisible
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverseView::SetVisible(bool bVisible)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.SetVisible");

	AMenuUniverseView_SetVisible_Params params {};
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CFC0
//		Name   -> Function Pavlov.MenuUniverseView.SetDockTransformOverride
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void AMenuUniverseView::SetDockTransformOverride(const struct FTransform& T)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.SetDockTransformOverride");

	AMenuUniverseView_SetDockTransformOverride_Params params {};
	params.T = T;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C7A0
//		Name   -> Function Pavlov.MenuUniverseView.IsVisible
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AMenuUniverseView::IsVisible()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.IsVisible");

	AMenuUniverseView_IsVisible_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C560
//		Name   -> Function Pavlov.MenuUniverseView.GetUniverseTransform
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform AMenuUniverseView::GetUniverseTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetUniverseTransform");

	AMenuUniverseView_GetUniverseTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C520
//		Name   -> Function Pavlov.MenuUniverseView.GetTopRightLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D AMenuUniverseView::GetTopRightLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetTopRightLocation");

	AMenuUniverseView_GetTopRightLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C4E0
//		Name   -> Function Pavlov.MenuUniverseView.GetTopLeftLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D AMenuUniverseView::GetTopLeftLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetTopLeftLocation");

	AMenuUniverseView_GetTopLeftLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C390
//		Name   -> Function Pavlov.MenuUniverseView.GetOffset2D
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   Pivot2D                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D AMenuUniverseView::GetOffset2D(const struct FVector2D& Pivot2D)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetOffset2D");

	AMenuUniverseView_GetOffset2D_Params params {};
	params.Pivot2D = Pivot2D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C430
//		Name   -> Function Pavlov.MenuUniverseView.GetOffset
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   Pivot2D                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector AMenuUniverseView::GetOffset(const struct FVector2D& Pivot2D)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetOffset");

	AMenuUniverseView_GetOffset_Params params {};
	params.Pivot2D = Pivot2D;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C330
//		Name   -> Function Pavlov.MenuUniverseView.GetMenuUniverse
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AMenuUniverse*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AMenuUniverse* AMenuUniverseView::GetMenuUniverse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetMenuUniverse");

	AMenuUniverseView_GetMenuUniverse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BF20
//		Name   -> Function Pavlov.MenuUniverseView.GetCenterLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D AMenuUniverseView::GetCenterLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetCenterLocation");

	AMenuUniverseView_GetCenterLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BEE0
//		Name   -> Function Pavlov.MenuUniverseView.GetBottomRightLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D AMenuUniverseView::GetBottomRightLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetBottomRightLocation");

	AMenuUniverseView_GetBottomRightLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BEA0
//		Name   -> Function Pavlov.MenuUniverseView.GetBottomLeftLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D AMenuUniverseView::GetBottomLeftLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.GetBottomLeftLocation");

	AMenuUniverseView_GetBottomLeftLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BE80
//		Name   -> Function Pavlov.MenuUniverseView.FadeEnded
//		Flags  -> (Final, Native, Protected)
void AMenuUniverseView::FadeEnded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.FadeEnded");

	AMenuUniverseView_FadeEnded_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068BDB0
//		Name   -> Function Pavlov.MenuUniverseView.Fade
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverseView::Fade(bool bVisible, float Duration)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.Fade");

	AMenuUniverseView_Fade_Params params {};
	params.bVisible = bVisible;
	params.Duration = Duration;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068BAC0
//		Name   -> Function Pavlov.MenuUniverseView.ClearDockTransformOverride
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMenuUniverseView::ClearDockTransformOverride()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.ClearDockTransformOverride");

	AMenuUniverseView_ClearDockTransformOverride_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068B970
//		Name   -> Function Pavlov.MenuUniverseView.AnimateTo
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   NewPivotLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FRotator                                    Rotator                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void AMenuUniverseView::AnimateTo(const struct FVector2D& NewPivotLocation, const struct FRotator& Rotator)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseView.AnimateTo");

	AMenuUniverseView_AnimateTo_Params params {};
	params.NewPivotLocation = NewPivotLocation;
	params.Rotator = Rotator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B290
//		Name   -> Function Pavlov.ContentView.OnSideInterfaceChanged
//		Flags  -> (Native, Protected)
// Parameters:
//		Pavlov_EUserInterfaceType                          PrimaryInterface                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EUserInterfaceType                          OldInterface                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AContentView::OnSideInterfaceChanged(Pavlov_EUserInterfaceType PrimaryInterface, Pavlov_EUserInterfaceType OldInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ContentView.OnSideInterfaceChanged");

	AContentView_OnSideInterfaceChanged_Params params {};
	params.PrimaryInterface = PrimaryInterface;
	params.OldInterface = OldInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00676230
//		Name   -> Function Pavlov.ContentView.OnLobbyLeave
//		Flags  -> (Native, Protected)
void AContentView::OnLobbyLeave()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ContentView.OnLobbyLeave");

	AContentView_OnLobbyLeave_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067AF80
//		Name   -> Function Pavlov.ContentView.OnLobbyEnter
//		Flags  -> (Native, Protected)
// Parameters:
//		bool                                               bFailure                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AContentView::OnLobbyEnter(bool bFailure)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ContentView.OnLobbyEnter");

	AContentView_OnLobbyEnter_Params params {};
	params.bFailure = bFailure;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067AF00
//		Name   -> Function Pavlov.ContentView.OnInterfaceChanged
//		Flags  -> (Native, Protected)
// Parameters:
//		Pavlov_EUserInterfaceType                          OldInterface                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AContentView::OnInterfaceChanged(Pavlov_EUserInterfaceType OldInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ContentView.OnInterfaceChanged");

	AContentView_OnInterfaceChanged_Params params {};
	params.OldInterface = OldInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC7F0
//		Name   -> Function Pavlov.PlayOnlineView.UpdateLobbyData
//		Flags  -> (Final, Native, Protected)
void APlayOnlineView::UpdateLobbyData()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.UpdateLobbyData");

	APlayOnlineView_UpdateLobbyData_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC050
//		Name   -> Function Pavlov.PlayOnlineView.OnServerBrowserUpdated
//		Flags  -> (Final, Native, Protected)
void APlayOnlineView::OnServerBrowserUpdated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnServerBrowserUpdated");

	APlayOnlineView_OnServerBrowserUpdated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBF10
//		Name   -> Function Pavlov.PlayOnlineView.OnPingUpdated
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class UServerContainer*                            Container                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APlayOnlineView::OnPingUpdated(class UServerContainer* Container)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnPingUpdated");

	APlayOnlineView_OnPingUpdated_Params params {};
	params.Container = Container;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBE00
//		Name   -> Function Pavlov.PlayOnlineView.OnOnlineError
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		Pavlov_EOnlineError                                Error                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FText                                       ErrorMessage                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void APlayOnlineView::OnOnlineError(Pavlov_EOnlineError Error, const struct FText& ErrorMessage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnOnlineError");

	APlayOnlineView_OnOnlineError_Params params {};
	params.Error = Error;
	params.ErrorMessage = ErrorMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBDE0
//		Name   -> Function Pavlov.PlayOnlineView.OnMapBrowserDestroyed
//		Flags  -> (Final, Native, Protected)
void APlayOnlineView::OnMapBrowserDestroyed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnMapBrowserDestroyed");

	APlayOnlineView_OnMapBrowserDestroyed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBD30
//		Name   -> Function Pavlov.PlayOnlineView.OnMapBrowserCommit
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void APlayOnlineView::OnMapBrowserCommit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnMapBrowserCommit");

	APlayOnlineView_OnMapBrowserCommit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBC60
//		Name   -> Function Pavlov.PlayOnlineView.OnLobbyPinDestroyed
//		Flags  -> (Final, Native, Protected)
void APlayOnlineView::OnLobbyPinDestroyed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnLobbyPinDestroyed");

	APlayOnlineView_OnLobbyPinDestroyed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBBB0
//		Name   -> Function Pavlov.PlayOnlineView.OnLobbyPinCommit
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void APlayOnlineView::OnLobbyPinCommit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.OnLobbyPinCommit");

	APlayOnlineView_OnLobbyPinCommit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBB10
//		Name   -> Function Pavlov.PlayOnlineView.LobbyTalkCheck
//		Flags  -> (Final, Native, Protected)
void APlayOnlineView::LobbyTalkCheck()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOnlineView.LobbyTalkCheck");

	APlayOnlineView_LobbyTalkCheck_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B350
//		Name   -> Function Pavlov.ConnectSpinnerModalView.OnWorkshopDownloadProgress
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		float                                              Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AConnectSpinnerModalView::OnWorkshopDownloadProgress(float Progress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ConnectSpinnerModalView.OnWorkshopDownloadProgress");

	AConnectSpinnerModalView_OnWorkshopDownloadProgress_Params params {};
	params.Progress = Progress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.CosmeticTickActor.CosmeticTick
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ACosmeticTickActor::CosmeticTick(float DeltaTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CosmeticTickActor.CosmeticTick");

	ACosmeticTickActor_CosmeticTick_Params params {};
	params.DeltaTime = DeltaTime;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B680
//		Name   -> Function Pavlov.CustomItem.SpawnItemProxy
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      CustomItemClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ACustomItem::SpawnItemProxy(class UClass* CustomItemClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.SpawnItemProxy");

	ACustomItem_SpawnItemProxy_Params params {};
	params.CustomItemClass = CustomItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B5F0
//		Name   -> Function Pavlov.CustomItem.SetPickDisabled
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bDisabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ACustomItem::SetPickDisabled(bool bDisabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.SetPickDisabled");

	ACustomItem_SetPickDisabled_Params params {};
	params.bDisabled = bDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B450
//		Name   -> Function Pavlov.CustomItem.PlayerDroppedItem
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ACustomItem::PlayerDroppedItem()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.PlayerDroppedItem");

	ACustomItem_PlayerDroppedItem_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B270
//		Name   -> Function Pavlov.CustomItem.OnRep_CustomProxy
//		Flags  -> (Final, Native, Public)
void ACustomItem::OnRep_CustomProxy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.OnRep_CustomProxy");

	ACustomItem_OnRep_CustomProxy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067AC90
//		Name   -> Function Pavlov.CustomItem.GetPawn
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class APawn*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APawn* ACustomItem::GetPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.GetPawn");

	ACustomItem_GetPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067ABB0
//		Name   -> Function Pavlov.CustomItem.GetItemState
//		Flags  -> (Final, Native, Public)
// Parameters:
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
unsigned char ACustomItem::GetItemState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.GetItemState");

	ACustomItem_GetItemState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x002AA170
//		Name   -> Function Pavlov.CustomItem.GetItemSequence
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class UAnimSequence*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAnimSequence* ACustomItem::GetItemSequence()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.GetItemSequence");

	ACustomItem_GetItemSequence_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067AB30
//		Name   -> Function Pavlov.CustomItem.GetExcludeSlots
//		Flags  -> (Final, Native, Public)
// Parameters:
//		TArray<unsigned char>                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<unsigned char> ACustomItem::GetExcludeSlots()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.GetExcludeSlots");

	ACustomItem_GetExcludeSlots_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067A9F0
//		Name   -> Function Pavlov.CustomItem.DropItem
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bDestroy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ACustomItem::DropItem(bool bDestroy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.DropItem");

	ACustomItem_DropItem_Params params {};
	params.bDestroy = bDestroy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067A8E0
//		Name   -> Function Pavlov.CustomItem.CustomItemDestroyed
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ACustomItem::CustomItemDestroyed(class AActor* DestroyedActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.CustomItem.CustomItemDestroyed");

	ACustomItem_CustomItemDestroyed_Params params {};
	params.DestroyedActor = DestroyedActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B3D0
//		Name   -> Function Pavlov.DamageEffectComponent.OwnerKilled
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UDamageEffectComponent::OwnerKilled(class AActor* Owner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageEffectComponent.OwnerKilled");

	UDamageEffectComponent_OwnerKilled_Params params {};
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067AD80
//		Name   -> Function Pavlov.DamageEffectComponent.InitComponent
//		Flags  -> (Final, Native, Public)
void UDamageEffectComponent::InitComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageEffectComponent.InitComponent");

	UDamageEffectComponent_InitComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x003F34F0
//		Name   -> Function Pavlov.DamageEffectComponent.EnableDebugging
//		Flags  -> (Final, Native, Protected, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UDamageEffectComponent::EnableDebugging(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageEffectComponent.EnableDebugging");

	UDamageEffectComponent_EnableDebugging_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067A960
//		Name   -> Function Pavlov.DamageEffectComponent.DisplayHit
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     BulletDirection                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UDamageEffectComponent::DisplayHit(const struct FVector& BulletDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageEffectComponent.DisplayHit");

	UDamageEffectComponent_DisplayHit_Params params {};
	params.BulletDirection = BulletDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B540
//		Name   -> Function Pavlov.DamageTrackerComponent.ResetTracking
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UDamageTrackerComponent::ResetTracking()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageTrackerComponent.ResetTracking");

	UDamageTrackerComponent_ResetTracking_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067ABE0
//		Name   -> Function Pavlov.DamageTrackerComponent.GetLastHit
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FDamageTrackInfo                            LastHit                                                    (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UDamageTrackerComponent::GetLastHit(struct FDamageTrackInfo* LastHit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageTrackerComponent.GetLastHit");

	UDamageTrackerComponent_GetLastHit_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LastHit != nullptr)
		*LastHit = params.LastHit;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067AA80
//		Name   -> Function Pavlov.DamageTrackerComponent.GatherAssists
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FDamageTrackInfo>                    Assists                                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
void UDamageTrackerComponent::GatherAssists(TArray<struct FDamageTrackInfo>* Assists)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DamageTrackerComponent.GatherAssists");

	UDamageTrackerComponent_GatherAssists_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Assists != nullptr)
		*Assists = params.Assists;

}


// Function:
//		Offset -> 0x0067B700
//		Name   -> Function Pavlov.DedicatedServer.TravelNextTick
//		Flags  -> (Final, Native, Protected)
void UDedicatedServer::TravelNextTick()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DedicatedServer.TravelNextTick");

	UDedicatedServer_TravelNextTick_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B010
//		Name   -> Function Pavlov.DedicatedServer.OnMapDownloaded
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UDedicatedServer::OnMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DedicatedServer.OnMapDownloaded");

	UDedicatedServer_OnMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067ACC0
//		Name   -> Function Pavlov.DedicatedServer.GetServerDetails
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FServerDetails                              ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
struct FServerDetails UDedicatedServer::GetServerDetails()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DedicatedServer.GetServerDetails");

	UDedicatedServer_GetServerDetails_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006AC7E0
//		Name   -> Function Pavlov.PavlovObject.TickByInterval
//		Flags  -> (Final, Native, Private)
void UPavlovObject::TickByInterval()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovObject.TickByInterval");

	UPavlovObject_TickByInterval_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Destructible.OnShatter
//		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FVector                                     Normal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ADestructible::OnShatter(const struct FVector& Normal, const struct FVector& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Destructible.OnShatter");

	ADestructible_OnShatter_Params params {};
	params.Normal = Normal;
	params.Location = Location;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067ADA0
//		Name   -> Function Pavlov.Destructible.MulticastOnShatter
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FVector_NetQuantizeNormal                   Normal                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
//		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
void ADestructible::MulticastOnShatter(const struct FVector_NetQuantizeNormal& Normal, const struct FVector_NetQuantize& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Destructible.MulticastOnShatter");

	ADestructible_MulticastOnShatter_Params params {};
	params.Normal = Normal;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B560
//		Name   -> Function Pavlov.DoubleBarrelGunState.SetBarrel
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bOpen                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UDoubleBarrelGunState::SetBarrel(bool bOpen)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.DoubleBarrelGunState.SetBarrel");

	UDoubleBarrelGunState_SetBarrel_Params params {};
	params.bOpen = bOpen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067A8A0
//		Name   -> Function Pavlov.FlyingHelmet.ApplyImpulse
//		Flags  -> (Final, Native, Private)
void AFlyingHelmet::ApplyImpulse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.FlyingHelmet.ApplyImpulse");

	AFlyingHelmet_ApplyImpulse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B720
//		Name   -> Function Pavlov.FriendsView.UpdateFriendsModel
//		Flags  -> (Final, Native, Protected)
void AFriendsView::UpdateFriendsModel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.FriendsView.UpdateFriendsModel");

	AFriendsView_UpdateFriendsModel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B520
//		Name   -> Function Pavlov.GameSessionServer.ReportState
//		Flags  -> (Final, Native, Private)
void UGameSessionServer::ReportState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GameSessionServer.ReportState");

	UGameSessionServer_ReportState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B140
//		Name   -> Function Pavlov.GameSessionServer.OnMapDownloaded
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UGameSessionServer::OnMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GameSessionServer.OnMapDownloaded");

	UGameSessionServer_OnMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067AE80
//		Name   -> Function Pavlov.GameSessionServer.OnDownloadProgress
//		Flags  -> (Final, Native, Private)
// Parameters:
//		float                                              Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UGameSessionServer::OnDownloadProgress(float Progress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GameSessionServer.OnDownloadProgress");

	UGameSessionServer_OnDownloadProgress_Params params {};
	params.Progress = Progress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067A8C0
//		Name   -> Function Pavlov.GameSessionServer.AttemptToDispatch
//		Flags  -> (Final, Native, Public)
void UGameSessionServer::AttemptToDispatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GameSessionServer.AttemptToDispatch");

	UGameSessionServer_AttemptToDispatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067B470
//		Name   -> Function Pavlov.GestureComponent.RegisterGesture
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FGestureSetup                               Setup                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
void UGestureComponent::RegisterGesture(const struct FGestureSetup& Setup)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GestureComponent.RegisterGesture");

	UGestureComponent_RegisterGesture_Params params {};
	params.Setup = Setup;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC940
//		Name   -> Function Pavlov.PavlovItemController.UpdateUIState
//		Flags  -> (Final, Native, Protected)
void APavlovItemController::UpdateUIState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.UpdateUIState");

	APavlovItemController_UpdateUIState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC130
//		Name   -> Function Pavlov.PavlovItemController.SetWheelEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovItemController::SetWheelEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.SetWheelEnabled");

	APavlovItemController_SetWheelEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006ABAD0
//		Name   -> Function Pavlov.PavlovItemController.SetMenu
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovItemController::SetMenu(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.SetMenu");

	APavlovItemController_SetMenu_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB960
//		Name   -> Function Pavlov.PavlovItemController.SetKillfeed
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovItemController::SetKillfeed(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.SetKillfeed");

	APavlovItemController_SetKillfeed_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAEF0
//		Name   -> Function Pavlov.PavlovItemController.ReleaseTwoHandGrip
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovItemController::ReleaseTwoHandGrip()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.ReleaseTwoHandGrip");

	APavlovItemController_ReleaseTwoHandGrip_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAC80
//		Name   -> Function Pavlov.PavlovItemController.OnTeamIdChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovItemController::OnTeamIdChanged(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.OnTeamIdChanged");

	APavlovItemController_OnTeamIdChanged_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAC00
//		Name   -> Function Pavlov.PavlovItemController.OnSelectionPicked
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AVRItem*                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovItemController::OnSelectionPicked(class AVRItem* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.OnSelectionPicked");

	APavlovItemController_OnSelectionPicked_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9C30
//		Name   -> Function Pavlov.PavlovItemController.IsWheelEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovItemController::IsWheelEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.IsWheelEnabled");

	APavlovItemController_IsWheelEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9C00
//		Name   -> Function Pavlov.PavlovItemController.IsTwoHandReloadEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovItemController::IsTwoHandReloadEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.IsTwoHandReloadEnabled");

	APavlovItemController_IsTwoHandReloadEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9BD0
//		Name   -> Function Pavlov.PavlovItemController.IsTwoHandGripEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovItemController::IsTwoHandGripEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.IsTwoHandGripEnabled");

	APavlovItemController_IsTwoHandGripEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9A80
//		Name   -> Function Pavlov.PavlovItemController.IsMenuActive
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovItemController::IsMenuActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.IsMenuActive");

	APavlovItemController_IsMenuActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9030
//		Name   -> Function Pavlov.PavlovItemController.GetOppositeHandController
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APavlovItemController*                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovItemController* APavlovItemController::GetOppositeHandController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.GetOppositeHandController");

	APavlovItemController_GetOppositeHandController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8A60
//		Name   -> Function Pavlov.PavlovItemController.GetHandMenuInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class AHandMenu*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AHandMenu* APavlovItemController::GetHandMenuInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.GetHandMenuInstance");

	APavlovItemController_GetHandMenuInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8A20
//		Name   -> Function Pavlov.PavlovItemController.GetFingerPointLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector APavlovItemController::GetFingerPointLocation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.GetFingerPointLocation");

	APavlovItemController_GetFingerPointLocation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A87A0
//		Name   -> Function Pavlov.PavlovItemController.ForceTwoHandGrip
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovItemController::ForceTwoHandGrip()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.ForceTwoHandGrip");

	APavlovItemController_ForceTwoHandGrip_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A80A0
//		Name   -> Function Pavlov.PavlovItemController.ClientEmptyGrippedHand
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
void APavlovItemController::ClientEmptyGrippedHand()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.ClientEmptyGrippedHand");

	APavlovItemController_ClientEmptyGrippedHand_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8080
//		Name   -> Function Pavlov.PavlovItemController.ClearWheelInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovItemController::ClearWheelInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovItemController.ClearWheelInstance");

	APavlovItemController_ClearWheelInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.GhostItemController.OnPointModeChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		Pavlov_EGhostPointMode                             OldPointMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGhostItemController::OnPointModeChanged(Pavlov_EGhostPointMode OldPointMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostItemController.OnPointModeChanged");

	AGhostItemController_OnPointModeChanged_Params params {};
	params.OldPointMode = OldPointMode;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067DFB0
//		Name   -> Function Pavlov.GhostItemController.ChangePointMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EGhostPointMode                             NewPointMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGhostItemController::ChangePointMode(Pavlov_EGhostPointMode NewPointMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostItemController.ChangePointMode");

	AGhostItemController_ChangePointMode_Params params {};
	params.NewPointMode = NewPointMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B03A0
//		Name   -> Function Pavlov.PavlovPawnBase.GetNonDominantController
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovItemController*                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovItemController* APavlovPawnBase::GetNonDominantController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawnBase.GetNonDominantController");

	APavlovPawnBase_GetNonDominantController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0350
//		Name   -> Function Pavlov.PavlovPawnBase.GetDominantController
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovItemController*                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovItemController* APavlovPawnBase::GetDominantController()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawnBase.GetDominantController");

	APavlovPawnBase_GetDominantController_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F190
//		Name   -> Function Pavlov.GhostPawn.SpawnTags
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AGhostPawn::SpawnTags()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.SpawnTags");

	AGhostPawn_SpawnTags_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.GhostPawn.OnTraveledToSpectatorRoom
//		Flags  -> (Event, Protected, BlueprintEvent)
void AGhostPawn::OnTraveledToSpectatorRoom()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.OnTraveledToSpectatorRoom");

	AGhostPawn_OnTraveledToSpectatorRoom_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.GhostPawn.OnTeamIdChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGhostPawn::OnTeamIdChanged(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.OnTeamIdChanged");

	AGhostPawn_OnTeamIdChanged_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.GhostPawn.OnGraceTimeEnded
//		Flags  -> (Event, Public, BlueprintEvent)
void AGhostPawn::OnGraceTimeEnded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.OnGraceTimeEnded");

	AGhostPawn_OnGraceTimeEnded_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E180
//		Name   -> Function Pavlov.GhostPawn.EndGraceTime
//		Flags  -> (Final, Native, Protected)
void AGhostPawn::EndGraceTime()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.EndGraceTime");

	AGhostPawn_EndGraceTime_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E120
//		Name   -> Function Pavlov.GhostPawn.CreateVoiceComponent
//		Flags  -> (Final, Native, Protected)
void AGhostPawn::CreateVoiceComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.CreateVoiceComponent");

	AGhostPawn_CreateVoiceComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E100
//		Name   -> Function Pavlov.GhostPawn.ClientTravelToSpectatorRoom
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
void AGhostPawn::ClientTravelToSpectatorRoom()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.ClientTravelToSpectatorRoom");

	AGhostPawn_ClientTravelToSpectatorRoom_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E050
//		Name   -> Function Pavlov.GhostPawn.ClientSpawnKillCam
//		Flags  -> (Net, Native, Event, Public, NetClient)
// Parameters:
//		struct FKillInfo                                   KillInfo                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
void AGhostPawn::ClientSpawnKillCam(const struct FKillInfo& KillInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.ClientSpawnKillCam");

	AGhostPawn_ClientSpawnKillCam_Params params {};
	params.KillInfo = KillInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E030
//		Name   -> Function Pavlov.GhostPawn.ClearTags
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AGhostPawn::ClearTags()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GhostPawn.ClearTags");

	AGhostPawn_ClearTags_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067F2F0
//		Name   -> Function Pavlov.GlobalPlayerEffects.SwitchState
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EPlayerEffectState                          NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGlobalPlayerEffects::SwitchState(Pavlov_EPlayerEffectState NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GlobalPlayerEffects.SwitchState");

	AGlobalPlayerEffects_SwitchState_Params params {};
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EE40
//		Name   -> Function Pavlov.GlobalPlayerEffects.ResetGlobalEffects
//		Flags  -> (Final, Native, Public)
void AGlobalPlayerEffects::ResetGlobalEffects()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GlobalPlayerEffects.ResetGlobalEffects");

	AGlobalPlayerEffects_ResetGlobalEffects_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E530
//		Name   -> Function Pavlov.GlobalPlayerEffects.InstigateFlashVision
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ViewAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGlobalPlayerEffects::InstigateFlashVision(float Duration, float ViewAlpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GlobalPlayerEffects.InstigateFlashVision");

	AGlobalPlayerEffects_InstigateFlashVision_Params params {};
	params.Duration = Duration;
	params.ViewAlpha = ViewAlpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E470
//		Name   -> Function Pavlov.GlobalPlayerEffects.InstigateFlash
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ViewAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGlobalPlayerEffects::InstigateFlash(float Duration, float ViewAlpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GlobalPlayerEffects.InstigateFlash");

	AGlobalPlayerEffects_InstigateFlash_Params params {};
	params.Duration = Duration;
	params.ViewAlpha = ViewAlpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E350
//		Name   -> Function Pavlov.GlobalPlayerEffects.GetFlashDuration
//		Flags  -> (Final, Native, Public, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AGlobalPlayerEffects::GetFlashDuration()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GlobalPlayerEffects.GetFlashDuration");

	AGlobalPlayerEffects_GetFlashDuration_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E160
//		Name   -> Function Pavlov.GlobalPlayerEffects.DisableWindSound
//		Flags  -> (Final, Native, Public)
void AGlobalPlayerEffects::DisableWindSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GlobalPlayerEffects.DisableWindSound");

	AGlobalPlayerEffects_DisableWindSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EF60
//		Name   -> Function Pavlov.Grenade.ServerRestoreSafetyPin
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void AGrenade::ServerRestoreSafetyPin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.ServerRestoreSafetyPin");

	AGrenade_ServerRestoreSafetyPin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EF10
//		Name   -> Function Pavlov.Grenade.ServerRemoveSafetyPin
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void AGrenade::ServerRemoveSafetyPin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.ServerRemoveSafetyPin");

	AGrenade_ServerRemoveSafetyPin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EE60
//		Name   -> Function Pavlov.Grenade.ServerReleaseSafetyLever
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		float                                              PinPull                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGrenade::ServerReleaseSafetyLever(float PinPull)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.ServerReleaseSafetyLever");

	AGrenade_ServerReleaseSafetyLever_Params params {};
	params.PinPull = PinPull;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EE00
//		Name   -> Function Pavlov.Grenade.RemoveSafetyPin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AGrenade::RemoveSafetyPin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.RemoveSafetyPin");

	AGrenade_RemoveSafetyPin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067ED80
//		Name   -> Function Pavlov.Grenade.ReleaseSafetyLever
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              PinPull                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGrenade::ReleaseSafetyLever(float PinPull)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.ReleaseSafetyLever");

	AGrenade_ReleaseSafetyLever_Params params {};
	params.PinPull = PinPull;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067ED00
//		Name   -> Function Pavlov.Grenade.PullSafetyPin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Ratio                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGrenade::PullSafetyPin(float Ratio)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.PullSafetyPin");

	AGrenade_PullSafetyPin_Params params {};
	params.Ratio = Ratio;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.Grenade.OnRep_ProjectileActive
//		Flags  -> (Final, Native, Protected)
void AGrenade::OnRep_ProjectileActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.OnRep_ProjectileActive");

	AGrenade_OnRep_ProjectileActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EB30
//		Name   -> Function Pavlov.Grenade.OnReleaseSafetyLever
//		Flags  -> (Final, Native, Public)
void AGrenade::OnReleaseSafetyLever()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.OnReleaseSafetyLever");

	AGrenade_OnReleaseSafetyLever_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EA50
//		Name   -> Function Pavlov.Grenade.OnProjectileStop
//		Flags  -> (Native, Protected, HasOutParms)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void AGrenade::OnProjectileStop(const struct FHitResult& ImpactResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.OnProjectileStop");

	AGrenade_OnProjectileStop_Params params {};
	params.ImpactResult = ImpactResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E940
//		Name   -> Function Pavlov.Grenade.OnProjectileBounce
//		Flags  -> (Native, Protected, HasOutParms, HasDefaults)
// Parameters:
//		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
//		struct FVector                                     ImpactVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGrenade::OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.OnProjectileBounce");

	AGrenade_OnProjectileBounce_Params params {};
	params.ImpactResult = ImpactResult;
	params.ImpactVelocity = ImpactVelocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Grenade.OnPinReinserted
//		Flags  -> (Event, Public, BlueprintEvent)
void AGrenade::OnPinReinserted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.OnPinReinserted");

	AGrenade_OnPinReinserted_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3970
//		Name   -> Function Pavlov.Grenade.OnDetonation
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void AGrenade::OnDetonation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.OnDetonation");

	AGrenade_OnDetonation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E7F0
//		Name   -> Function Pavlov.Grenade.MulticastThrow
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		struct FVector                                     Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGrenade::MulticastThrow(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Velocity)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.MulticastThrow");

	AGrenade_MulticastThrow_Params params {};
	params.Location = Location;
	params.Rotation = Rotation;
	params.Velocity = Velocity;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA610
//		Name   -> Function Pavlov.Grenade.MulticastOnSafetyPinRemoved
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void AGrenade::MulticastOnSafetyPinRemoved()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.MulticastOnSafetyPinRemoved");

	AGrenade_MulticastOnSafetyPinRemoved_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E7D0
//		Name   -> Function Pavlov.Grenade.MulticastOnReleaseSafetyLever
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void AGrenade::MulticastOnReleaseSafetyLever()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.MulticastOnReleaseSafetyLever");

	AGrenade_MulticastOnReleaseSafetyLever_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675B60
//		Name   -> Function Pavlov.Grenade.MulticastOnDetonation
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void AGrenade::MulticastOnDetonation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.MulticastOnDetonation");

	AGrenade_MulticastOnDetonation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E380
//		Name   -> Function Pavlov.Grenade.GetHolidayLeverSound
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class USoundCue*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundCue* AGrenade::GetHolidayLeverSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.GetHolidayLeverSound");

	AGrenade_GetHolidayLeverSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E1A0
//		Name   -> Function Pavlov.Grenade.FixClientPin
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void AGrenade::FixClientPin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.FixClientPin");

	AGrenade_FixClientPin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E140
//		Name   -> Function Pavlov.Grenade.Detonate
//		Flags  -> (Native, Public, BlueprintCallable)
void AGrenade::Detonate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.Detonate");

	AGrenade_Detonate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067DF80
//		Name   -> Function Pavlov.Grenade.CanPullPin
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGrenade::CanPullPin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Grenade.CanPullPin");

	AGrenade_CanPullPin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F3F0
//		Name   -> Function Pavlov.Gun.UpdateCanRemoveAttachments
//		Flags  -> (Final, Native, Private)
void AGun::UpdateCanRemoveAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.UpdateCanRemoveAttachments");

	AGun_UpdateCanRemoveAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067F3A0
//		Name   -> Function Pavlov.Gun.ToggleAccessory_Server
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void AGun::ToggleAccessory_Server()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.ToggleAccessory_Server");

	AGun_ToggleAccessory_Server_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067F370
//		Name   -> Function Pavlov.Gun.ToggleAccessory
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::ToggleAccessory()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.ToggleAccessory");

	AGun_ToggleAccessory_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F2C0
//		Name   -> Function Pavlov.Gun.SupportsSuppressorAttachments
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::SupportsSuppressorAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SupportsSuppressorAttachments");

	AGun_SupportsSuppressorAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F290
//		Name   -> Function Pavlov.Gun.SupportsSightAttachments
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::SupportsSightAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SupportsSightAttachments");

	AGun_SupportsSightAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F260
//		Name   -> Function Pavlov.Gun.SupportsGripAttachments
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::SupportsGripAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SupportsGripAttachments");

	AGun_SupportsGripAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F230
//		Name   -> Function Pavlov.Gun.SupportsCantedAttachments
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::SupportsCantedAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SupportsCantedAttachments");

	AGun_SupportsCantedAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F200
//		Name   -> Function Pavlov.Gun.SupportsAttachments
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::SupportsAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SupportsAttachments");

	AGun_SupportsAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F1D0
//		Name   -> Function Pavlov.Gun.SupportsAccessoryAttachments
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::SupportsAccessoryAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SupportsAccessoryAttachments");

	AGun_SupportsAccessoryAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067F1B0
//		Name   -> Function Pavlov.Gun.StartSlideInputSound
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AGun::StartSlideInputSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.StartSlideInputSound");

	AGun_StartSlideInputSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067F170
//		Name   -> Function Pavlov.Gun.SpawnAndAttachLowEndSight
//		Flags  -> (Final, Native, Private)
void AGun::SpawnAndAttachLowEndSight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SpawnAndAttachLowEndSight");

	AGun_SpawnAndAttachLowEndSight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067F0F0
//		Name   -> Function Pavlov.Gun.SlideInputSound
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              SlideInput                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::SlideInputSound(float SlideInput)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SlideInputSound");

	AGun_SlideInputSound_Params params {};
	params.SlideInput = SlideInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067F070
//		Name   -> Function Pavlov.Gun.SetupBulletSkin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UStaticMeshComponent*                        BulletMesh                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::SetupBulletSkin(class UStaticMeshComponent* BulletMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SetupBulletSkin");

	AGun_SetupBulletSkin_Params params {};
	params.BulletMesh = BulletMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EFB0
//		Name   -> Function Pavlov.Gun.SetAccessoryDrawDistance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bLocallyOwned                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UStaticMeshComponent*                        OptimizeMesh                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::SetAccessoryDrawDistance(bool bLocallyOwned, class UStaticMeshComponent* OptimizeMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.SetAccessoryDrawDistance");

	AGun_SetAccessoryDrawDistance_Params params {};
	params.bLocallyOwned = bLocallyOwned;
	params.OptimizeMesh = OptimizeMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EE20
//		Name   -> Function Pavlov.Gun.ResetAttachmentMode
//		Flags  -> (Final, Native, Public)
void AGun::ResetAttachmentMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.ResetAttachmentMode");

	AGun_ResetAttachmentMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.RecoilDrop
//		Flags  -> (Event, Public, BlueprintEvent)
void AGun::RecoilDrop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.RecoilDrop");

	AGun_RecoilDrop_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EC70
//		Name   -> Function Pavlov.Gun.OptimizeGun
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bLocallyOwned                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::OptimizeGun(bool bLocallyOwned)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OptimizeGun");

	AGun_OptimizeGun_Params params {};
	params.bLocallyOwned = bLocallyOwned;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.OnUnderExploitChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bUnderExploit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::OnUnderExploitChanged(bool bUnderExploit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnUnderExploitChanged");

	AGun_OnUnderExploitChanged_Params params {};
	params.bUnderExploit = bUnderExploit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.OnTwoHandGripChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::OnTwoHandGripChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnTwoHandGripChanged");

	AGun_OnTwoHandGripChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.OnSpawnUnloaded
//		Flags  -> (Event, Public, BlueprintEvent)
void AGun::OnSpawnUnloaded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnSpawnUnloaded");

	AGun_OnSpawnUnloaded_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EC50
//		Name   -> Function Pavlov.Gun.OnSliderUngrabbed
//		Flags  -> (Final, Native, Private)
void AGun::OnSliderUngrabbed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnSliderUngrabbed");

	AGun_OnSliderUngrabbed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EB70
//		Name   -> Function Pavlov.Gun.OnSliderInputReceived
//		Flags  -> (Final, Native, Private, HasDefaults)
// Parameters:
//		struct FVector                                     Input                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     InputDelta                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::OnSliderInputReceived(const struct FVector& Input, const struct FVector& InputDelta)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnSliderInputReceived");

	AGun_OnSliderInputReceived_Params params {};
	params.Input = Input;
	params.InputDelta = InputDelta;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EB50
//		Name   -> Function Pavlov.Gun.OnSliderGrabbed
//		Flags  -> (Final, Native, Private)
void AGun::OnSliderGrabbed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnSliderGrabbed");

	AGun_OnSliderGrabbed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.OnSlideModeChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bSliding                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::OnSlideModeChanged(bool bSliding)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnSlideModeChanged");

	AGun_OnSlideModeChanged_Params params {};
	params.bSliding = bSliding;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067EB10
//		Name   -> Function Pavlov.Gun.OnRecoilDropCooldown
//		Flags  -> (Final, Native, Private)
void AGun::OnRecoilDropCooldown()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnRecoilDropCooldown");

	AGun_OnRecoilDropCooldown_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.OnAttachModeChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bJustPicked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AGun::OnAttachModeChanged(bool bEnabled, bool bJustPicked)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnAttachModeChanged");

	AGun_OnAttachModeChanged_Params params {};
	params.bEnabled = bEnabled;
	params.bJustPicked = bJustPicked;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E920
//		Name   -> Function Pavlov.Gun.OnAttachmentChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void AGun::OnAttachmentChanged()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.OnAttachmentChanged");

	AGun_OnAttachmentChanged_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3FF0
//		Name   -> Function Pavlov.Gun.MulticastOnRecoilDrop
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void AGun::MulticastOnRecoilDrop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.MulticastOnRecoilDrop");

	AGun_MulticastOnRecoilDrop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E7A0
//		Name   -> Function Pavlov.Gun.IsUnderExploit
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::IsUnderExploit()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.IsUnderExploit");

	AGun_IsUnderExploit_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E770
//		Name   -> Function Pavlov.Gun.IsInAttachmentMode
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::IsInAttachmentMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.IsInAttachmentMode");

	AGun_IsInAttachmentMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E6E0
//		Name   -> Function Pavlov.Gun.IsBeingGrippedBy
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APavlovItemController*                       ByController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::IsBeingGrippedBy(class APavlovItemController* ByController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.IsBeingGrippedBy");

	AGun_IsBeingGrippedBy_Params params {};
	params.ByController = ByController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E6B0
//		Name   -> Function Pavlov.Gun.IsBeingGripped
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::IsBeingGripped()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.IsBeingGripped");

	AGun_IsBeingGripped_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E5F0
//		Name   -> Function Pavlov.Gun.IsAttachmentCompatible
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      GunClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      AttachmentClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::STATIC_IsAttachmentCompatible(class UClass* GunClass, class UClass* AttachmentClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.IsAttachmentCompatible");

	AGun_IsAttachmentCompatible_Params params {};
	params.GunClass = GunClass;
	params.AttachmentClass = AttachmentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E3E0
//		Name   -> Function Pavlov.Gun.HasAttachment
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UClass*                                      AttachmentClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AGun::HasAttachment(class UClass* AttachmentClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.HasAttachment");

	AGun_HasAttachment_Params params {};
	params.AttachmentClass = AttachmentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E3B0
//		Name   -> Function Pavlov.Gun.GetPicatinnySlideSpacer
//		Flags  -> (Final, Native, Public, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AGun::GetPicatinnySlideSpacer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.GetPicatinnySlideSpacer");

	AGun_GetPicatinnySlideSpacer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Gun.GetChamberMesh
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UStaticMeshComponent*                        ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UStaticMeshComponent* AGun::GetChamberMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.GetChamberMesh");

	AGun_GetChamberMesh_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E2C0
//		Name   -> Function Pavlov.Gun.GetAttachmentSocket
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      AttachmentClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName AGun::GetAttachmentSocket(class UClass* AttachmentClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.GetAttachmentSocket");

	AGun_GetAttachmentSocket_Params params {};
	params.AttachmentClass = AttachmentClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E240
//		Name   -> Function Pavlov.Gun.GetAttachmentNames
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<struct FName>                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FName> AGun::GetAttachmentNames()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.GetAttachmentNames");

	AGun_GetAttachmentNames_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E1C0
//		Name   -> Function Pavlov.Gun.GetAttachmentList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<class AAttachment*>                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<class AAttachment*> AGun::GetAttachmentList()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.GetAttachmentList");

	AGun_GetAttachmentList_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067DE60
//		Name   -> Function Pavlov.Gun.BayonetDamage_Server
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FBayonetDamage                              BayonetDamage                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
void AGun::BayonetDamage_Server(const struct FBayonetDamage& BayonetDamage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Gun.BayonetDamage_Server");

	AGun_BayonetDamage_Server_Params params {};
	params.BayonetDamage = BayonetDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CA8E0
//		Name   -> Function Pavlov.SkinComponent.LoadSkin
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool USkinComponent::LoadSkin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SkinComponent.LoadSkin");

	USkinComponent_LoadSkin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006829D0
//		Name   -> Function Pavlov.GunSkinComponent.HasBulletMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UGunSkinComponent::HasBulletMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GunSkinComponent.HasBulletMaterial");

	UGunSkinComponent_HasBulletMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00682780
//		Name   -> Function Pavlov.GunSkinComponent.GetBulletMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UMaterialInterface*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UMaterialInterface* UGunSkinComponent::GetBulletMaterial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.GunSkinComponent.GetBulletMaterial");

	UGunSkinComponent_GetBulletMaterial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067B3D0
//		Name   -> Function Pavlov.HealEffectComponent.OwnerKilled
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHealEffectComponent::OwnerKilled(class AActor* Owner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HealEffectComponent.OwnerKilled");

	UHealEffectComponent_OwnerKilled_Params params {};
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682AD0
//		Name   -> Function Pavlov.HealEffectComponent.Initialize
//		Flags  -> (Final, Native, Public)
// Parameters:
//		float                                              HealTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UMaterialInterface*                          HealMat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHealEffectComponent::Initialize(float HealTime, class UMaterialInterface* HealMat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HealEffectComponent.Initialize");

	UHealEffectComponent_Initialize_Params params {};
	params.HealTime = HealTime;
	params.HealMat = HealMat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006827B0
//		Name   -> Function Pavlov.HighlightInterface.GetHighlightComponents
//		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		Pavlov_EHighlightColor                             HighlightColor                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<class UMeshComponent*>                      HighlightMeshes                                            (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void UHighlightInterface::GetHighlightComponents(Pavlov_EHighlightColor* HighlightColor, TArray<class UMeshComponent*>* HighlightMeshes)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HighlightInterface.GetHighlightComponents");

	UHighlightInterface_GetHighlightComponents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HighlightColor != nullptr)
		*HighlightColor = params.HighlightColor;
	if (HighlightMeshes != nullptr)
		*HighlightMeshes = params.HighlightMeshes;

}


// Function:
//		Offset -> 0x006C3F50
//		Name   -> Function Pavlov.RconPawn.ExitSpectator_Server
//		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
void ARconPawn::ExitSpectator_Server()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.RconPawn.ExitSpectator_Server");

	ARconPawn_ExitSpectator_Server_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4E90
//		Name   -> Function Pavlov.RepairTool.RepairVehicle
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ARepairTool::RepairVehicle(class AActor* Vehicle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.RepairTool.RepairVehicle");

	ARepairTool_RepairVehicle_Params params {};
	params.Vehicle = Vehicle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C3D50
//		Name   -> Function Pavlov.RepairTool.CanRepairVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      RepairActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bNoTeams                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ARepairTool::CanRepairVehicle(class AActor* RepairActor, bool bNoTeams, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.RepairTool.CanRepairVehicle");

	ARepairTool_CanRepairVehicle_Params params {};
	params.RepairActor = RepairActor;
	params.bNoTeams = bNoTeams;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C4DD0
//		Name   -> Function Pavlov.ReplayManager.PlayReplay
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ReplayId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UReplayManager::PlayReplay(const struct FString& ReplayId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ReplayManager.PlayReplay");

	UReplayManager_PlayReplay_Params params {};
	params.ReplayId = ReplayId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4950
//		Name   -> Function Pavlov.ReplayManager.OnCustomMapDownloaded
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UReplayManager::OnCustomMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ReplayManager.OnCustomMapDownloaded");

	UReplayManager_OnCustomMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C3FA0
//		Name   -> Function Pavlov.ReplayManager.Find
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     GameMode                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bCompetitive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UReplayManager::Find(const struct FString& GameMode, bool bCompetitive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ReplayManager.Find");

	UReplayManager_Find_Params params {};
	params.GameMode = GameMode;
	params.bCompetitive = bCompetitive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C51E0
//		Name   -> Function Pavlov.ReviveTool.SetNumOfRevives
//		Flags  -> (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                AmountOfRevives                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AReviveTool::SetNumOfRevives(int AmountOfRevives)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ReviveTool.SetNumOfRevives");

	AReviveTool_SetNumOfRevives_Params params {};
	params.AmountOfRevives = AmountOfRevives;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006909F0
//		Name   -> Function Pavlov.ReviveTool.GetNumOfRevives
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int AReviveTool::GetNumOfRevives()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ReviveTool.GetNumOfRevives");

	AReviveTool_GetNumOfRevives_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C4F20
//		Name   -> Function Pavlov.RevolverGunState.SetCylinder
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bOpen                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void URevolverGunState::SetCylinder(bool bOpen)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.RevolverGunState.SetCylinder");

	URevolverGunState_SetCylinder_Params params {};
	params.bOpen = bOpen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5160
//		Name   -> Function Pavlov.RockerLauncherGunState.SetLauncherState
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_ELauncherState                              State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void URockerLauncherGunState::SetLauncherState(Pavlov_ELauncherState State)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.RockerLauncherGunState.SetLauncherState");

	URockerLauncherGunState_SetLauncherState_Params params {};
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C3E50
//		Name   -> Function Pavlov.RockerLauncherGunState.ChamberChanged
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                ChamberIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		VRFramework_EVRGunChamberState                     OldState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		VRFramework_EVRGunChamberState                     NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void URockerLauncherGunState::ChamberChanged(int ChamberIndex, VRFramework_EVRGunChamberState OldState, VRFramework_EVRGunChamberState NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.RockerLauncherGunState.ChamberChanged");

	URockerLauncherGunState_ChamberChanged_Params params {};
	params.ChamberIndex = ChamberIndex;
	params.OldState = OldState;
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683060
//		Name   -> Function Pavlov.HitBoxProxyComponent.OnBulletOverlap
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void UHitBoxProxyComponent::OnBulletOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HitBoxProxyComponent.OnBulletOverlap");

	UHitBoxProxyComponent_OnBulletOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683870
//		Name   -> Function Pavlov.HolsterComponent.TakeItem
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovItemController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHolsterComponent::TakeItem(class APavlovItemController* Controller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.TakeItem");

	UHolsterComponent_TakeItem_Params params {};
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683500
//		Name   -> Function Pavlov.HolsterComponent.ServerTakeItem
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class APavlovItemController*                       Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHolsterComponent::ServerTakeItem(class APavlovItemController* Controller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.ServerTakeItem");

	UHolsterComponent_ServerTakeItem_Params params {};
	params.Controller = Controller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683440
//		Name   -> Function Pavlov.HolsterComponent.ServerHolster
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class AVRItem*                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHolsterComponent::ServerHolster(class AVRItem* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.ServerHolster");

	UHolsterComponent_ServerHolster_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.HolsterComponent.OnRep_HolsteredItem
//		Flags  -> (Final, Native, Private)
void UHolsterComponent::OnRep_HolsteredItem()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.OnRep_HolsteredItem");

	UHolsterComponent_OnRep_HolsteredItem_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682CD0
//		Name   -> Function Pavlov.HolsterComponent.MulticastOnItemHolstered
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		class AVRItem*                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHolsterComponent::MulticastOnItemHolstered(class AVRItem* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.MulticastOnItemHolstered");

	UHolsterComponent_MulticastOnItemHolstered_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682C40
//		Name   -> Function Pavlov.HolsterComponent.MulticastOnDrop
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		class AVRItem*                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHolsterComponent::MulticastOnDrop(class AVRItem* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.MulticastOnDrop");

	UHolsterComponent_MulticastOnDrop_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682C20
//		Name   -> Function Pavlov.HolsterComponent.Mirror
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UHolsterComponent::Mirror()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.Mirror");

	UHolsterComponent_Mirror_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682A50
//		Name   -> Function Pavlov.HolsterComponent.Holster
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AVRItem*                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UHolsterComponent::Holster(class AVRItem* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.Holster");

	UHolsterComponent_Holster_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006826F0
//		Name   -> Function Pavlov.HolsterComponent.Drop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UHolsterComponent::Drop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.Drop");

	UHolsterComponent_Drop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682690
//		Name   -> Function Pavlov.HolsterComponent.AttachItemLocally
//		Flags  -> (Final, Native, Private)
void UHolsterComponent::AttachItemLocally()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.HolsterComponent.AttachItemLocally");

	UHolsterComponent_AttachItemLocally_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006825B0
//		Name   -> Function Pavlov.IconRemover.AddIcons
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<class UPrimitiveComponent*>                 IconArray                                                  (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void UIconRemover::AddIcons(TArray<class UPrimitiveComponent*> IconArray)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.IconRemover.AddIcons");

	UIconRemover_AddIcons_Params params {};
	params.IconArray = IconArray;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682530
//		Name   -> Function Pavlov.IconRemover.AddIcon
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class UPrimitiveComponent*                         Icon                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UIconRemover::AddIcon(class UPrimitiveComponent* Icon)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.IconRemover.AddIcon");

	UIconRemover_AddIcon_Params params {};
	params.Icon = Icon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00213C10
//		Name   -> Function Pavlov.ImpairInterface.MarkAsImpaired
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
//		Pavlov_EImpairedType                               Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      EventActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 Instigator                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UImpairInterface::MarkAsImpaired(Pavlov_EImpairedType Type, class AActor* EventActor, class AController* Instigator)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ImpairInterface.MarkAsImpaired");

	UImpairInterface_MarkAsImpaired_Params params {};
	params.Type = Type;
	params.EventActor = EventActor;
	params.Instigator = Instigator;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006828B0
//		Name   -> Function Pavlov.ImpairInterface.GetImpairedEyesViewPoint
//		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
//		struct FVector                                     OutLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void UImpairInterface::GetImpairedEyesViewPoint(struct FVector* OutLocation, struct FRotator* OutRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ImpairInterface.GetImpairedEyesViewPoint");

	UImpairInterface_GetImpairedEyesViewPoint_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutLocation != nullptr)
		*OutLocation = params.OutLocation;
	if (OutRotation != nullptr)
		*OutRotation = params.OutRotation;

}


// Function:
//		Offset -> 0x00683700
//		Name   -> Function Pavlov.InstancedSourceBusComponent.SilenceAudioComponent
//		Flags  -> (Final, Native, Protected)
void UInstancedSourceBusComponent::SilenceAudioComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.InstancedSourceBusComponent.SilenceAudioComponent");

	UInstancedSourceBusComponent_SilenceAudioComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683370
//		Name   -> Function Pavlov.InstancedSourceBusComponent.Play
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bForceNoOcclusion                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAudioComponent* UInstancedSourceBusComponent::Play(class USoundBase* Sound, bool bForceNoOcclusion)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.InstancedSourceBusComponent.Play");

	UInstancedSourceBusComponent_Play_Params params {};
	params.Sound = Sound;
	params.bForceNoOcclusion = bForceNoOcclusion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006832F0
//		Name   -> Function Pavlov.InstancedSourceBusComponent.OnSourceBusAudioFinished
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class UAudioComponent*                             Comp                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UInstancedSourceBusComponent::OnSourceBusAudioFinished(class UAudioComponent* Comp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.InstancedSourceBusComponent.OnSourceBusAudioFinished");

	UInstancedSourceBusComponent_OnSourceBusAudioFinished_Params params {};
	params.Comp = Comp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682DF0
//		Name   -> Function Pavlov.InstancedSourceBusComponent.OnAudioFinished
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class UAudioComponent*                             Comp                                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UInstancedSourceBusComponent::OnAudioFinished(class UAudioComponent* Comp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.InstancedSourceBusComponent.OnAudioFinished");

	UInstancedSourceBusComponent_OnAudioFinished_Params params {};
	params.Comp = Comp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682760
//		Name   -> Function Pavlov.InstancedSourceBusComponent.GetAudioComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAudioComponent* UInstancedSourceBusComponent::GetAudioComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.InstancedSourceBusComponent.GetAudioComponent");

	UInstancedSourceBusComponent_GetAudioComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006836E0
//		Name   -> Function Pavlov.Killfeed.Show
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AKillfeed::Show()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Killfeed.Show");

	AKillfeed_Show_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Killfeed.OnDisplayModeUpdated
//		Flags  -> (Event, Public, BlueprintEvent)
void AKillfeed::OnDisplayModeUpdated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Killfeed.OnDisplayModeUpdated");

	AKillfeed_OnDisplayModeUpdated_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682D60
//		Name   -> Function Pavlov.Killfeed.OnArmKillfeedChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKillfeed::OnArmKillfeedChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Killfeed.OnArmKillfeedChanged");

	AKillfeed_OnArmKillfeedChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682A30
//		Name   -> Function Pavlov.Killfeed.Hide
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AKillfeed::Hide()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Killfeed.Hide");

	AKillfeed_Hide_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671370
//		Name   -> Function Pavlov.Knife.StartThrowSound_Multi
//		Flags  -> (Final, Net, Native, Event, NetMulticast, Private)
void AKnife::StartThrowSound_Multi()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.StartThrowSound_Multi");

	AKnife_StartThrowSound_Multi_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683850
//		Name   -> Function Pavlov.Knife.StartKnifeThrow
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void AKnife::StartKnifeThrow()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.StartKnifeThrow");

	AKnife_StartKnifeThrow_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683720
//		Name   -> Function Pavlov.Knife.SpawnKnifeProxy
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FAttachProxyInfo                            AttachInfo                                                 (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void AKnife::SpawnKnifeProxy(const struct FAttachProxyInfo& AttachInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.SpawnKnifeProxy");

	AKnife_SpawnKnifeProxy_Params params {};
	params.AttachInfo = AttachInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006835C0
//		Name   -> Function Pavlov.Knife.SetBloody
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKnife::SetBloody(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.SetBloody");

	AKnife_SetBloody_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.Knife.OnRep_Bloody
//		Flags  -> (Final, Native, Private)
void AKnife::OnRep_Bloody()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.OnRep_Bloody");

	AKnife_OnRep_Bloody_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3830
//		Name   -> Function Pavlov.Knife.OnEndOverlap
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKnife::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.OnEndOverlap");

	AKnife_OnEndOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Knife.OnBloodyChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bNewBloody                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKnife::OnBloodyChanged(bool bNewBloody)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.OnBloodyChanged");

	AKnife_OnBloodyChanged_Params params {};
	params.bNewBloody = bNewBloody;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682E70
//		Name   -> Function Pavlov.Knife.OnBeginOverlap
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void AKnife::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.OnBeginOverlap");

	AKnife_OnBeginOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA580
//		Name   -> Function Pavlov.Knife.MulticastOnStab
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bDead                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKnife::MulticastOnStab(bool bDead)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.MulticastOnStab");

	AKnife_MulticastOnStab_Params params {};
	params.bDead = bDead;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682A00
//		Name   -> Function Pavlov.Knife.HasSpawnedProxy
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AKnife::HasSpawnedProxy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.HasSpawnedProxy");

	AKnife_HasSpawnedProxy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006829A0
//		Name   -> Function Pavlov.Knife.GetKillConfirmationSound2D
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class USoundCue*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundCue* AKnife::GetKillConfirmationSound2D()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.GetKillConfirmationSound2D");

	AKnife_GetKillConfirmationSound2D_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00682730
//		Name   -> Function Pavlov.Knife.GetAlternativeStabSound
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class USoundCue*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundCue* AKnife::GetAlternativeStabSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.GetAlternativeStabSound");

	AKnife_GetAlternativeStabSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00682710
//		Name   -> Function Pavlov.Knife.EnableTicking
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AKnife::EnableTicking()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.EnableTicking");

	AKnife_EnableTicking_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006826D0
//		Name   -> Function Pavlov.Knife.DelayDestroyKnife
//		Flags  -> (Final, Native, Public)
void AKnife::DelayDestroyKnife()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.DelayDestroyKnife");

	AKnife_DelayDestroyKnife_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006826B0
//		Name   -> Function Pavlov.Knife.CheckThrowThreshold
//		Flags  -> (Final, Native, Private)
void AKnife::CheckThrowThreshold()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Knife.CheckThrowThreshold");

	AKnife_CheckThrowThreshold_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006838F0
//		Name   -> Function Pavlov.KOTHObjective.UpdateHillMaterial
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMaterialInterface*                          UpdateMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKOTHObjective::UpdateHillMaterial(class UMaterialInterface* UpdateMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.UpdateHillMaterial");

	AKOTHObjective_UpdateHillMaterial_Params params {};
	params.UpdateMaterial = UpdateMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683650
//		Name   -> Function Pavlov.KOTHObjective.SetHillActive
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKOTHObjective::SetHillActive(bool bActive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.SetHillActive");

	AKOTHObjective_SetHillActive_Params params {};
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683270
//		Name   -> Function Pavlov.KOTHObjective.OnRep_KOTHState
//		Flags  -> (Final, Native, Public)
// Parameters:
//		Pavlov_EHillState                                  OldKOTHState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKOTHObjective::OnRep_KOTHState(Pavlov_EHillState OldKOTHState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.OnRep_KOTHState");

	AKOTHObjective_OnRep_KOTHState_Params params {};
	params.OldKOTHState = OldKOTHState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00683250
//		Name   -> Function Pavlov.KOTHObjective.OnRep_KOTHProxy
//		Flags  -> (Final, Native, Protected)
void AKOTHObjective::OnRep_KOTHProxy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.OnRep_KOTHProxy");

	AKOTHObjective_OnRep_KOTHProxy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.KOTHObjective.OnObjectiveInitialized
//		Flags  -> (Event, Public, BlueprintEvent)
void AKOTHObjective::OnObjectiveInitialized()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.OnObjectiveInitialized");

	AKOTHObjective_OnObjectiveInitialized_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218B10
//		Name   -> Function Pavlov.KOTHObjective.OnHillActive
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void AKOTHObjective::OnHillActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.OnHillActive");

	AKOTHObjective_OnHillActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682BA0
//		Name   -> Function Pavlov.KOTHObjective.InitializeFromProxy
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class AKOTHObjectiveProxy*                         ObjectiveProxy                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AKOTHObjective::InitializeFromProxy(class AKOTHObjectiveProxy* ObjectiveProxy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.KOTHObjective.InitializeFromProxy");

	AKOTHObjective_InitializeFromProxy_Params params {};
	params.ObjectiveProxy = ObjectiveProxy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006889B0
//		Name   -> Function Pavlov.LimitedAmmoComponent.ShowLimitedAmmoCounter
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bCounterVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ULimitedAmmoComponent::ShowLimitedAmmoCounter(bool bCounterVisible)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.ShowLimitedAmmoCounter");

	ULimitedAmmoComponent_ShowLimitedAmmoCounter_Params params {};
	params.bCounterVisible = bCounterVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688930
//		Name   -> Function Pavlov.LimitedAmmoComponent.SetupAmmoUI_Server
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ULimitedAmmoComponent::SetupAmmoUI_Server(class APavlovPawn* PavPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.SetupAmmoUI_Server");

	ULimitedAmmoComponent_SetupAmmoUI_Server_Params params {};
	params.PavPawn = PavPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00217B10
//		Name   -> Function Pavlov.LimitedAmmoComponent.SetupAmmoCounter_Client
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void ULimitedAmmoComponent::SetupAmmoCounter_Client()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.SetupAmmoCounter_Client");

	ULimitedAmmoComponent_SetupAmmoCounter_Client_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688590
//		Name   -> Function Pavlov.LimitedAmmoComponent.RemoveAmmo
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                RemoveAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int ULimitedAmmoComponent::RemoveAmmo(VRFramework_EAmmoType AmmoType, int RemoveAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.RemoveAmmo");

	ULimitedAmmoComponent_RemoveAmmo_Params params {};
	params.AmmoType = AmmoType;
	params.RemoveAmount = RemoveAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006715D0
//		Name   -> Function Pavlov.LimitedAmmoComponent.PlayerDied
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPawn*                                 Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ULimitedAmmoComponent::PlayerDied(class APavlovPawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.PlayerDied");

	ULimitedAmmoComponent_PlayerDied_Params params {};
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687D90
//		Name   -> Function Pavlov.LimitedAmmoComponent.MagToAmmo
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class AVRMagazine*                                 Mag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULimitedAmmoComponent::MagToAmmo(class AVRMagazine* Mag)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.MagToAmmo");

	ULimitedAmmoComponent_MagToAmmo_Params params {};
	params.Mag = Mag;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687AB0
//		Name   -> Function Pavlov.LimitedAmmoComponent.HasAmmoOfType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULimitedAmmoComponent::HasAmmoOfType(VRFramework_EAmmoType AmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.HasAmmoOfType");

	ULimitedAmmoComponent_HasAmmoOfType_Params params {};
	params.AmmoType = AmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006879E0
//		Name   -> Function Pavlov.LimitedAmmoComponent.GiveAmmoForBuy
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		class AVRGun*                                      Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                AmmoLimit                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULimitedAmmoComponent::GiveAmmoForBuy(class AVRGun* Gun, int AmmoLimit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GiveAmmoForBuy");

	ULimitedAmmoComponent_GiveAmmoForBuy_Params params {};
	params.Gun = Gun;
	params.AmmoLimit = AmmoLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006876D0
//		Name   -> Function Pavlov.LimitedAmmoComponent.GetGunAmmoType
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class AVRGun*                                      Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		VRFramework_EAmmoType                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
VRFramework_EAmmoType ULimitedAmmoComponent::STATIC_GetGunAmmoType(class AVRGun* Gun)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GetGunAmmoType");

	ULimitedAmmoComponent_GetGunAmmoType_Params params {};
	params.Gun = Gun;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687540
//		Name   -> Function Pavlov.LimitedAmmoComponent.GetAmmoTypeName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName ULimitedAmmoComponent::GetAmmoTypeName(VRFramework_EAmmoType AmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GetAmmoTypeName");

	ULimitedAmmoComponent_GetAmmoTypeName_Params params {};
	params.AmmoType = AmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687470
//		Name   -> Function Pavlov.LimitedAmmoComponent.GetAmmoTypeFromName
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       AmmoId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULimitedAmmoComponent::GetAmmoTypeFromName(const struct FName& AmmoId, VRFramework_EAmmoType* AmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GetAmmoTypeFromName");

	ULimitedAmmoComponent_GetAmmoTypeFromName_Params params {};
	params.AmmoId = AmmoId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (AmmoType != nullptr)
		*AmmoType = params.AmmoType;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006873E0
//		Name   -> Function Pavlov.LimitedAmmoComponent.GetAmmoClassFromType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* ULimitedAmmoComponent::GetAmmoClassFromType(VRFramework_EAmmoType AmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GetAmmoClassFromType");

	ULimitedAmmoComponent_GetAmmoClassFromType_Params params {};
	params.AmmoType = AmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687350
//		Name   -> Function Pavlov.LimitedAmmoComponent.GetAmmoClassFromName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       AmmoId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* ULimitedAmmoComponent::GetAmmoClassFromName(const struct FName& AmmoId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GetAmmoClassFromName");

	ULimitedAmmoComponent_GetAmmoClassFromName_Params params {};
	params.AmmoId = AmmoId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006872C0
//		Name   -> Function Pavlov.LimitedAmmoComponent.GetAmmoAmount
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int ULimitedAmmoComponent::GetAmmoAmount(VRFramework_EAmmoType AmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.GetAmmoAmount");

	ULimitedAmmoComponent_GetAmmoAmount_Params params {};
	params.AmmoType = AmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00686D00
//		Name   -> Function Pavlov.LimitedAmmoComponent.AddBulkAmmo
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TMap<VRFramework_EAmmoType, int>                   BulkAmmo                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
void ULimitedAmmoComponent::AddBulkAmmo(TMap<VRFramework_EAmmoType, int> BulkAmmo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.AddBulkAmmo");

	ULimitedAmmoComponent_AddBulkAmmo_Params params {};
	params.BulkAmmo = BulkAmmo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00686C30
//		Name   -> Function Pavlov.LimitedAmmoComponent.AddAmmo
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int ULimitedAmmoComponent::AddAmmo(VRFramework_EAmmoType AmmoType, int Amount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoComponent.AddAmmo");

	ULimitedAmmoComponent_AddAmmo_Params params {};
	params.AmmoType = AmmoType;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00682460
//		Name   -> Function Pavlov.LimitedAmmoBoxlessComponent.AddAmmoBox
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULimitedAmmoBoxlessComponent::AddAmmoBox(VRFramework_EAmmoType AmmoType, int Amount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoBoxlessComponent.AddAmmoBox");

	ULimitedAmmoBoxlessComponent_AddAmmoBox_Params params {};
	params.AmmoType = AmmoType;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.LimitedAmmoCounter.ShowAmmoCounter
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ALimitedAmmoCounter::ShowAmmoCounter(bool bVisible)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LimitedAmmoCounter.ShowAmmoCounter");

	ALimitedAmmoCounter_ShowAmmoCounter_Params params {};
	params.bVisible = bVisible;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688660
//		Name   -> Function Pavlov.LoadoutData.RemoveLoadout
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULoadoutData::RemoveLoadout(const struct FString& LoadoutName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LoadoutData.RemoveLoadout");

	ULoadoutData_RemoveLoadout_Params params {};
	params.LoadoutName = LoadoutName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00688560
//		Name   -> Function Pavlov.LoadoutData.PropertiesToJson
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UJsonUtilsObj*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UJsonUtilsObj* ULoadoutData::PropertiesToJson()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LoadoutData.PropertiesToJson");

	ULoadoutData_PropertiesToJson_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687CA0
//		Name   -> Function Pavlov.LoadoutData.JsonStringToLoadoutProperties
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     JsonString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULoadoutData::JsonStringToLoadoutProperties(const struct FString& JsonString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LoadoutData.JsonStringToLoadoutProperties");

	ULoadoutData_JsonStringToLoadoutProperties_Params params {};
	params.JsonString = JsonString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687120
//		Name   -> Function Pavlov.LoadoutData.CreateLoadoutProperties
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     JsonString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class ULoadoutData*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class ULoadoutData* ULoadoutData::CreateLoadoutProperties(const struct FString& JsonString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LoadoutData.CreateLoadoutProperties");

	ULoadoutData_CreateLoadoutProperties_Params params {};
	params.JsonString = JsonString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00686FD0
//		Name   -> Function Pavlov.LoadoutData.CanUseLoadout
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ULoadoutData::CanUseLoadout(class APavlovPlayerState* PlayerState, const struct FString& LoadoutName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LoadoutData.CanUseLoadout");

	ULoadoutData_CanUseLoadout_Params params {};
	params.PlayerState = PlayerState;
	params.LoadoutName = LoadoutName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00686E00
//		Name   -> Function Pavlov.LoadoutData.AddLoadout
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     LoadoutName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FLoadout                                    Loadout                                                    (Parm, NativeAccessSpecifierPublic)
void ULoadoutData::AddLoadout(const struct FString& LoadoutName, const struct FLoadout& Loadout)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LoadoutData.AddLoadout");

	ULoadoutData_AddLoadout_Params params {};
	params.LoadoutName = LoadoutName;
	params.Loadout = Loadout;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688040
//		Name   -> Function Pavlov.LobbyStatusModel.OnLobbyStatusMessage
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FString                                     InMessage                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bInDownloading                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              InProgress                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ULobbyStatusModel::OnLobbyStatusMessage(const struct FString& InMessage, bool bInDownloading, float InProgress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LobbyStatusModel.OnLobbyStatusMessage");

	ULobbyStatusModel_OnLobbyStatusMessage_Params params {};
	params.InMessage = InMessage;
	params.bInDownloading = bInDownloading;
	params.InProgress = InProgress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688750
//		Name   -> Function Pavlov.LootSpawner.SetLootIndexByName
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bNetUpdate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ALootSpawner::SetLootIndexByName(const struct FName& Name, bool bNetUpdate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.SetLootIndexByName");

	ALootSpawner_SetLootIndexByName_Params params {};
	params.Name = Name;
	params.bNetUpdate = bNetUpdate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688300
//		Name   -> Function Pavlov.LootSpawner.OnRep_LootIndex
//		Flags  -> (Final, Native, Protected)
void ALootSpawner::OnRep_LootIndex()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.OnRep_LootIndex");

	ALootSpawner_OnRep_LootIndex_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688160
//		Name   -> Function Pavlov.LootSpawner.OnLootChanged
//		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		unsigned char                                      Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ALootSpawner::OnLootChanged(unsigned char Index, const struct FName& Name)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.OnLootChanged");

	ALootSpawner_OnLootChanged_Params params {};
	params.Index = Index;
	params.Name = Name;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687E30
//		Name   -> Function Pavlov.LootSpawner.NetworkUpdate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ALootSpawner::NetworkUpdate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.NetworkUpdate");

	ALootSpawner_NetworkUpdate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687B70
//		Name   -> Function Pavlov.LootSpawner.IsClear
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool ALootSpawner::IsClear()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.IsClear");

	ALootSpawner_IsClear_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687830
//		Name   -> Function Pavlov.LootSpawner.GetLootNameByIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		unsigned char                                      Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName ALootSpawner::GetLootNameByIndex(unsigned char Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.GetLootNameByIndex");

	ALootSpawner_GetLootNameByIndex_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006877F0
//		Name   -> Function Pavlov.LootSpawner.GetLootName
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName ALootSpawner::GetLootName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.GetLootName");

	ALootSpawner_GetLootName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687750
//		Name   -> Function Pavlov.LootSpawner.GetLootIndexByName
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
unsigned char ALootSpawner::GetLootIndexByName(const struct FName& Name)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.GetLootIndexByName");

	ALootSpawner_GetLootIndexByName_Params params {};
	params.Name = Name;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687100
//		Name   -> Function Pavlov.LootSpawner.ClearLoot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ALootSpawner::ClearLoot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.LootSpawner.ClearLoot");

	ALootSpawner_ClearLoot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.MainMenu.OnUpdateScoreboard
//		Flags  -> (Event, Public, BlueprintEvent)
void AMainMenu::OnUpdateScoreboard()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MainMenu.OnUpdateScoreboard");

	AMainMenu_OnUpdateScoreboard_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006884B0
//		Name   -> Function Pavlov.MainMenuView.OnVoteKickModalCommit
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void AMainMenuView::OnVoteKickModalCommit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MainMenuView.OnVoteKickModalCommit");

	AMainMenuView_OnVoteKickModalCommit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675C10
//		Name   -> Function Pavlov.MainMenuView.LeaveImpl
//		Flags  -> (Final, Native, Protected)
void AMainMenuView::LeaveImpl()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MainMenuView.LeaveImpl");

	AMainMenuView_LeaveImpl_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687260
//		Name   -> Function Pavlov.MainMenuView.ExitGameImpl
//		Flags  -> (Final, Native, Protected)
void AMainMenuView::ExitGameImpl()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MainMenuView.ExitGameImpl");

	AMainMenuView_ExitGameImpl_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006883E0
//		Name   -> Function Pavlov.MapBrowserModel.OnSubscritionChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bSubscribed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMapBrowserModel::OnSubscritionChanged(const struct FName& ID, bool bSubscribed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnSubscritionChanged");

	UMapBrowserModel_OnSubscritionChanged_Params params {};
	params.ID = ID;
	params.bSubscribed = bSubscribed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688320
//		Name   -> Function Pavlov.MapBrowserModel.OnRequestUserVote
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EWorkshopVoteType                           VoteType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMapBrowserModel::OnRequestUserVote(const struct FName& ID, Pavlov_EWorkshopVoteType VoteType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnRequestUserVote");

	UMapBrowserModel_OnRequestUserVote_Params params {};
	params.ID = ID;
	params.VoteType = VoteType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00688240
//		Name   -> Function Pavlov.MapBrowserModel.OnPreviewLoaded
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMapBrowserModel::OnPreviewLoaded(const struct FName& ID, class UTexture2D* Texture)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnPreviewLoaded");

	UMapBrowserModel_OnPreviewLoaded_Params params {};
	params.ID = ID;
	params.Texture = Texture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687FC0
//		Name   -> Function Pavlov.MapBrowserModel.OnDownloadProgress
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		float                                              Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMapBrowserModel::OnDownloadProgress(float Progress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnDownloadProgress");

	UMapBrowserModel_OnDownloadProgress_Params params {};
	params.Progress = Progress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687FA0
//		Name   -> Function Pavlov.MapBrowserModel.OnDownloadBegin
//		Flags  -> (Final, Native, Protected)
void UMapBrowserModel::OnDownloadBegin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnDownloadBegin");

	UMapBrowserModel_OnDownloadBegin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687FA0
//		Name   -> Function Pavlov.MapBrowserModel.OnCustomMapQueryCompleted
//		Flags  -> (Final, Native, Protected)
void UMapBrowserModel::OnCustomMapQueryCompleted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnCustomMapQueryCompleted");

	UMapBrowserModel_OnCustomMapQueryCompleted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687E70
//		Name   -> Function Pavlov.MapBrowserModel.OnCustomMapDownloadCompleted
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMapBrowserModel::OnCustomMapDownloadCompleted(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnCustomMapDownloadCompleted");

	UMapBrowserModel_OnCustomMapDownloadCompleted_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687E50
//		Name   -> Function Pavlov.MapBrowserModel.OnArtificialQueryCompleted
//		Flags  -> (Final, Native, Protected)
void UMapBrowserModel::OnArtificialQueryCompleted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapBrowserModel.OnArtificialQueryCompleted");

	UMapBrowserModel_OnArtificialQueryCompleted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006872A0
//		Name   -> Function Pavlov.MapValidator.GenerateNewColors
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMapValidator::GenerateNewColors()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapValidator.GenerateNewColors");

	AMapValidator_GenerateNewColors_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687280
//		Name   -> Function Pavlov.MapValidator.FlushDebugPoints
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMapValidator::FlushDebugPoints()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapValidator.FlushDebugPoints");

	AMapValidator_FlushDebugPoints_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687240
//		Name   -> Function Pavlov.MapValidator.DrawReflectionCaptureView
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMapValidator::DrawReflectionCaptureView()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MapValidator.DrawReflectionCaptureView");

	AMapValidator_DrawReflectionCaptureView_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687210
//		Name   -> Function Pavlov.Matchmaking.UpdatePartyList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::UpdatePartyList()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.UpdatePartyList");

	UMatchmaking_UpdatePartyList_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00688820
//		Name   -> Function Pavlov.Matchmaking.SetSettings
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FMatchSettings                              NewSettings                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UMatchmaking::SetSettings(const struct FMatchSettings& NewSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.SetSettings");

	UMatchmaking_SetSettings_Params params {};
	params.NewSettings = NewSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.Matchmaking.SetDefaultSettings
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMatchmaking::SetDefaultSettings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.SetDefaultSettings");

	UMatchmaking_SetDefaultSettings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687210
//		Name   -> Function Pavlov.Matchmaking.Queue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::Queue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.Queue");

	UMatchmaking_Queue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.Matchmaking.LeaveParty
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMatchmaking::LeaveParty()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.LeaveParty");

	UMatchmaking_LeaveParty_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687BF0
//		Name   -> Function Pavlov.Matchmaking.JoinParty
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     NetworkStr                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::JoinParty(const struct FString& NetworkStr)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.JoinParty");

	UMatchmaking_JoinParty_Params params {};
	params.NetworkStr = NetworkStr;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687B40
//		Name   -> Function Pavlov.Matchmaking.IsInQueue
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::IsInQueue()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.IsInQueue");

	UMatchmaking_IsInQueue_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687BA0
//		Name   -> Function Pavlov.Matchmaking.IsConnectingToServer
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::IsConnectingToServer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.IsConnectingToServer");

	UMatchmaking_IsConnectingToServer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687B40
//		Name   -> Function Pavlov.Matchmaking.IsActive
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::IsActive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.IsActive");

	UMatchmaking_IsActive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006875D0
//		Name   -> Function Pavlov.Matchmaking.GetPlayerTitleId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UMatchmaking::GetPlayerTitleId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.GetPlayerTitleId");

	UMatchmaking_GetPlayerTitleId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006875D0
//		Name   -> Function Pavlov.Matchmaking.GetPlayerPlayFabId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UMatchmaking::GetPlayerPlayFabId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.GetPlayerPlayFabId");

	UMatchmaking_GetPlayerPlayFabId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006879C0
//		Name   -> Function Pavlov.Matchmaking.GetPartyInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UMatchmakingParty*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UMatchmakingParty* UMatchmaking::GetPartyInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.GetPartyInstance");

	UMatchmaking_GetPartyInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687650
//		Name   -> Function Pavlov.Matchmaking.GetEntityType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UMatchmaking::GetEntityType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.GetEntityType");

	UMatchmaking_GetEntityType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006875D0
//		Name   -> Function Pavlov.Matchmaking.GetEntityToken
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UMatchmaking::GetEntityToken()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.GetEntityToken");

	UMatchmaking_GetEntityToken_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006875D0
//		Name   -> Function Pavlov.Matchmaking.GetEntityId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UMatchmaking::GetEntityId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.GetEntityId");

	UMatchmaking_GetEntityId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687210
//		Name   -> Function Pavlov.Matchmaking.CreateParty
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmaking::CreateParty()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.CreateParty");

	UMatchmaking_CreateParty_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.Matchmaking.Cancel
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMatchmaking::Cancel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Matchmaking.Cancel");

	UMatchmaking_Cancel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687BC0
//		Name   -> Function Pavlov.MatchmakingParty.IsLocalMemberLeader
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UMatchmakingParty::IsLocalMemberLeader()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MatchmakingParty.IsLocalMemberLeader");

	UMatchmakingParty_IsLocalMemberLeader_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.MatchmakingParty.Hide
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMatchmakingParty::Hide()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MatchmakingParty.Hide");

	UMatchmakingParty_Hide_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006878C0
//		Name   -> Function Pavlov.MatchmakingParty.GetMemberArray
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<struct FPartyMember>                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FPartyMember> UMatchmakingParty::GetMemberArray()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MatchmakingParty.GetMemberArray");

	UMatchmakingParty_GetMemberArray_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006875D0
//		Name   -> Function Pavlov.MatchmakingParty.GetLeaderEntityId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UMatchmakingParty::GetLeaderEntityId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MatchmakingParty.GetLeaderEntityId");

	UMatchmakingParty_GetLeaderEntityId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.MatchmakingParty.Broadcast
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UMatchmakingParty::Broadcast()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MatchmakingParty.Broadcast");

	UMatchmakingParty_Broadcast_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D530
//		Name   -> Function Pavlov.MenuUniverse.UpdateDocks
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMenuUniverse::UpdateDocks()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.UpdateDocks");

	AMenuUniverse_UpdateDocks_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D0A0
//		Name   -> Function Pavlov.MenuUniverse.SetEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::SetEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.SetEnabled");

	AMenuUniverse_SetEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218D00
//		Name   -> Function Pavlov.MenuUniverse.OnViewTargetChangingFrom
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class AActor*                                      ViewTarget                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::OnViewTargetChangingFrom(class AActor* ViewTarget)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.OnViewTargetChangingFrom");

	AMenuUniverse_OnViewTargetChangingFrom_Params params {};
	params.ViewTarget = ViewTarget;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CD00
//		Name   -> Function Pavlov.MenuUniverse.OnSideInterfaceChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		Pavlov_EUserInterfaceType                          PrimaryInterface                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EUserInterfaceType                          OldInterface                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::OnSideInterfaceChanged(Pavlov_EUserInterfaceType PrimaryInterface, Pavlov_EUserInterfaceType OldInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.OnSideInterfaceChanged");

	AMenuUniverse_OnSideInterfaceChanged_Params params {};
	params.PrimaryInterface = PrimaryInterface;
	params.OldInterface = OldInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CB60
//		Name   -> Function Pavlov.MenuUniverse.OnInterfaceChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		Pavlov_EUserInterfaceType                          OldInterface                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::OnInterfaceChanged(Pavlov_EUserInterfaceType OldInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.OnInterfaceChanged");

	AMenuUniverse_OnInterfaceChanged_Params params {};
	params.OldInterface = OldInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CAE0
//		Name   -> Function Pavlov.MenuUniverse.OnHeadsetScaleChanged
//		Flags  -> (Native, Protected)
// Parameters:
//		float                                              NewScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::OnHeadsetScaleChanged(float NewScale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.OnHeadsetScaleChanged");

	AMenuUniverse_OnHeadsetScaleChanged_Params params {};
	params.NewScale = NewScale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0020E7C0
//		Name   -> Function Pavlov.MenuUniverse.OnEnableChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::OnEnableChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.OnEnableChanged");

	AMenuUniverse_OnEnableChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C650
//		Name   -> Function Pavlov.MenuUniverse.IsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AMenuUniverse::IsEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.IsEnabled");

	AMenuUniverse_IsEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C5C0
//		Name   -> Function Pavlov.MenuUniverse.GetViewById
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AMenuUniverseView*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AMenuUniverseView* AMenuUniverse::GetViewById(int ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.GetViewById");

	AMenuUniverse_GetViewById_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BCB0
//		Name   -> Function Pavlov.MenuUniverse.DockView
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EMenuUniverseDockingType                    Dock                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ViewId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Order                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AMenuUniverse::DockView(Pavlov_EMenuUniverseDockingType Dock, int ViewId, int Order)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.DockView");

	AMenuUniverse_DockView_Params params {};
	params.Dock = Dock;
	params.ViewId = ViewId;
	params.Order = Order;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068BB90
//		Name   -> Function Pavlov.MenuUniverse.CreateView
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      ViewClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ViewUrlOverride                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UObject*                                     ControllerObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AMenuUniverseView*                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AMenuUniverseView* AMenuUniverse::CreateView(class UClass* ViewClass, const struct FString& ViewUrlOverride, class UObject* ControllerObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.CreateView");

	AMenuUniverse_CreateView_Params params {};
	params.ViewClass = ViewClass;
	params.ViewUrlOverride = ViewUrlOverride;
	params.ControllerObject = ControllerObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068B950
//		Name   -> Function Pavlov.MenuUniverse.AdjustFacingPivot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void AMenuUniverse::AdjustFacingPivot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverse.AdjustFacingPivot");

	AMenuUniverse_AdjustFacingPivot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CE60
//		Name   -> Function Pavlov.MenuUniverseController.OnTriggerReleased
//		Flags  -> (Final, Native, Private)
void UMenuUniverseController::OnTriggerReleased()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnTriggerReleased");

	UMenuUniverseController_OnTriggerReleased_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CE40
//		Name   -> Function Pavlov.MenuUniverseController.OnTriggerPressed
//		Flags  -> (Final, Native, Private)
void UMenuUniverseController::OnTriggerPressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnTriggerPressed");

	UMenuUniverseController_OnTriggerPressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CDC0
//		Name   -> Function Pavlov.MenuUniverseController.OnTouchpadY
//		Flags  -> (Final, Native, Private)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMenuUniverseController::OnTouchpadY(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnTouchpadY");

	UMenuUniverseController_OnTouchpadY_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CDC0
//		Name   -> Function Pavlov.MenuUniverseController.OnTouchpadX
//		Flags  -> (Final, Native, Private)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMenuUniverseController::OnTouchpadX(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnTouchpadX");

	UMenuUniverseController_OnTouchpadX_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CC80
//		Name   -> Function Pavlov.MenuUniverseController.OnScrollY
//		Flags  -> (Final, Native, Private)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMenuUniverseController::OnScrollY(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnScrollY");

	UMenuUniverseController_OnScrollY_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CC00
//		Name   -> Function Pavlov.MenuUniverseController.OnScrollX
//		Flags  -> (Final, Native, Private)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UMenuUniverseController::OnScrollX(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnScrollX");

	UMenuUniverseController_OnScrollX_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.MenuUniverseController.OnMenuReleased
//		Flags  -> (Final, Native, Private)
void UMenuUniverseController::OnMenuReleased()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnMenuReleased");

	UMenuUniverseController_OnMenuReleased_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CBE0
//		Name   -> Function Pavlov.MenuUniverseController.OnMenuPressed
//		Flags  -> (Final, Native, Private)
void UMenuUniverseController::OnMenuPressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.MenuUniverseController.OnMenuPressed");

	UMenuUniverseController_OnMenuPressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068BAE0
//		Name   -> Function Pavlov.Modal.Commit
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UModal::Commit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Modal.Commit");

	UModal_Commit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D420
//		Name   -> Function Pavlov.ModalMessageBox.SetProgress
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NewProgress                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UModalMessageBox::SetProgress(float NewProgress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ModalMessageBox.SetProgress");

	UModalMessageBox_SetProgress_Params params {};
	params.NewProgress = NewProgress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D550
//		Name   -> Function Pavlov.NameTagWidgetTTT.UpdateVis
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          LocalPavPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPlayerState*                          OwnerPavPlayerState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UNameTagWidgetTTT::UpdateVis(class APavlovPlayerState* LocalPavPlayerState, class APavlovPlayerState* OwnerPavPlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.NameTagWidgetTTT.UpdateVis");

	UNameTagWidgetTTT_UpdateVis_Params params {};
	params.LocalPavPlayerState = LocalPavPlayerState;
	params.OwnerPavPlayerState = OwnerPavPlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068BA50
//		Name   -> Function Pavlov.OculusInputBinding.ApplyEmulated
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOculusInputBinding::STATIC_ApplyEmulated(class UObject* WorldContext)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OculusInputBinding.ApplyEmulated");

	UOculusInputBinding_ApplyEmulated_Params params {};
	params.WorldContext = WorldContext;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CFA0
//		Name   -> Function Pavlov.OnlineAuthentication.ResetReLoginCooldown
//		Flags  -> (Final, Native, Protected)
void UOnlineAuthentication::ResetReLoginCooldown()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineAuthentication.ResetReLoginCooldown");

	UOnlineAuthentication_ResetReLoginCooldown_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C6E0
//		Name   -> Function Pavlov.OnlineAuthentication.IsLoggedIn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineAuthentication::IsLoggedIn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineAuthentication.IsLoggedIn");

	UOnlineAuthentication_IsLoggedIn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C180
//		Name   -> Function Pavlov.OnlineAuthentication.GetLocalPlatformId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineAuthentication::GetLocalPlatformId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineAuthentication.GetLocalPlatformId");

	UOnlineAuthentication_GetLocalPlatformId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BF60
//		Name   -> Function Pavlov.OnlineAuthentication.GetDisplayName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineAuthentication::GetDisplayName()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineAuthentication.GetDisplayName");

	UOnlineAuthentication_GetDisplayName_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068CE80
//		Name   -> Function Pavlov.OnlineLeaderboards.QueryLeaderboardRanks
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     LeaderboardId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                MaxResults                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLeaderboards::QueryLeaderboardRanks(const struct FString& LeaderboardId, int MaxResults)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLeaderboards.QueryLeaderboardRanks");

	UOnlineLeaderboards_QueryLeaderboardRanks_Params params {};
	params.LeaderboardId = LeaderboardId;
	params.MaxResults = MaxResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D4A0
//		Name   -> Function Pavlov.OnlineLobby.SetVoiceChat
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::SetVoiceChat(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.SetVoiceChat");

	UOnlineLobby_SetVoiceChat_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D330
//		Name   -> Function Pavlov.OnlineLobby.SetMemberData
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::SetMemberData(const struct FString& Key, const struct FString& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.SetMemberData");

	UOnlineLobby_SetMemberData_Params params {};
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D2B0
//		Name   -> Function Pavlov.OnlineLobby.SetLobbyMemberLimit
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                MemberLimit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::SetLobbyMemberLimit(int MemberLimit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.SetLobbyMemberLimit");

	UOnlineLobby_SetLobbyMemberLimit_Params params {};
	params.MemberLimit = MemberLimit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D1C0
//		Name   -> Function Pavlov.OnlineLobby.SetLobbyData
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Value                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::SetLobbyData(const struct FString& Key, const struct FString& Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.SetLobbyData");

	UOnlineLobby_SetLobbyData_Params params {};
	params.Key = Key;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068D130
//		Name   -> Function Pavlov.OnlineLobby.SetFriendsOnly
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::SetFriendsOnly(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.SetFriendsOnly");

	UOnlineLobby_SetFriendsOnly_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068CA30
//		Name   -> Function Pavlov.OnlineLobby.OnEncodedVoiceData
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		TArray<unsigned char>                              EncodedVoiceData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
void UOnlineLobby::OnEncodedVoiceData(TArray<unsigned char> EncodedVoiceData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.OnEncodedVoiceData");

	UOnlineLobby_OnEncodedVoiceData_Params params {};
	params.EncodedVoiceData = EncodedVoiceData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C900
//		Name   -> Function Pavlov.OnlineLobby.OnAvatarUpdated
//		Flags  -> (Final, Native, Private)
// Parameters:
//		struct FString                                     ProductId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     PlatformId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture2D*                                  AvatarTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::OnAvatarUpdated(const struct FString& ProductId, const struct FString& PlatformId, class UTexture2D* AvatarTexture)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.OnAvatarUpdated");

	UOnlineLobby_OnAvatarUpdated_Params params {};
	params.ProductId = ProductId;
	params.PlatformId = PlatformId;
	params.AvatarTexture = AvatarTexture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C880
//		Name   -> Function Pavlov.OnlineLobby.KickAndBan
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                MemberIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::KickAndBan(int MemberIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.KickAndBan");

	UOnlineLobby_KickAndBan_Params params {};
	params.MemberIndex = MemberIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C7F0
//		Name   -> Function Pavlov.OnlineLobby.Kick
//		Flags  -> (Native, Public, BlueprintCallable)
// Parameters:
//		int                                                MemberIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineLobby::Kick(int MemberIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.Kick");

	UOnlineLobby_Kick_Params params {};
	params.MemberIndex = MemberIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C7D0
//		Name   -> Function Pavlov.OnlineLobby.IsVoiceChatEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineLobby::IsVoiceChatEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.IsVoiceChatEnabled");

	UOnlineLobby_IsVoiceChatEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C710
//		Name   -> Function Pavlov.OnlineLobby.IsMemberTalking
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineLobby::IsMemberTalking(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.IsMemberTalking");

	UOnlineLobby_IsMemberTalking_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C6B0
//		Name   -> Function Pavlov.OnlineLobby.IsLocalUserOwner
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineLobby::IsLocalUserOwner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.IsLocalUserOwner");

	UOnlineLobby_IsLocalUserOwner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C680
//		Name   -> Function Pavlov.OnlineLobby.IsFriendsOnly
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineLobby::IsFriendsOnly()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.IsFriendsOnly");

	UOnlineLobby_IsFriendsOnly_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.OnlineLobby.InviteFriends
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UOnlineLobby::InviteFriends()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.InviteFriends");

	UOnlineLobby_InviteFriends_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0068C360
//		Name   -> Function Pavlov.OnlineLobby.GetNumLobbyMembers
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UOnlineLobby::GetNumLobbyMembers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.GetNumLobbyMembers");

	UOnlineLobby_GetNumLobbyMembers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C200
//		Name   -> Function Pavlov.OnlineLobby.GetMemberData
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineLobby::GetMemberData(int Index, const struct FString& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.GetMemberData");

	UOnlineLobby_GetMemberData_Params params {};
	params.Index = Index;
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C150
//		Name   -> Function Pavlov.OnlineLobby.GetLobbyMemberLimit
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UOnlineLobby::GetLobbyMemberLimit()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.GetLobbyMemberLimit");

	UOnlineLobby_GetLobbyMemberLimit_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068C0D0
//		Name   -> Function Pavlov.OnlineLobby.GetLobbyId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineLobby::GetLobbyId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.GetLobbyId");

	UOnlineLobby_GetLobbyId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0068BFE0
//		Name   -> Function Pavlov.OnlineLobby.GetLobbyData
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     Key                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineLobby::GetLobbyData(const struct FString& Key)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineLobby.GetLobbyData");

	UOnlineLobby_GetLobbyData_Params params {};
	params.Key = Key;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006914E0
//		Name   -> Function Pavlov.OnlineManager.OnServerConnectFailure
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		Pavlov_EConnectorFailureReason                     FailureReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineManager::OnServerConnectFailure(Pavlov_EConnectorFailureReason FailureReason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.OnServerConnectFailure");

	UOnlineManager_OnServerConnectFailure_Params params {};
	params.FailureReason = FailureReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006911C0
//		Name   -> Function Pavlov.OnlineManager.OnErrorEvent
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		Pavlov_EOnlineError                                Error                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FText                                       ErrorMessage                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UOnlineManager::OnErrorEvent(Pavlov_EOnlineError Error, const struct FText& ErrorMessage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.OnErrorEvent");

	UOnlineManager_OnErrorEvent_Params params {};
	params.Error = Error;
	params.ErrorMessage = ErrorMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691000
//		Name   -> Function Pavlov.OnlineManager.LobbySearch
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FLobbySearchOptions                         SearchOptions                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineManager::LobbySearch(const struct FLobbySearchOptions& SearchOptions)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.LobbySearch");

	UOnlineManager_LobbySearch_Params params {};
	params.SearchOptions = SearchOptions;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690FE0
//		Name   -> Function Pavlov.OnlineManager.LeaveLobby
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UOnlineManager::LeaveLobby()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.LeaveLobby");

	UOnlineManager_LeaveLobby_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690F40
//		Name   -> Function Pavlov.OnlineManager.JoinLobby
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     LobbyId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineManager::JoinLobby(const struct FString& LobbyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.JoinLobby");

	UOnlineManager_JoinLobby_Params params {};
	params.LobbyId = LobbyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690ED0
//		Name   -> Function Pavlov.OnlineManager.IsSearchingForLobbies
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineManager::IsSearchingForLobbies()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.IsSearchingForLobbies");

	UOnlineManager_IsSearchingForLobbies_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690830
//		Name   -> Function Pavlov.OnlineManager.GetLobbyInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UOnlineLobby*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UOnlineLobby* UOnlineManager::GetLobbyInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.GetLobbyInstance");

	UOnlineManager_GetLobbyInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690610
//		Name   -> Function Pavlov.OnlineManager.FindLobbyById
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     LobbyId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineManager::FindLobbyById(const struct FString& LobbyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.FindLobbyById");

	UOnlineManager_FindLobbyById_Params params {};
	params.LobbyId = LobbyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690530
//		Name   -> Function Pavlov.OnlineManager.CreateLobby
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                LobbyMemberLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bPublic                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlineManager::CreateLobby(int LobbyMemberLimit, bool bPublic)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineManager.CreateLobby");

	UOnlineManager_CreateLobby_Params params {};
	params.LobbyMemberLimit = LobbyMemberLimit;
	params.bPublic = bPublic;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006907A0
//		Name   -> Function Pavlov.OnlinePlatform.GetAvatarByPlayerState
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture2D*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTexture2D* UOnlinePlatform::GetAvatarByPlayerState(class APlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlinePlatform.GetAvatarByPlayerState");

	UOnlinePlatform_GetAvatarByPlayerState_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006906B0
//		Name   -> Function Pavlov.OnlinePlatform.GetAvatar
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ProductId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFailOver                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture2D*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTexture2D* UOnlinePlatform::GetAvatar(const struct FString& ProductId, bool bFailOver)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlinePlatform.GetAvatar");

	UOnlinePlatform_GetAvatar_Params params {};
	params.ProductId = ProductId;
	params.bFailOver = bFailOver;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006912D0
//		Name   -> Function Pavlov.OnlinePlatformOculus.OnFriendsUpdated
//		Flags  -> (Final, Native, Protected)
void UOnlinePlatformOculus::OnFriendsUpdated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlinePlatformOculus.OnFriendsUpdated");

	UOnlinePlatformOculus_OnFriendsUpdated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006910D0
//		Name   -> Function Pavlov.OnlinePlatformOculus.OnDeepLinkMessage
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FString                                     ApiName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOnlinePlatformOculus::OnDeepLinkMessage(const struct FString& ApiName, const struct FString& Message)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlinePlatformOculus.OnDeepLinkMessage");

	UOnlinePlatformOculus_OnDeepLinkMessage_Params params {};
	params.ApiName = ApiName;
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691560
//		Name   -> Function Pavlov.OnlinePlatformSteam.OnSteamRichPresenceUpdated
//		Flags  -> (Final, Native, Protected)
void UOnlinePlatformSteam::OnSteamRichPresenceUpdated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlinePlatformSteam.OnSteamRichPresenceUpdated");

	UOnlinePlatformSteam_OnSteamRichPresenceUpdated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690BA0
//		Name   -> Function Pavlov.OnlineStatics.GetOnlineStats
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UOnlineStats*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UOnlineStats* UOnlineStatics::STATIC_GetOnlineStats(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStatics.GetOnlineStats");

	UOnlineStatics_GetOnlineStats_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690B20
//		Name   -> Function Pavlov.OnlineStatics.GetOnlinePlatform
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UOnlinePlatform*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UOnlinePlatform* UOnlineStatics::STATIC_GetOnlinePlatform(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStatics.GetOnlinePlatform");

	UOnlineStatics_GetOnlinePlatform_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690AA0
//		Name   -> Function Pavlov.OnlineStatics.GetOnlineManager
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UOnlineManager*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UOnlineManager* UOnlineStatics::STATIC_GetOnlineManager(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStatics.GetOnlineManager");

	UOnlineStatics_GetOnlineManager_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690A20
//		Name   -> Function Pavlov.OnlineStatics.GetOnlineLeaderboards
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UOnlineLeaderboards*                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UOnlineLeaderboards* UOnlineStatics::STATIC_GetOnlineLeaderboards(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStatics.GetOnlineLeaderboards");

	UOnlineStatics_GetOnlineLeaderboards_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690920
//		Name   -> Function Pavlov.OnlineStatics.GetLocalUserIdAsString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineStatics::STATIC_GetLocalUserIdAsString(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStatics.GetLocalUserIdAsString");

	UOnlineStatics_GetLocalUserIdAsString_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690850
//		Name   -> Function Pavlov.OnlineStatics.GetLocalDisplayName
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UOnlineStatics::STATIC_GetLocalDisplayName(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStatics.GetLocalDisplayName");

	UOnlineStatics_GetLocalDisplayName_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00691780
//		Name   -> Function Pavlov.OnlineStats.QueryStatsServer
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ProductUserId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     StatName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineStats::QueryStatsServer(const struct FString& ProductUserId, const struct FString& StatName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStats.QueryStatsServer");

	UOnlineStats_QueryStatsServer_Params params {};
	params.ProductUserId = ProductUserId;
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006916D0
//		Name   -> Function Pavlov.OnlineStats.QueryStatsLocal
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     StatName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineStats::QueryStatsLocal(const struct FString& StatName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStats.QueryStatsLocal");

	UOnlineStats_QueryStatsLocal_Params params {};
	params.StatName = StatName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690D60
//		Name   -> Function Pavlov.OnlineStats.IngestStatsServer
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ProductUserIdString                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     StatName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                StatAmount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineStats::IngestStatsServer(const struct FString& ProductUserIdString, const struct FString& StatName, int StatAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStats.IngestStatsServer");

	UOnlineStats_IngestStatsServer_Params params {};
	params.ProductUserIdString = ProductUserIdString;
	params.StatName = StatName;
	params.StatAmount = StatAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690C70
//		Name   -> Function Pavlov.OnlineStats.IngestStatsLocal
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     StatName                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                StatAmount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UOnlineStats::IngestStatsLocal(const struct FString& StatName, int StatAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OnlineStats.IngestStatsLocal");

	UOnlineStats_IngestStatsLocal_Params params {};
	params.StatName = StatName;
	params.StatAmount = StatAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006918A0
//		Name   -> Function Pavlov.OutOfBoundsComponent.SetGuideToLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     GuideLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOutOfBoundsComponent::SetGuideToLocation(const struct FVector& GuideLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.SetGuideToLocation");

	UOutOfBoundsComponent_SetGuideToLocation_Params params {};
	params.GuideLocation = GuideLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691880
//		Name   -> Function Pavlov.OutOfBoundsComponent.RecalculateGuide
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UOutOfBoundsComponent::RecalculateGuide()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.RecalculateGuide");

	UOutOfBoundsComponent_RecalculateGuide_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0023D6D0
//		Name   -> Function Pavlov.OutOfBoundsComponent.PlayDamageSound
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void UOutOfBoundsComponent::PlayDamageSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.PlayDamageSound");

	UOutOfBoundsComponent_PlayDamageSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691650
//		Name   -> Function Pavlov.OutOfBoundsComponent.OwnerKilled
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Killed                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOutOfBoundsComponent::OwnerKilled(class AActor* Killed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.OwnerKilled");

	UOutOfBoundsComponent_OwnerKilled_Params params {};
	params.Killed = Killed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691580
//		Name   -> Function Pavlov.OutOfBoundsComponent.OutOfBounds_Server
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector                                     EscapeLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlov_OutOfBoundsVolume*                   OOBVolume                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UOutOfBoundsComponent::OutOfBounds_Server(const struct FVector& EscapeLocation, class APavlov_OutOfBoundsVolume* OOBVolume)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.OutOfBounds_Server");

	UOutOfBoundsComponent_OutOfBounds_Server_Params params {};
	params.EscapeLocation = EscapeLocation;
	params.OOBVolume = OOBVolume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0023D5E0
//		Name   -> Function Pavlov.OutOfBoundsComponent.OnPawnDamaged_Client
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void UOutOfBoundsComponent::OnPawnDamaged_Client()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.OnPawnDamaged_Client");

	UOutOfBoundsComponent_OnPawnDamaged_Client_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00217B10
//		Name   -> Function Pavlov.OutOfBoundsComponent.OnOutOfBounds
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void UOutOfBoundsComponent::OnOutOfBounds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.OnOutOfBounds");

	UOutOfBoundsComponent_OnOutOfBounds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690C50
//		Name   -> Function Pavlov.OutOfBoundsComponent.InBounds
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void UOutOfBoundsComponent::InBounds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.InBounds");

	UOutOfBoundsComponent_InBounds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006905F0
//		Name   -> Function Pavlov.OutOfBoundsComponent.DamageTick
//		Flags  -> (Final, Native, Public)
void UOutOfBoundsComponent::DamageTick()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.DamageTick");

	UOutOfBoundsComponent_DamageTick_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690510
//		Name   -> Function Pavlov.OutOfBoundsComponent.AddGuideMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UOutOfBoundsComponent::AddGuideMesh()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.OutOfBoundsComponent.AddGuideMesh");

	UOutOfBoundsComponent_AddGuideMesh_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691930
//		Name   -> Function Pavlov.Painkillers.SetPainkillerDetails
//		Flags  -> (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                PillAmount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              HealAmountPerPill                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APainkillers::SetPainkillerDetails(int PillAmount, float HealAmountPerPill)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Painkillers.SetPainkillerDetails");

	APainkillers_SetPainkillerDetails_Params params {};
	params.PillAmount = PillAmount;
	params.HealAmountPerPill = HealAmountPerPill;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006909F0
//		Name   -> Function Pavlov.Painkillers.GetNumOfPills
//		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APainkillers::GetNumOfPills()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Painkillers.GetNumOfPills");

	APainkillers_GetNumOfPills_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00691A00
//		Name   -> Function Pavlov.PavlovAIController.SetTargetPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 TargetPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovAIController::SetTargetPawn(class APavlovPawn* TargetPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovAIController.SetTargetPawn");

	APavlovAIController_SetTargetPawn_Params params {};
	params.TargetPawn = TargetPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006912F0
//		Name   -> Function Pavlov.PavlovAIController.OnPawnCollisionBeginOverlap
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void APavlovAIController::OnPawnCollisionBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovAIController.OnPawnCollisionBeginOverlap");

	APavlovAIController_OnPawnCollisionBeginOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00690F00
//		Name   -> Function Pavlov.PavlovAIController.IsSuppressed
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovAIController::IsSuppressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovAIController.IsSuppressed");

	APavlovAIController_IsSuppressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00690C20
//		Name   -> Function Pavlov.PavlovAIController.GetTargetPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APavlovPawn*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPawn* APavlovAIController::GetTargetPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovAIController.GetTargetPawn");

	APavlovAIController_GetTargetPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693820
//		Name   -> Function Pavlov.PavlovAvatarAnimInstance.GetFingerBlend
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EFinger                                     Finger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovAvatarAnimInstance::GetFingerBlend(bool bRight, Pavlov_EFinger Finger)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovAvatarAnimInstance.GetFingerBlend");

	UPavlovAvatarAnimInstance_GetFingerBlend_Params params {};
	params.bRight = bRight;
	params.Finger = Finger;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00694360
//		Name   -> Function Pavlov.PavlovCustomGameMode.OnCustomRconCommand
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FString                                     Command                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovCustomGameMode::OnCustomRconCommand(const struct FString& Command)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovCustomGameMode.OnCustomRconCommand");

	APavlovCustomGameMode_OnCustomRconCommand_Params params {};
	params.Command = Command;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00695700
//		Name   -> Function Pavlov.PavlovGameInstance.UpdateServerList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     GameMode                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFriendsOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bPrivateOnly                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::UpdateServerList(const struct FString& Map, const struct FString& GameMode, bool bFriendsOnly, bool bPrivateOnly)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.UpdateServerList");

	UPavlovGameInstance_UpdateServerList_Params params {};
	params.Map = Map;
	params.GameMode = GameMode;
	params.bFriendsOnly = bFriendsOnly;
	params.bPrivateOnly = bPrivateOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00695670
//		Name   -> Function Pavlov.PavlovGameInstance.UpdateNextSplashScreen
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bInitialSplash                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::UpdateNextSplashScreen(bool bInitialSplash)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.UpdateNextSplashScreen");

	UPavlovGameInstance_UpdateNextSplashScreen_Params params {};
	params.bInitialSplash = bInitialSplash;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00695650
//		Name   -> Function Pavlov.PavlovGameInstance.ToggleMenu
//		Flags  -> (Final, Exec, Native, Public)
void UPavlovGameInstance::ToggleMenu()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ToggleMenu");

	UPavlovGameInstance_ToggleMenu_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006954B0
//		Name   -> Function Pavlov.PavlovGameInstance.TestServerConnect
//		Flags  -> (Final, Exec, Native, Protected)
// Parameters:
//		struct FString                                     ConnectURL                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     MapId                                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::TestServerConnect(const struct FString& ConnectURL, const struct FString& MapId, float Delay)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.TestServerConnect");

	UPavlovGameInstance_TestServerConnect_Params params {};
	params.ConnectURL = ConnectURL;
	params.MapId = MapId;
	params.Delay = Delay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006953E0
//		Name   -> Function Pavlov.PavlovGameInstance.ShowPavlovSplash
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFade                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::ShowPavlovSplash(bool bVisible, bool bFade)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ShowPavlovSplash");

	UPavlovGameInstance_ShowPavlovSplash_Params params {};
	params.bVisible = bVisible;
	params.bFade = bFade;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00695300
//		Name   -> Function Pavlov.PavlovGameInstance.SetMutedByProductId
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::SetMutedByProductId(const struct FString& ID, bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.SetMutedByProductId");

	UPavlovGameInstance_SetMutedByProductId_Params params {};
	params.ID = ID;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00695230
//		Name   -> Function Pavlov.PavlovGameInstance.SetMuted
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::SetMuted(class APavlovPlayerState* PlayerState, bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.SetMuted");

	UPavlovGameInstance_SetMuted_Params params {};
	params.PlayerState = PlayerState;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00695160
//		Name   -> Function Pavlov.PavlovGameInstance.SetMixingChannelVolume
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		struct FName                                       Name                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::SetMixingChannelVolume(const struct FName& Name, float Volume)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.SetMixingChannelVolume");

	UPavlovGameInstance_SetMixingChannelVolume_Params params {};
	params.Name = Name;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006950E0
//		Name   -> Function Pavlov.PavlovGameInstance.SetMatchmakingState
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EMatchmakingState                           NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::SetMatchmakingState(Pavlov_EMatchmakingState NewState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.SetMatchmakingState");

	UPavlovGameInstance_SetMatchmakingState_Params params {};
	params.NewState = NewState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694FD0
//		Name   -> Function Pavlov.PavlovGameInstance.SetItemRotation
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::SetItemRotation(float Roll, float Pitch, float Yaw)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.SetItemRotation");

	UPavlovGameInstance_SetItemRotation_Params params {};
	params.Roll = Roll;
	params.Pitch = Pitch;
	params.Yaw = Yaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694FB0
//		Name   -> Function Pavlov.PavlovGameInstance.ServerStartStatusHelper
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::ServerStartStatusHelper()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ServerStartStatusHelper");

	UPavlovGameInstance_ServerStartStatusHelper_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694F30
//		Name   -> Function Pavlov.PavlovGameInstance.ServerConnectFailed
//		Flags  -> (Final, Native, Public)
// Parameters:
//		Pavlov_EConnectorFailureReason                     FailureReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::ServerConnectFailed(Pavlov_EConnectorFailureReason FailureReason)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ServerConnectFailed");

	UPavlovGameInstance_ServerConnectFailed_Params params {};
	params.FailureReason = FailureReason;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694F10
//		Name   -> Function Pavlov.PavlovGameInstance.ServerConnectComplete
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::ServerConnectComplete()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ServerConnectComplete");

	UPavlovGameInstance_ServerConnectComplete_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694E70
//		Name   -> Function Pavlov.PavlovGameInstance.ServerConnectByURL
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::ServerConnectByURL(const struct FString& URL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ServerConnectByURL");

	UPavlovGameInstance_ServerConnectByURL_Params params {};
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694D90
//		Name   -> Function Pavlov.PavlovGameInstance.ServerConnectByIp
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     IpString                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Port                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::ServerConnectByIp(const struct FString& IpString, int Port)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ServerConnectByIp");

	UPavlovGameInstance_ServerConnectByIp_Params params {};
	params.IpString = IpString;
	params.Port = Port;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694CB0
//		Name   -> Function Pavlov.PavlovGameInstance.ServerConnect
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FServerConnectParams                        Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameInstance::ServerConnect(const struct FServerConnectParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ServerConnect");

	UPavlovGameInstance_ServerConnect_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00694C90
//		Name   -> Function Pavlov.PavlovGameInstance.RetrieveMasterServerSessionId
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::RetrieveMasterServerSessionId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.RetrieveMasterServerSessionId");

	UPavlovGameInstance_RetrieveMasterServerSessionId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694C70
//		Name   -> Function Pavlov.PavlovGameInstance.ResumeShaderPreCompilation
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::ResumeShaderPreCompilation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ResumeShaderPreCompilation");

	UPavlovGameInstance_ResumeShaderPreCompilation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694C50
//		Name   -> Function Pavlov.PavlovGameInstance.ResetTutorial
//		Flags  -> (Final, Exec, Native, Public)
void UPavlovGameInstance::ResetTutorial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ResetTutorial");

	UPavlovGameInstance_ResetTutorial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694C30
//		Name   -> Function Pavlov.PavlovGameInstance.ResetPhononScene
//		Flags  -> (Final, Exec, Native, Public)
void UPavlovGameInstance::ResetPhononScene()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ResetPhononScene");

	UPavlovGameInstance_ResetPhononScene_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694C10
//		Name   -> Function Pavlov.PavlovGameInstance.ReportServerState
//		Flags  -> (Final, Native, Protected)
void UPavlovGameInstance::ReportServerState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ReportServerState");

	UPavlovGameInstance_ReportServerState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694B60
//		Name   -> Function Pavlov.PavlovGameInstance.RemoveMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameInstance::RemoveMap(const struct FString& UniqueID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.RemoveMap");

	UPavlovGameInstance_RemoveMap_Params params {};
	params.UniqueID = UniqueID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00694AE0
//		Name   -> Function Pavlov.PavlovGameInstance.RemoveFromRefBucket
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::RemoveFromRefBucket(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.RemoveFromRefBucket");

	UPavlovGameInstance_RemoveFromRefBucket_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694AC0
//		Name   -> Function Pavlov.PavlovGameInstance.QuickMatch
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::QuickMatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.QuickMatch");

	UPavlovGameInstance_QuickMatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694AA0
//		Name   -> Function Pavlov.PavlovGameInstance.QueryForGameSession
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::QueryForGameSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.QueryForGameSession");

	UPavlovGameInstance_QueryForGameSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694A80
//		Name   -> Function Pavlov.PavlovGameInstance.OpenMap_Implementation
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::OpenMap_Implementation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OpenMap_Implementation");

	UPavlovGameInstance_OpenMap_Implementation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694990
//		Name   -> Function Pavlov.PavlovGameInstance.OpenMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Map                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OpenMap(const struct FString& Map, const struct FString& Options)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OpenMap");

	UPavlovGameInstance_OpenMap_Params params {};
	params.Map = Map;
	params.Options = Options;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694970
//		Name   -> Function Pavlov.PavlovGameInstance.OnWorkshopSpecificQuery
//		Flags  -> (Final, Native, Protected)
void UPavlovGameInstance::OnWorkshopSpecificQuery()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnWorkshopSpecificQuery");

	UPavlovGameInstance_OnWorkshopSpecificQuery_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694950
//		Name   -> Function Pavlov.PavlovGameInstance.OnSteamServersConnected
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::OnSteamServersConnected()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnSteamServersConnected");

	UPavlovGameInstance_OnSteamServersConnected_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694930
//		Name   -> Function Pavlov.PavlovGameInstance.OnSteamLobbyListUpdated
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::OnSteamLobbyListUpdated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnSteamLobbyListUpdated");

	UPavlovGameInstance_OnSteamLobbyListUpdated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694810
//		Name   -> Function Pavlov.PavlovGameInstance.OnSplashScreenLoaded
//		Flags  -> (Final, Native, Protected, HasDefaults)
// Parameters:
//		struct FDateTime                                   StartTimestamp                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnSplashScreenLoaded(const struct FDateTime& StartTimestamp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnSplashScreenLoaded");

	UPavlovGameInstance_OnSplashScreenLoaded_Params params {};
	params.StartTimestamp = StartTimestamp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006946E0
//		Name   -> Function Pavlov.PavlovGameInstance.OnServerMapDownloaded
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnServerMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnServerMapDownloaded");

	UPavlovGameInstance_OnServerMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694580
//		Name   -> Function Pavlov.PavlovGameInstance.OnNetworkFailure
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UNetDriver*                                  NetDriver                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TEnumAsByte<Engine_ENetworkFailure>                FailureType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ErrorString                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnNetworkFailure(class UWorld* World, class UNetDriver* NetDriver, TEnumAsByte<Engine_ENetworkFailure> FailureType, const struct FString& ErrorString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnNetworkFailure");

	UPavlovGameInstance_OnNetworkFailure_Params params {};
	params.World = World;
	params.NetDriver = NetDriver;
	params.FailureType = FailureType;
	params.ErrorString = ErrorString;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006944F0
//		Name   -> Function Pavlov.PavlovGameInstance.OnLoginStatusChanged
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bLoggedIn                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnLoginStatusChanged(bool bLoggedIn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnLoginStatusChanged");

	UPavlovGameInstance_OnLoginStatusChanged_Params params {};
	params.bLoggedIn = bLoggedIn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006944D0
//		Name   -> Function Pavlov.PavlovGameInstance.OnLobbyLeave
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::OnLobbyLeave()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnLobbyLeave");

	UPavlovGameInstance_OnLobbyLeave_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694440
//		Name   -> Function Pavlov.PavlovGameInstance.OnLobbyEnter
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bFailed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnLobbyEnter(bool bFailed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnLobbyEnter");

	UPavlovGameInstance_OnLobbyEnter_Params params {};
	params.bFailed = bFailed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694230
//		Name   -> Function Pavlov.PavlovGameInstance.OnClientMapDownloaded
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnClientMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnClientMapDownloaded");

	UPavlovGameInstance_OnClientMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00694100
//		Name   -> Function Pavlov.PavlovGameInstance.OnAuthSessionTicketResponse
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     HexAuthTicket                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnAuthSessionTicketResponse(bool bSucceed, const struct FString& HexAuthTicket)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnAuthSessionTicketResponse");

	UPavlovGameInstance_OnAuthSessionTicketResponse_Params params {};
	params.bSucceed = bSucceed;
	params.HexAuthTicket = HexAuthTicket;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693FC0
//		Name   -> Function Pavlov.PavlovGameInstance.OnAndroidPermisionsGranted
//		Flags  -> (Final, Native, Public, HasOutParms)
// Parameters:
//		TArray<struct FString>                             Permissions                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
//		TArray<bool>                                       GrantResults                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
void UPavlovGameInstance::OnAndroidPermisionsGranted(TArray<struct FString> Permissions, TArray<bool> GrantResults)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.OnAndroidPermisionsGranted");

	UPavlovGameInstance_OnAndroidPermisionsGranted_Params params {};
	params.Permissions = Permissions;
	params.GrantResults = GrantResults;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovGameInstance.LogoutTest
//		Flags  -> (Final, Exec, Native, Public)
void UPavlovGameInstance::LogoutTest()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.LogoutTest");

	UPavlovGameInstance_LogoutTest_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693F20
//		Name   -> Function Pavlov.PavlovGameInstance.JoinServer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     LobbyId                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::JoinServer(const struct FString& LobbyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.JoinServer");

	UPavlovGameInstance_JoinServer_Params params {};
	params.LobbyId = LobbyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693E70
//		Name   -> Function Pavlov.PavlovGameInstance.IsMutedByProductId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameInstance::IsMutedByProductId(const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.IsMutedByProductId");

	UPavlovGameInstance_IsMutedByProductId_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693DE0
//		Name   -> Function Pavlov.PavlovGameInstance.IsMuted
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameInstance::IsMuted(class APavlovPlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.IsMuted");

	UPavlovGameInstance_IsMuted_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693DC0
//		Name   -> Function Pavlov.PavlovGameInstance.InitClientProxies
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::InitClientProxies()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.InitClientProxies");

	UPavlovGameInstance_InitClientProxies_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693DA0
//		Name   -> Function Pavlov.PavlovGameInstance.HideSplashScreen
//		Flags  -> (Final, Native, Protected)
void UPavlovGameInstance::HideSplashScreen()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.HideSplashScreen");

	UPavlovGameInstance_HideSplashScreen_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693D70
//		Name   -> Function Pavlov.PavlovGameInstance.HasGameSession
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameInstance::HasGameSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.HasGameSession");

	UPavlovGameInstance_HasGameSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693D50
//		Name   -> Function Pavlov.PavlovGameInstance.GetVoiceSource
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UVoiceSource*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVoiceSource* UPavlovGameInstance::GetVoiceSource()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetVoiceSource");

	UPavlovGameInstance_GetVoiceSource_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693D20
//		Name   -> Function Pavlov.PavlovGameInstance.GetUIManager
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UUIManager*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UUIManager* UPavlovGameInstance::GetUIManager()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetUIManager");

	UPavlovGameInstance_GetUIManager_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693CF0
//		Name   -> Function Pavlov.PavlovGameInstance.GetTutorial
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UTutorial*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTutorial* UPavlovGameInstance::GetTutorial()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetTutorial");

	UPavlovGameInstance_GetTutorial_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693CD0
//		Name   -> Function Pavlov.PavlovGameInstance.GetSoundMixingSettings
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USoundMixingSettings*                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundMixingSettings* UPavlovGameInstance::GetSoundMixingSettings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetSoundMixingSettings");

	UPavlovGameInstance_GetSoundMixingSettings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693CB0
//		Name   -> Function Pavlov.PavlovGameInstance.GetServerBrowserV2
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UServerBrowserV2*                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UServerBrowserV2* UPavlovGameInstance::GetServerBrowserV2()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetServerBrowserV2");

	UPavlovGameInstance_GetServerBrowserV2_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693C90
//		Name   -> Function Pavlov.PavlovGameInstance.GetServerBrowser
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UServerBrowser*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UServerBrowser* UPavlovGameInstance::GetServerBrowser()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetServerBrowser");

	UPavlovGameInstance_GetServerBrowser_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693C60
//		Name   -> Function Pavlov.PavlovGameInstance.GetOnlineRegion
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EOnlineRegion                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EOnlineRegion UPavlovGameInstance::GetOnlineRegion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetOnlineRegion");

	UPavlovGameInstance_GetOnlineRegion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693C40
//		Name   -> Function Pavlov.PavlovGameInstance.GetOnlineManager
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UOnlineManager*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UOnlineManager* UPavlovGameInstance::GetOnlineManager()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetOnlineManager");

	UPavlovGameInstance_GetOnlineManager_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693C20
//		Name   -> Function Pavlov.PavlovGameInstance.GetOculusScale
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovGameInstance::GetOculusScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetOculusScale");

	UPavlovGameInstance_GetOculusScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693BF0
//		Name   -> Function Pavlov.PavlovGameInstance.GetMatchmaking
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UMatchmaking*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UMatchmaking* UPavlovGameInstance::GetMatchmaking()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetMatchmaking");

	UPavlovGameInstance_GetMatchmaking_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693B40
//		Name   -> Function Pavlov.PavlovGameInstance.GetMapVersion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPavlovGameInstance::GetMapVersion(const struct FString& UniqueID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetMapVersion");

	UPavlovGameInstance_GetMapVersion_Params params {};
	params.UniqueID = UniqueID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693A80
//		Name   -> Function Pavlov.PavlovGameInstance.GetMapListAdvanced
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Compatibility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFavoriteOnly                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::GetMapListAdvanced(int Compatibility, bool bFavoriteOnly)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetMapListAdvanced");

	UPavlovGameInstance_GetMapListAdvanced_Params params {};
	params.Compatibility = Compatibility;
	params.bFavoriteOnly = bFavoriteOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006939B0
//		Name   -> Function Pavlov.PavlovGameInstance.GetMapList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Compatibility                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<class UPavlov_Map*>                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<class UPavlov_Map*> UPavlovGameInstance::GetMapList(int Compatibility)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetMapList");

	UPavlovGameInstance_GetMapList_Params params {};
	params.Compatibility = Compatibility;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693900
//		Name   -> Function Pavlov.PavlovGameInstance.GetMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPavlov_Map*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UPavlov_Map* UPavlovGameInstance::GetMap(const struct FString& UniqueID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetMap");

	UPavlovGameInstance_GetMap_Params params {};
	params.UniqueID = UniqueID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006937F0
//		Name   -> Function Pavlov.PavlovGameInstance.GetCurrentSplashScreen
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UTexture*                                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTexture* UPavlovGameInstance::GetCurrentSplashScreen()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetCurrentSplashScreen");

	UPavlovGameInstance_GetCurrentSplashScreen_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693770
//		Name   -> Function Pavlov.PavlovGameInstance.GetBuildLabel
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovGameInstance::GetBuildLabel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.GetBuildLabel");

	UPavlovGameInstance_GetBuildLabel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693750
//		Name   -> Function Pavlov.PavlovGameInstance.DumpLobbyData
//		Flags  -> (Final, Exec, Native, Public)
void UPavlovGameInstance::DumpLobbyData()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.DumpLobbyData");

	UPavlovGameInstance_DumpLobbyData_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693730
//		Name   -> Function Pavlov.PavlovGameInstance.DisplayNetworkFailureMessage
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::DisplayNetworkFailureMessage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.DisplayNetworkFailureMessage");

	UPavlovGameInstance_DisplayNetworkFailureMessage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693710
//		Name   -> Function Pavlov.PavlovGameInstance.DisplayMessageImpl
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::DisplayMessageImpl()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.DisplayMessageImpl");

	UPavlovGameInstance_DisplayMessageImpl_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693630
//		Name   -> Function Pavlov.PavlovGameInstance.DisplayMessage
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bDeferredDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::DisplayMessage(const struct FString& Message, bool bDeferredDelay)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.DisplayMessage");

	UPavlovGameInstance_DisplayMessage_Params params {};
	params.Message = Message;
	params.bDeferredDelay = bDeferredDelay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693610
//		Name   -> Function Pavlov.PavlovGameInstance.CreateLobby
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CreateLobby()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CreateLobby");

	UPavlovGameInstance_CreateLobby_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006935F0
//		Name   -> Function Pavlov.PavlovGameInstance.CreateGameSession
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CreateGameSession()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CreateGameSession");

	UPavlovGameInstance_CreateGameSession_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006935D0
//		Name   -> Function Pavlov.PavlovGameInstance.CreateCoopLobby
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CreateCoopLobby()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CreateCoopLobby");

	UPavlovGameInstance_CreateCoopLobby_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693540
//		Name   -> Function Pavlov.PavlovGameInstance.ClientStartStatusHelper
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ListenPort                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UServerStatusHelper*                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UServerStatusHelper* UPavlovGameInstance::ClientStartStatusHelper(int ListenPort)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ClientStartStatusHelper");

	UPavlovGameInstance_ClientStartStatusHelper_Params params {};
	params.ListenPort = ListenPort;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00693520
//		Name   -> Function Pavlov.PavlovGameInstance.CheckPlacementStatus
//		Flags  -> (Final, Native, Public)
void UPavlovGameInstance::CheckPlacementStatus()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CheckPlacementStatus");

	UPavlovGameInstance_CheckPlacementStatus_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693500
//		Name   -> Function Pavlov.PavlovGameInstance.CheckBuildVersionStatus
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CheckBuildVersionStatus()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CheckBuildVersionStatus");

	UPavlovGameInstance_CheckBuildVersionStatus_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006934E0
//		Name   -> Function Pavlov.PavlovGameInstance.CancelServerFind
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CancelServerFind()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CancelServerFind");

	UPavlovGameInstance_CancelServerFind_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006934C0
//		Name   -> Function Pavlov.PavlovGameInstance.CancelServerConnect
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CancelServerConnect()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CancelServerConnect");

	UPavlovGameInstance_CancelServerConnect_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006934A0
//		Name   -> Function Pavlov.PavlovGameInstance.CancelQuickmatch
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameInstance::CancelQuickmatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.CancelQuickmatch");

	UPavlovGameInstance_CancelQuickmatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693480
//		Name   -> Function Pavlov.PavlovGameInstance.AsyncLoadSplashScreens
//		Flags  -> (Final, Native, Protected)
void UPavlovGameInstance::AsyncLoadSplashScreens()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.AsyncLoadSplashScreens");

	UPavlovGameInstance_AsyncLoadSplashScreens_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00693460
//		Name   -> Function Pavlov.PavlovGameInstance.ApplyOculusBindings
//		Flags  -> (Final, Exec, Native, Public)
void UPavlovGameInstance::ApplyOculusBindings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.ApplyOculusBindings");

	UPavlovGameInstance_ApplyOculusBindings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006933E0
//		Name   -> Function Pavlov.PavlovGameInstance.AddToRefBucket
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameInstance::AddToRefBucket(class UObject* Object)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameInstance.AddToRefBucket");

	UPavlovGameInstance_AddToRefBucket_Params params {};
	params.Object = Object;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069E210
//		Name   -> Function Pavlov.PavlovGameState.UnpauseMatchTime
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameState::UnpauseMatchTime()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.UnpauseMatchTime");

	APavlovGameState_UnpauseMatchTime_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D560
//		Name   -> Function Pavlov.PavlovGameState.SetGlobalInfo
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UPavlov_GlobalInfo*                          GI                                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::SetGlobalInfo(class UPavlov_GlobalInfo* GI)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.SetGlobalInfo");

	APavlovGameState_SetGlobalInfo_Params params {};
	params.GI = GI;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D440
//		Name   -> Function Pavlov.PavlovGameState.SetAttackingTeam
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               Team0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::SetAttackingTeam(bool Team0)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.SetAttackingTeam");

	APavlovGameState_SetAttackingTeam_Params params {};
	params.Team0 = Team0;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D2F0
//		Name   -> Function Pavlov.PavlovGameState.ResetMatchTime
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bPause                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::ResetMatchTime(bool bPause)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.ResetMatchTime");

	APavlovGameState_ResetMatchTime_Params params {};
	params.bPause = bPause;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D2D0
//		Name   -> Function Pavlov.PavlovGameState.ResetBuyRestrictions
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameState::ResetBuyRestrictions()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.ResetBuyRestrictions");

	APavlovGameState_ResetBuyRestrictions_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069D130
//		Name   -> Function Pavlov.PavlovGameState.PreloadSkin
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                SkinFamilyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::PreloadSkin(const struct FName& ItemName, int SkinFamilyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.PreloadSkin");

	APavlovGameState_PreloadSkin_Params params {};
	params.ItemName = ItemName;
	params.SkinFamilyId = SkinFamilyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069D0D0
//		Name   -> Function Pavlov.PavlovGameState.PauseMatchTime
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovGameState::PauseMatchTime()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.PauseMatchTime");

	APavlovGameState_PauseMatchTime_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069CAA0
//		Name   -> Function Pavlov.PavlovGameState.OnSkinPreloaded
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                SkinFamilyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::OnSkinPreloaded(const struct FName& ItemName, int SkinFamilyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.OnSkinPreloaded");

	APavlovGameState_OnSkinPreloaded_Params params {};
	params.ItemName = ItemName;
	params.SkinFamilyId = SkinFamilyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C970
//		Name   -> Function Pavlov.PavlovGameState.OnSkinLoaded
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::OnSkinLoaded(class AActor* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.OnSkinLoaded");

	APavlovGameState_OnSkinLoaded_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C890
//		Name   -> Function Pavlov.PavlovGameState.OnRep_GlobalInfo
//		Flags  -> (Final, Native, Public)
void APavlovGameState::OnRep_GlobalInfo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.OnRep_GlobalInfo");

	APavlovGameState_OnRep_GlobalInfo_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C870
//		Name   -> Function Pavlov.PavlovGameState.OnRep_BalancingCSV
//		Flags  -> (Final, Native, Private)
void APavlovGameState::OnRep_BalancingCSV()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.OnRep_BalancingCSV");

	APavlovGameState_OnRep_BalancingCSV_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C380
//		Name   -> Function Pavlov.PavlovGameState.OnModkitLoadLootMeshAsync
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FAsyncLoadLootMesh                          LoadLootMesh                                               (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::OnModkitLoadLootMeshAsync(const struct FAsyncLoadLootMesh& LoadLootMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.OnModkitLoadLootMeshAsync");

	APavlovGameState_OnModkitLoadLootMeshAsync_Params params {};
	params.LoadLootMesh = LoadLootMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> DelegateFunction Pavlov.PavlovGameState.OnGetVehicleClassToSpawnWRef__DelegateSignature
//		Flags  -> (Public, Delegate)
// Parameters:
//		class UClass*                                      VehicleClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FAsyncVehicleSpawnData                      AsyncVehicleSpawnData                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void APavlovGameState::OnGetVehicleClassToSpawnWRef__DelegateSignature(class UClass* VehicleClass, const struct FAsyncVehicleSpawnData& AsyncVehicleSpawnData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Pavlov.PavlovGameState.OnGetVehicleClassToSpawnWRef__DelegateSignature");

	APavlovGameState_OnGetVehicleClassToSpawnWRef__DelegateSignature_Params params {};
	params.VehicleClass = VehicleClass;
	params.AsyncVehicleSpawnData = AsyncVehicleSpawnData;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> DelegateFunction Pavlov.PavlovGameState.OnGetVehicleClassToSpawn__DelegateSignature
//		Flags  -> (Public, Delegate, HasDefaults)
// Parameters:
//		class UClass*                                      VehicleClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::OnGetVehicleClassToSpawn__DelegateSignature(class UClass* VehicleClass, const struct FTransform& SpawnTransform, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Pavlov.PavlovGameState.OnGetVehicleClassToSpawn__DelegateSignature");

	APavlovGameState_OnGetVehicleClassToSpawn__DelegateSignature_Params params {};
	params.VehicleClass = VehicleClass;
	params.SpawnTransform = SpawnTransform;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> DelegateFunction Pavlov.PavlovGameState.OnGetVehicleClass__DelegateSignature
//		Flags  -> (Public, Delegate)
// Parameters:
//		class UClass*                                      VehicleClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::OnGetVehicleClass__DelegateSignature(class UClass* VehicleClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Pavlov.PavlovGameState.OnGetVehicleClass__DelegateSignature");

	APavlovGameState_OnGetVehicleClass__DelegateSignature_Params params {};
	params.VehicleClass = VehicleClass;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069C150
//		Name   -> Function Pavlov.PavlovGameState.MulticastOnKillfeedEntry
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
//		struct FKillfeedEntry                              NewEntry                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
void APavlovGameState::MulticastOnKillfeedEntry(const struct FKillfeedEntry& NewEntry)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.MulticastOnKillfeedEntry");

	APavlovGameState_MulticastOnKillfeedEntry_Params params {};
	params.NewEntry = NewEntry;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069BFC0
//		Name   -> Function Pavlov.PavlovGameState.ModkitLootLoaded
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FAsyncLoadLootMesh                          LoadLootMesh                                               (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void APavlovGameState::ModkitLootLoaded(const struct FAsyncLoadLootMesh& LoadLootMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.ModkitLootLoaded");

	APavlovGameState_ModkitLootLoaded_Params params {};
	params.LoadLootMesh = LoadLootMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069BE60
//		Name   -> Function Pavlov.PavlovGameState.LootLoaded
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FScriptDelegate                             LoadedDelegate                                             (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
void APavlovGameState::LootLoaded(const struct FScriptDelegate& LoadedDelegate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LootLoaded");

	APavlovGameState_LootLoaded_Params params {};
	params.LoadedDelegate = LoadedDelegate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B590
//		Name   -> Function Pavlov.PavlovGameState.LoadSkinForItem
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PavPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AVRItem*                                     Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::LoadSkinForItem(class APavlovPlayerState* PavPlayerState, class UClass* ItemClass, class AVRItem* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LoadSkinForItem");

	APavlovGameState_LoadSkinForItem_Params params {};
	params.PavPlayerState = PavPlayerState;
	params.ItemClass = ItemClass;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069B490
//		Name   -> Function Pavlov.PavlovGameState.LoadSkin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PavPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::LoadSkin(class APavlovPlayerState* PavPlayerState, const struct FName& ItemName, class AActor* Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LoadSkin");

	APavlovGameState_LoadSkin_Params params {};
	params.PavPlayerState = PavPlayerState;
	params.ItemName = ItemName;
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069BA30
//		Name   -> Function Pavlov.PavlovGameState.LoadedVehicleClassToSpawnWRef
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FScriptDelegate                             OnVehicleClassToSpawnWRefLoaded                            (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
//		struct FAsyncVehicleSpawnData                      AsyncVehicleSpawnData                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void APavlovGameState::LoadedVehicleClassToSpawnWRef(const struct FScriptDelegate& OnVehicleClassToSpawnWRefLoaded, const struct FAsyncVehicleSpawnData& AsyncVehicleSpawnData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LoadedVehicleClassToSpawnWRef");

	APavlovGameState_LoadedVehicleClassToSpawnWRef_Params params {};
	params.OnVehicleClassToSpawnWRefLoaded = OnVehicleClassToSpawnWRefLoaded;
	params.AsyncVehicleSpawnData = AsyncVehicleSpawnData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B7F0
//		Name   -> Function Pavlov.PavlovGameState.LoadedVehicleClassToSpawn
//		Flags  -> (Final, Native, Public, HasDefaults)
// Parameters:
//		struct FScriptDelegate                             OnVehicleClassToSpawnLoaded                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::LoadedVehicleClassToSpawn(const struct FScriptDelegate& OnVehicleClassToSpawnLoaded, const struct FTransform& SpawnTransform, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LoadedVehicleClassToSpawn");

	APavlovGameState_LoadedVehicleClassToSpawn_Params params {};
	params.OnVehicleClassToSpawnLoaded = OnVehicleClassToSpawnLoaded;
	params.SpawnTransform = SpawnTransform;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B690
//		Name   -> Function Pavlov.PavlovGameState.LoadedVehicleClass
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FScriptDelegate                             OnVehicleClassLoaded                                       (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
void APavlovGameState::LoadedVehicleClass(const struct FScriptDelegate& OnVehicleClassLoaded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LoadedVehicleClass");

	APavlovGameState_LoadedVehicleClass_Params params {};
	params.OnVehicleClassLoaded = OnVehicleClassLoaded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B470
//		Name   -> Function Pavlov.PavlovGameState.LoadBalanceTableAsync
//		Flags  -> (Final, Native, Public)
void APavlovGameState::LoadBalanceTableAsync()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.LoadBalanceTableAsync");

	APavlovGameState_LoadBalanceTableAsync_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069B0C0
//		Name   -> Function Pavlov.PavlovGameState.IsVehicleNameValid
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       VehicleName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::IsVehicleNameValid(const struct FName& VehicleName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.IsVehicleNameValid");

	APavlovGameState_IsVehicleNameValid_Params params {};
	params.VehicleName = VehicleName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069AF70
//		Name   -> Function Pavlov.PavlovGameState.IsTeamAbleToBuy
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::IsTeamAbleToBuy(const struct FName& EquipmentName, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.IsTeamAbleToBuy");

	APavlovGameState_IsTeamAbleToBuy_Params params {};
	params.EquipmentName = EquipmentName;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069AEB0
//		Name   -> Function Pavlov.PavlovGameState.IsSkinPreloaded
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       ItemName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                SkinFamilyId                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::IsSkinPreloaded(const struct FName& ItemName, int SkinFamilyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.IsSkinPreloaded");

	APavlovGameState_IsSkinPreloaded_Params params {};
	params.ItemName = ItemName;
	params.SkinFamilyId = SkinFamilyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069AE90
//		Name   -> Function Pavlov.PavlovGameState.InitializeCosmeticTickActors
//		Flags  -> (Final, Native, Public)
void APavlovGameState::InitializeCosmeticTickActors()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.InitializeCosmeticTickActors");

	APavlovGameState_InitializeCosmeticTickActors_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0069A8C0
//		Name   -> Function Pavlov.PavlovGameState.GetVehicleClassWRef
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FScriptDelegate                             OnVehicleClassToSpawnWRefLoaded                            (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
//		struct FAsyncVehicleSpawnData                      AsyncVehicleSpawnData                                      (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::GetVehicleClassWRef(const struct FScriptDelegate& OnVehicleClassToSpawnWRefLoaded, const struct FAsyncVehicleSpawnData& AsyncVehicleSpawnData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetVehicleClassWRef");

	APavlovGameState_GetVehicleClassWRef_Params params {};
	params.OnVehicleClassToSpawnWRefLoaded = OnVehicleClassToSpawnWRefLoaded;
	params.AsyncVehicleSpawnData = AsyncVehicleSpawnData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A710
//		Name   -> Function Pavlov.PavlovGameState.GetVehicleClassToSpawnAsync
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       VehicleName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FScriptDelegate                             OnVehicleClassToSpawnLoaded                                (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
//		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::GetVehicleClassToSpawnAsync(const struct FName& VehicleName, const struct FScriptDelegate& OnVehicleClassToSpawnLoaded, const struct FTransform& SpawnTransform, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetVehicleClassToSpawnAsync");

	APavlovGameState_GetVehicleClassToSpawnAsync_Params params {};
	params.VehicleName = VehicleName;
	params.OnVehicleClassToSpawnLoaded = OnVehicleClassToSpawnLoaded;
	params.SpawnTransform = SpawnTransform;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A610
//		Name   -> Function Pavlov.PavlovGameState.GetVehicleClassByNameAsync
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       VehicleName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FScriptDelegate                             OnVehicleClassLoaded                                       (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::GetVehicleClassByNameAsync(const struct FName& VehicleName, const struct FScriptDelegate& OnVehicleClassLoaded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetVehicleClassByNameAsync");

	APavlovGameState_GetVehicleClassByNameAsync_Params params {};
	params.VehicleName = VehicleName;
	params.OnVehicleClassLoaded = OnVehicleClassLoaded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A580
//		Name   -> Function Pavlov.PavlovGameState.GetVehicleClassByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       VehicleName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* APavlovGameState::GetVehicleClassByName(const struct FName& VehicleName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetVehicleClassByName");

	APavlovGameState_GetVehicleClassByName_Params params {};
	params.VehicleName = VehicleName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A3C0
//		Name   -> Function Pavlov.PavlovGameState.GetTeamScore
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameState::GetTeamScore(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetTeamScore");

	APavlovGameState_GetTeamScore_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0069A240
//		Name   -> Function Pavlov.PavlovGameState.GetTeamArray
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<class APavlovPlayerState*>                  TeamArray                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::GetTeamArray(TArray<class APavlovPlayerState*>* TeamArray, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetTeamArray");

	APavlovGameState_GetTeamArray_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (TeamArray != nullptr)
		*TeamArray = params.TeamArray;

}


// Function:
//		Offset -> 0x0069A140
//		Name   -> Function Pavlov.PavlovGameState.GetSpawnableEquipmentNames
//		Flags  -> (Final, Native, Public)
// Parameters:
//		TArray<struct FName>                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FName> APavlovGameState::GetSpawnableEquipmentNames()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetSpawnableEquipmentNames");

	APavlovGameState_GetSpawnableEquipmentNames_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699F80
//		Name   -> Function Pavlov.PavlovGameState.GetSortedPlayerArray
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<class APavlovPlayerState*>                  SortedPlayerArray                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
//		int                                                FilterByTeamId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::GetSortedPlayerArray(TArray<class APavlovPlayerState*>* SortedPlayerArray, int FilterByTeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetSortedPlayerArray");

	APavlovGameState_GetSortedPlayerArray_Params params {};
	params.FilterByTeamId = FilterByTeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (SortedPlayerArray != nullptr)
		*SortedPlayerArray = params.SortedPlayerArray;

}


// Function:
//		Offset -> 0x00699D80
//		Name   -> Function Pavlov.PavlovGameState.GetPlayerStringId
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString APavlovGameState::GetPlayerStringId(class APavlovPlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetPlayerStringId");

	APavlovGameState_GetPlayerStringId_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699CD0
//		Name   -> Function Pavlov.PavlovGameState.GetPlayerStateByStringId
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     StringId                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPlayerState*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPlayerState* APavlovGameState::GetPlayerStateByStringId(const struct FString& StringId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetPlayerStateByStringId");

	APavlovGameState_GetPlayerStateByStringId_Params params {};
	params.StringId = StringId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699C10
//		Name   -> Function Pavlov.PavlovGameState.GetPlayerByScore
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPlayerState*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPlayerState* APavlovGameState::GetPlayerByScore(int Index, int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetPlayerByScore");

	APavlovGameState_GetPlayerByScore_Params params {};
	params.Index = Index;
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699B80
//		Name   -> Function Pavlov.PavlovGameState.GetMaxPurchasesPerPlayer
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
unsigned char APavlovGameState::GetMaxPurchasesPerPlayer(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetMaxPurchasesPerPlayer");

	APavlovGameState_GetMaxPurchasesPerPlayer_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699B20
//		Name   -> Function Pavlov.PavlovGameState.GetMatchResult
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_EMatchResult                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EMatchResult APavlovGameState::GetMatchResult()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetMatchResult");

	APavlovGameState_GetMatchResult_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699A20
//		Name   -> Function Pavlov.PavlovGameState.GetLootMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       LootName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FScriptDelegate                             OnLoaded                                                   (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::GetLootMesh(const struct FName& LootName, const struct FScriptDelegate& OnLoaded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetLootMesh");

	APavlovGameState_GetLootMesh_Params params {};
	params.LootName = LootName;
	params.OnLoaded = OnLoaded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699840
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentNames
//		Flags  -> (Final, Native, Public)
// Parameters:
//		TArray<struct FName>                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FName> APavlovGameState::GetEquipmentNames()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentNames");

	APavlovGameState_GetEquipmentNames_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006997B0
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentNameByIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName APavlovGameState::GetEquipmentNameByIndex(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentNameByIndex");

	APavlovGameState_GetEquipmentNameByIndex_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699720
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentNameByClass
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName APavlovGameState::GetEquipmentNameByClass(class UClass* ItemClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentNameByClass");

	APavlovGameState_GetEquipmentNameByClass_Params params {};
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699690
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentMagCount
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameState::GetEquipmentMagCount(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentMagCount");

	APavlovGameState_GetEquipmentMagCount_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699600
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentKillBonus
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameState::GetEquipmentKillBonus(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentKillBonus");

	APavlovGameState_GetEquipmentKillBonus_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699570
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentIndexByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameState::GetEquipmentIndexByName(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentIndexByName");

	APavlovGameState_GetEquipmentIndexByName_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699420
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentDataByClass
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bSuccess                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FEquipmentData                              ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
struct FEquipmentData APavlovGameState::GetEquipmentDataByClass(class UClass* ItemClass, bool* bSuccess)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentDataByClass");

	APavlovGameState_GetEquipmentDataByClass_Params params {};
	params.ItemClass = ItemClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (bSuccess != nullptr)
		*bSuccess = params.bSuccess;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006992D0
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentData
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bSuccess                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FEquipmentData                              ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
struct FEquipmentData APavlovGameState::GetEquipmentData(const struct FName& EquipmentName, bool* bSuccess)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentData");

	APavlovGameState_GetEquipmentData_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (bSuccess != nullptr)
		*bSuccess = params.bSuccess;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699240
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentCost
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovGameState::GetEquipmentCost(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentCost");

	APavlovGameState_GetEquipmentCost_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006991B0
//		Name   -> Function Pavlov.PavlovGameState.GetEquipmentClassByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* APavlovGameState::GetEquipmentClassByName(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetEquipmentClassByName");

	APavlovGameState_GetEquipmentClassByName_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00699070
//		Name   -> Function Pavlov.PavlovGameState.GetAsyncLoader
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UVRAsyncLoader*                              ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVRAsyncLoader* APavlovGameState::GetAsyncLoader()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.GetAsyncLoader");

	APavlovGameState_GetAsyncLoader_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00698F30
//		Name   -> Function Pavlov.PavlovGameState.DisplayMatchStateOverlay
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      OverlayClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovGameState::DisplayMatchStateOverlay(class UClass* OverlayClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.DisplayMatchStateOverlay");

	APavlovGameState_DisplayMatchStateOverlay_Params params {};
	params.OverlayClass = OverlayClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00698DA0
//		Name   -> Function Pavlov.PavlovGameState.CanRemoveAttachments
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::CanRemoveAttachments()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.CanRemoveAttachments");

	APavlovGameState_CanRemoveAttachments_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00698BE0
//		Name   -> Function Pavlov.PavlovGameState.ArePlayersEnemies
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APlayerState*                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APlayerState*                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovGameState::ArePlayersEnemies(class APlayerState* A, class APlayerState* B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameState.ArePlayersEnemies");

	APavlovGameState_ArePlayersEnemies_Params params {};
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A3100
//		Name   -> Function Pavlov.PavlovGameUserSettings.UseOOBLocomotion
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::UseOOBLocomotion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.UseOOBLocomotion");

	UPavlovGameUserSettings_UseOOBLocomotion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A30D0
//		Name   -> Function Pavlov.PavlovGameUserSettings.UseGrabForce
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::UseGrabForce()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.UseGrabForce");

	UPavlovGameUserSettings_UseGrabForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A30B0
//		Name   -> Function Pavlov.PavlovGameUserSettings.ShouldSwapControllers
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::ShouldSwapControllers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.ShouldSwapControllers");

	UPavlovGameUserSettings_ShouldSwapControllers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A2F80
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetVoiceDevice
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     DeviceURL                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetVoiceDevice(const struct FString& DeviceURL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetVoiceDevice");

	UPavlovGameUserSettings_SetVoiceDevice_Params params {};
	params.DeviceURL = DeviceURL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2EF0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetVirtualStock
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetVirtualStock(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetVirtualStock");

	UPavlovGameUserSettings_SetVirtualStock_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2E70
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetUseGrabForce
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetUseGrabForce(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetUseGrabForce");

	UPavlovGameUserSettings_SetUseGrabForce_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2DE0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetUseAudioThread
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetUseAudioThread(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetUseAudioThread");

	UPavlovGameUserSettings_SetUseAudioThread_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2D60
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetTwoHandToggle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetTwoHandToggle(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetTwoHandToggle");

	UPavlovGameUserSettings_SetTwoHandToggle_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2CE0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetTouchpadInverted
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bInverted                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetTouchpadInverted(bool bInverted)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetTouchpadInverted");

	UPavlovGameUserSettings_SetTouchpadInverted_Params params {};
	params.bInverted = bInverted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2C60
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetSwapControllers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetSwapControllers(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetSwapControllers");

	UPavlovGameUserSettings_SetSwapControllers_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2B70
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetStartUpMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     NewStartUpMap                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetStartUpMap(const struct FString& NewStartUpMap)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetStartUpMap");

	UPavlovGameUserSettings_SetStartUpMap_Params params {};
	params.NewStartUpMap = NewStartUpMap;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2AE0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetSnapTurn
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetSnapTurn(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetSnapTurn");

	UPavlovGameUserSettings_SetSnapTurn_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2A60
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetSmoothTurnRate
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetSmoothTurnRate(float Rate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetSmoothTurnRate");

	UPavlovGameUserSettings_SetSmoothTurnRate_Params params {};
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A29E0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetSmoothTurn
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetSmoothTurn(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetSmoothTurn");

	UPavlovGameUserSettings_SetSmoothTurn_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2960
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetSmoothLocomotionMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		VRFramework_EVRSmoothLocomotionMode                NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetSmoothLocomotionMode(VRFramework_EVRSmoothLocomotionMode NewMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetSmoothLocomotionMode");

	UPavlovGameUserSettings_SetSmoothLocomotionMode_Params params {};
	params.NewMode = NewMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A28E0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetServerSortType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EServerSortType                             SortType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetServerSortType(Pavlov_EServerSortType SortType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetServerSortType");

	UPavlovGameUserSettings_SetServerSortType_Params params {};
	params.SortType = SortType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2860
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetServerSearchType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EServerSearchType                           SearchType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetServerSearchType(Pavlov_EServerSearchType SearchType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetServerSearchType");

	UPavlovGameUserSettings_SetServerSearchType_Params params {};
	params.SearchType = SearchType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A27E0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetResolutionQuality
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Quality                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetResolutionQuality(float Quality)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetResolutionQuality");

	UPavlovGameUserSettings_SetResolutionQuality_Params params {};
	params.Quality = Quality;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2630
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetRegionFilters
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<struct FString>                             Filters                                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetRegionFilters(TArray<struct FString> Filters)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetRegionFilters");

	UPavlovGameUserSettings_SetRegionFilters_Params params {};
	params.Filters = Filters;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A25A0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetRealTimeReverb
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetRealTimeReverb(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetRealTimeReverb");

	UPavlovGameUserSettings_SetRealTimeReverb_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2520
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetPrimaryRegion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EOnlineRegion                               Region                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetPrimaryRegion(Pavlov_EOnlineRegion Region)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetPrimaryRegion");

	UPavlovGameUserSettings_SetPrimaryRegion_Params params {};
	params.Region = Region;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2490
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetPlayerRightHanded
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRightHanded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetPlayerRightHanded(bool bRightHanded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetPlayerRightHanded");

	UPavlovGameUserSettings_SetPlayerRightHanded_Params params {};
	params.bRightHanded = bRightHanded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2410
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetPlayerHeight
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetPlayerHeight(float Height)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetPlayerHeight");

	UPavlovGameUserSettings_SetPlayerHeight_Params params {};
	params.Height = Height;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2280
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetOOBLocomotion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bUse                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetOOBLocomotion(bool bUse)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetOOBLocomotion");

	UPavlovGameUserSettings_SetOOBLocomotion_Params params {};
	params.bUse = bUse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2380
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetOnScreenEffectsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetOnScreenEffectsEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetOnScreenEffectsEnabled");

	UPavlovGameUserSettings_SetOnScreenEffectsEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2300
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetOffHandAction
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_ECustomAction                               Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetOffHandAction(Pavlov_ECustomAction Action)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetOffHandAction");

	UPavlovGameUserSettings_SetOffHandAction_Params params {};
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2200
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetNoAmbisonics
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetNoAmbisonics(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetNoAmbisonics");

	UPavlovGameUserSettings_SetNoAmbisonics_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2180
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetMountFriendly
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bFriendly                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetMountFriendly(bool bFriendly)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetMountFriendly");

	UPavlovGameUserSettings_SetMountFriendly_Params params {};
	params.bFriendly = bFriendly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2100
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetMicMuted
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bMuted                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetMicMuted(bool bMuted)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetMicMuted");

	UPavlovGameUserSettings_SetMicMuted_Params params {};
	params.bMuted = bMuted;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A2080
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetMenuScoreboardSwaped
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetMenuScoreboardSwaped(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetMenuScoreboardSwaped");

	UPavlovGameUserSettings_SetMenuScoreboardSwaped_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1FA0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetMapAsFavoriteById
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetMapAsFavoriteById(const struct FString& ID, bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetMapAsFavoriteById");

	UPavlovGameUserSettings_SetMapAsFavoriteById_Params params {};
	params.ID = ID;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1ED0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetMapAsFavorite
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UPavlov_Map*                                 Map                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetMapAsFavorite(class UPavlov_Map* Map, bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetMapAsFavorite");

	UPavlovGameUserSettings_SetMapAsFavorite_Params params {};
	params.Map = Map;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1E50
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetMainHandAction
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_ECustomAction                               Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetMainHandAction(Pavlov_ECustomAction Action)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetMainHandAction");

	UPavlovGameUserSettings_SetMainHandAction_Params params {};
	params.Action = Action;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1DD0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetLockInventory
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetLockInventory(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetLockInventory");

	UPavlovGameUserSettings_SetLockInventory_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1D50
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetLiteFootStepHaptics
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetLiteFootStepHaptics(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetLiteFootStepHaptics");

	UPavlovGameUserSettings_SetLiteFootStepHaptics_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1CD0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetLegacyGrip
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetLegacyGrip(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetLegacyGrip");

	UPavlovGameUserSettings_SetLegacyGrip_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1C40
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetLeftEyeRendering
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetLeftEyeRendering(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetLeftEyeRendering");

	UPavlovGameUserSettings_SetLeftEyeRendering_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1BC0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetHidePinLockedServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bHideLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetHidePinLockedServers(bool bHideLocked)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetHidePinLockedServers");

	UPavlovGameUserSettings_SetHidePinLockedServers_Params params {};
	params.bHideLocked = bHideLocked;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1B40
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetHideFullServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               HideFull                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetHideFullServers(bool HideFull)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetHideFullServers");

	UPavlovGameUserSettings_SetHideFullServers_Params params {};
	params.HideFull = HideFull;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1AC0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetHideEmptyServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bHideEmpty                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetHideEmptyServers(bool bHideEmpty)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetHideEmptyServers");

	UPavlovGameUserSettings_SetHideEmptyServers_Params params {};
	params.bHideEmpty = bHideEmpty;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1A30
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetHideAmmoCount
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bHidden                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetHideAmmoCount(bool bHidden)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetHideAmmoCount");

	UPavlovGameUserSettings_SetHideAmmoCount_Params params {};
	params.bHidden = bHidden;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A19B0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetHeadLocomotion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetHeadLocomotion(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetHeadLocomotion");

	UPavlovGameUserSettings_SetHeadLocomotion_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1930
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetGripMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EGripMode                                   NewGripMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetGripMode(Pavlov_EGripMode NewGripMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetGripMode");

	UPavlovGameUserSettings_SetGripMode_Params params {};
	params.NewGripMode = NewGripMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A18B0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetGrabForceThreashold
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetGrabForceThreashold(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetGrabForceThreashold");

	UPavlovGameUserSettings_SetGrabForceThreashold_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1830
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetGoreLevel
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EGoreLevel                                  Level                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetGoreLevel(Pavlov_EGoreLevel Level)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetGoreLevel");

	UPavlovGameUserSettings_SetGoreLevel_Params params {};
	params.Level = Level;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1680
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetGMFilters
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<struct FString>                             Filters                                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetGMFilters(TArray<struct FString> Filters)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetGMFilters");

	UPavlovGameUserSettings_SetGMFilters_Params params {};
	params.Filters = Filters;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1600
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetFreeSpectatingEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetFreeSpectatingEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetFreeSpectatingEnabled");

	UPavlovGameUserSettings_SetFreeSpectatingEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1570
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetForceTubeEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetForceTubeEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetForceTubeEnabled");

	UPavlovGameUserSettings_SetForceTubeEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1370
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetFavoriteServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<struct FFavoriteServer>                     Servers                                                    (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetFavoriteServers(TArray<struct FFavoriteServer> Servers)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetFavoriteServers");

	UPavlovGameUserSettings_SetFavoriteServers_Params params {};
	params.Servers = Servers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A3020
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetbHapticsSuitEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetbHapticsSuitEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetbHapticsSuitEnabled");

	UPavlovGameUserSettings_SetbHapticsSuitEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A12F0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetAutoUngrip
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetAutoUngrip(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetAutoUngrip");

	UPavlovGameUserSettings_SetAutoUngrip_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1270
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetAutoSwapHandsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetAutoSwapHandsEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetAutoSwapHandsEnabled");

	UPavlovGameUserSettings_SetAutoSwapHandsEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A11F0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetAutoSprint
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetAutoSprint(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetAutoSprint");

	UPavlovGameUserSettings_SetAutoSprint_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A1160
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetArmKillfeedEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetArmKillfeedEnabled(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetArmKillfeedEnabled");

	UPavlovGameUserSettings_SetArmKillfeedEnabled_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A10D0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SetAdvancedVehicleInput
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bUseAdvanced                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SetAdvancedVehicleInput(bool bUseAdvanced)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SetAdvancedVehicleInput");

	UPavlovGameUserSettings_SetAdvancedVehicleInput_Params params {};
	params.bUseAdvanced = bUseAdvanced;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovGameUserSettings.SendAnalyticEvents
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameUserSettings::SendAnalyticEvents()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SendAnalyticEvents");

	UPavlovGameUserSettings_SendAnalyticEvents_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A0F70
//		Name   -> Function Pavlov.PavlovGameUserSettings.SaveSpectatorView
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  Transform                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::SaveSpectatorView(class UObject* WorldContextObject, int Index, const struct FTransform& Transform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.SaveSpectatorView");

	UPavlovGameUserSettings_SaveSpectatorView_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Index = Index;
	params.Transform = Transform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A0F50
//		Name   -> Function Pavlov.PavlovGameUserSettings.MarkAsCalibrated
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovGameUserSettings::MarkAsCalibrated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.MarkAsCalibrated");

	UPavlovGameUserSettings_MarkAsCalibrated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A0F30
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsTwoHandToggleEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsTwoHandToggleEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsTwoHandToggleEnabled");

	UPavlovGameUserSettings_IsTwoHandToggleEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0F10
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsTouchpadInverted
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsTouchpadInverted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsTouchpadInverted");

	UPavlovGameUserSettings_IsTouchpadInverted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0EE0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsSnapTurnEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsSnapTurnEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsSnapTurnEnabled");

	UPavlovGameUserSettings_IsSnapTurnEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0EC0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsSmoothTurnEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsSmoothTurnEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsSmoothTurnEnabled");

	UPavlovGameUserSettings_IsSmoothTurnEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0B70
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsPostProcessDisabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsPostProcessDisabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsPostProcessDisabled");

	UPavlovGameUserSettings_IsPostProcessDisabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0EA0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsPlayerRightHanded
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsPlayerRightHanded()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsPlayerRightHanded");

	UPavlovGameUserSettings_IsPlayerRightHanded_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0E70
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsOnScreenEffectsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsOnScreenEffectsEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsOnScreenEffectsEnabled");

	UPavlovGameUserSettings_IsOnScreenEffectsEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00687BA0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsMountFriendly
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsMountFriendly()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsMountFriendly");

	UPavlovGameUserSettings_IsMountFriendly_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0E50
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsMicMuted
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsMicMuted()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsMicMuted");

	UPavlovGameUserSettings_IsMicMuted_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0E30
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsMenuScoreboardSwapped
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsMenuScoreboardSwapped()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsMenuScoreboardSwapped");

	UPavlovGameUserSettings_IsMenuScoreboardSwapped_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0E10
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsLiteFootStepHapticsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsLiteFootStepHapticsEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsLiteFootStepHapticsEnabled");

	UPavlovGameUserSettings_IsLiteFootStepHapticsEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0DF0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsLeftEyeRendering
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsLeftEyeRendering()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsLeftEyeRendering");

	UPavlovGameUserSettings_IsLeftEyeRendering_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0DD0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsHeadLocomotionEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsHeadLocomotionEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsHeadLocomotionEnabled");

	UPavlovGameUserSettings_IsHeadLocomotionEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0DB0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsFreeSpectatingEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsFreeSpectatingEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsFreeSpectatingEnabled");

	UPavlovGameUserSettings_IsFreeSpectatingEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0D80
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsForceTubeEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsForceTubeEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsForceTubeEnabled");

	UPavlovGameUserSettings_IsForceTubeEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0CD0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsFavoriteMapById
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsFavoriteMapById(const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsFavoriteMapById");

	UPavlovGameUserSettings_IsFavoriteMapById_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0C40
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsFavoriteMap
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UPavlov_Map*                                 Map                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsFavoriteMap(class UPavlov_Map* Map)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsFavoriteMap");

	UPavlovGameUserSettings_IsFavoriteMap_Params params {};
	params.Map = Map;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0C20
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsCalibrated
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsCalibrated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsCalibrated");

	UPavlovGameUserSettings_IsCalibrated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0BF0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsBHapticsSuitEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsBHapticsSuitEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsBHapticsSuitEnabled");

	UPavlovGameUserSettings_IsBHapticsSuitEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0BD0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsAutoUngripEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsAutoUngripEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsAutoUngripEnabled");

	UPavlovGameUserSettings_IsAutoUngripEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0BB0
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsAutoSwapHandsEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsAutoSwapHandsEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsAutoSwapHandsEnabled");

	UPavlovGameUserSettings_IsAutoSwapHandsEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0B90
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsAutoSprintEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsAutoSprintEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsAutoSprintEnabled");

	UPavlovGameUserSettings_IsAutoSprintEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0B70
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsArmKillfeedEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsArmKillfeedEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsArmKillfeedEnabled");

	UPavlovGameUserSettings_IsArmKillfeedEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0B40
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsAmmoCounterHidden
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsAmmoCounterHidden()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsAmmoCounterHidden");

	UPavlovGameUserSettings_IsAmmoCounterHidden_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x002A9E70
//		Name   -> Function Pavlov.PavlovGameUserSettings.IsAdvancedVehicleInputEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::IsAdvancedVehicleInputEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.IsAdvancedVehicleInputEnabled");

	UPavlovGameUserSettings_IsAdvancedVehicleInputEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0B20
//		Name   -> Function Pavlov.PavlovGameUserSettings.HasLegacyGrip
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::HasLegacyGrip()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.HasLegacyGrip");

	UPavlovGameUserSettings_HasLegacyGrip_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0AF0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetVoiceDevice
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovGameUserSettings::GetVoiceDevice()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetVoiceDevice");

	UPavlovGameUserSettings_GetVoiceDevice_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0AD0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetVirtualStock
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetVirtualStock()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetVirtualStock");

	UPavlovGameUserSettings_GetVirtualStock_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0AA0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetUseAudioThread
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetUseAudioThread()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetUseAudioThread");

	UPavlovGameUserSettings_GetUseAudioThread_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0A70
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetStartUpMap
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovGameUserSettings::GetStartUpMap()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetStartUpMap");

	UPavlovGameUserSettings_GetStartUpMap_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0970
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetSpectatorView
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform UPavlovGameUserSettings::GetSpectatorView(class UObject* WorldContextObject, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetSpectatorView");

	UPavlovGameUserSettings_GetSpectatorView_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0950
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetSmoothTurnRate
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovGameUserSettings::GetSmoothTurnRate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetSmoothTurnRate");

	UPavlovGameUserSettings_GetSmoothTurnRate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0930
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetSmoothLocomotionMode
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		VRFramework_EVRSmoothLocomotionMode                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
VRFramework_EVRSmoothLocomotionMode UPavlovGameUserSettings::GetSmoothLocomotionMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetSmoothLocomotionMode");

	UPavlovGameUserSettings_GetSmoothLocomotionMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0910
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetServerSortType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EServerSortType                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EServerSortType UPavlovGameUserSettings::GetServerSortType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetServerSortType");

	UPavlovGameUserSettings_GetServerSortType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A08F0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetServerSearchType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EServerSearchType                           ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EServerSearchType UPavlovGameUserSettings::GetServerSearchType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetServerSearchType");

	UPavlovGameUserSettings_GetServerSearchType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0770
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetRegionFilters
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FString> UPavlovGameUserSettings::GetRegionFilters()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetRegionFilters");

	UPavlovGameUserSettings_GetRegionFilters_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0750
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetRealTimeVoiceReverb
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetRealTimeVoiceReverb()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetRealTimeVoiceReverb");

	UPavlovGameUserSettings_GetRealTimeVoiceReverb_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0730
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetPrimaryRegion
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EOnlineRegion                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EOnlineRegion UPavlovGameUserSettings::GetPrimaryRegion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetPrimaryRegion");

	UPavlovGameUserSettings_GetPrimaryRegion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0700
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetPlayerHeight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovGameUserSettings::GetPlayerHeight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetPlayerHeight");

	UPavlovGameUserSettings_GetPlayerHeight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A06E0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetOffHandAction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_ECustomAction                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_ECustomAction UPavlovGameUserSettings::GetOffHandAction()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetOffHandAction");

	UPavlovGameUserSettings_GetOffHandAction_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A06C0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetNoAmbisonics
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetNoAmbisonics()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetNoAmbisonics");

	UPavlovGameUserSettings_GetNoAmbisonics_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A06A0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetMainHandAction
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_ECustomAction                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_ECustomAction UPavlovGameUserSettings::GetMainHandAction()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetMainHandAction");

	UPavlovGameUserSettings_GetMainHandAction_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0680
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetLockInventory
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetLockInventory()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetLockInventory");

	UPavlovGameUserSettings_GetLockInventory_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0660
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetHidePinLockedServers
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetHidePinLockedServers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetHidePinLockedServers");

	UPavlovGameUserSettings_GetHidePinLockedServers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0640
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetHideFullServers
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetHideFullServers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetHideFullServers");

	UPavlovGameUserSettings_GetHideFullServers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0620
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetHideEmptyServers
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovGameUserSettings::GetHideEmptyServers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetHideEmptyServers");

	UPavlovGameUserSettings_GetHideEmptyServers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A05F0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetGripMode
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EGripMode                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EGripMode UPavlovGameUserSettings::GetGripMode()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetGripMode");

	UPavlovGameUserSettings_GetGripMode_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A05D0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetGrabForceThreashold
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovGameUserSettings::GetGrabForceThreashold()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetGrabForceThreashold");

	UPavlovGameUserSettings_GetGrabForceThreashold_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A05A0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetGoreLevel
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EGoreLevel                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EGoreLevel UPavlovGameUserSettings::GetGoreLevel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetGoreLevel");

	UPavlovGameUserSettings_GetGoreLevel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0420
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetGMFilters
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FString> UPavlovGameUserSettings::GetGMFilters()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetGMFilters");

	UPavlovGameUserSettings_GetGMFilters_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A02B0
//		Name   -> Function Pavlov.PavlovGameUserSettings.GetFavoriteServers
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TArray<struct FFavoriteServer>                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FFavoriteServer> UPavlovGameUserSettings::GetFavoriteServers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.GetFavoriteServers");

	UPavlovGameUserSettings_GetFavoriteServers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A0230
//		Name   -> Function Pavlov.PavlovGameUserSettings.ForceNoPostProcessing
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovGameUserSettings::ForceNoPostProcessing(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovGameUserSettings.ForceNoPostProcessing");

	UPavlovGameUserSettings_ForceNoPostProcessing_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB6E0
//		Name   -> Function Pavlov.PavlovHandAnimInstance.SetDefaultGripSequence
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UAnimSequence*                               UpdateSequence                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bImmersiveSequence                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovHandAnimInstance::SetDefaultGripSequence(class UAnimSequence* UpdateSequence, bool bImmersiveSequence)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovHandAnimInstance.SetDefaultGripSequence");

	UPavlovHandAnimInstance_SetDefaultGripSequence_Params params {};
	params.UpdateSequence = UpdateSequence;
	params.bImmersiveSequence = bImmersiveSequence;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8990
//		Name   -> Function Pavlov.PavlovHandAnimInstance.GetFingerBlend
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_EFinger                                     Finger                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovHandAnimInstance::GetFingerBlend(Pavlov_EFinger Finger)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovHandAnimInstance.GetFingerBlend");

	UPavlovHandAnimInstance_GetFingerBlend_Params params {};
	params.Finger = Finger;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006AC520
//		Name   -> Function Pavlov.PavlovLobby.Start
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovLobby::Start()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.Start");

	UPavlovLobby_Start_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC0A0
//		Name   -> Function Pavlov.PavlovLobby.SetWantToStart
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetWantToStart(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetWantToStart");

	UPavlovLobby_SetWantToStart_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006ABF10
//		Name   -> Function Pavlov.PavlovLobby.SetServerSettings
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FServerSettings                             NewServerSettings                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UPavlovLobby::SetServerSettings(const struct FServerSettings& NewServerSettings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetServerSettings");

	UPavlovLobby_SetServerSettings_Params params {};
	params.NewServerSettings = NewServerSettings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006ABE70
//		Name   -> Function Pavlov.PavlovLobby.SetRegion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     NewRegion                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetRegion(const struct FString& NewRegion)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetRegion");

	UPavlovLobby_SetRegion_Params params {};
	params.NewRegion = NewRegion;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006ABD50
//		Name   -> Function Pavlov.PavlovLobby.SetPin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Pin                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetPin(const struct FString& Pin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetPin");

	UPavlovLobby_SetPin_Params params {};
	params.Pin = Pin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB9F0
//		Name   -> Function Pavlov.PavlovLobby.SetMap
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     MapName                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetMap(const struct FString& MapName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetMap");

	UPavlovLobby_SetMap_Params params {};
	params.MapName = MapName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB8E0
//		Name   -> Function Pavlov.PavlovLobby.SetHostingType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EServerHostingType                          NewHostingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetHostingType(Pavlov_EServerHostingType NewHostingType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetHostingType");

	UPavlovLobby_SetHostingType_Params params {};
	params.NewHostingType = NewHostingType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB840
//		Name   -> Function Pavlov.PavlovLobby.SetGameMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     NewGameMode                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetGameMode(const struct FString& NewGameMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetGameMode");

	UPavlovLobby_SetGameMode_Params params {};
	params.NewGameMode = NewGameMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB7B0
//		Name   -> Function Pavlov.PavlovLobby.SetFillWithBots
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetFillWithBots(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetFillWithBots");

	UPavlovLobby_SetFillWithBots_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB660
//		Name   -> Function Pavlov.PavlovLobby.SetCompetitiveMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                CompMode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::SetCompetitiveMode(int CompMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.SetCompetitiveMode");

	UPavlovLobby_SetCompetitiveMode_Params params {};
	params.CompMode = CompMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB060
//		Name   -> Function Pavlov.PavlovLobby.RequestTeam
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                TeamId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::RequestTeam(int TeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.RequestTeam");

	UPavlovLobby_RequestTeam_Params params {};
	params.TeamId = TeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA8F0
//		Name   -> Function Pavlov.PavlovLobby.OnMapDownloadProgress
//		Flags  -> (Final, Native, Private)
// Parameters:
//		float                                              Progress                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::OnMapDownloadProgress(float Progress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.OnMapDownloadProgress");

	UPavlovLobby_OnMapDownloadProgress_Params params {};
	params.Progress = Progress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA970
//		Name   -> Function Pavlov.PavlovLobby.OnMapDownloaded
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::OnMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.OnMapDownloaded");

	UPavlovLobby_OnMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA670
//		Name   -> Function Pavlov.PavlovLobby.MuteMember
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovLobby::MuteMember(int Index, bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.MuteMember");

	UPavlovLobby_MuteMember_Params params {};
	params.Index = Index;
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9AE0
//		Name   -> Function Pavlov.PavlovLobby.IsPinProtected
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovLobby::IsPinProtected()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.IsPinProtected");

	UPavlovLobby_IsPinProtected_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A99F0
//		Name   -> Function Pavlov.PavlovLobby.IsMemberMuted
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovLobby::IsMemberMuted(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.IsMemberMuted");

	UPavlovLobby_IsMemberMuted_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A90E0
//		Name   -> Function Pavlov.PavlovLobby.GetRegion
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovLobby::GetRegion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.GetRegion");

	UPavlovLobby_GetRegion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9060
//		Name   -> Function Pavlov.PavlovLobby.GetPin
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovLobby::GetPin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.GetPin");

	UPavlovLobby_GetPin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8E80
//		Name   -> Function Pavlov.PavlovLobby.GetMemberTeam
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPavlovLobby::GetMemberTeam(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.GetMemberTeam");

	UPavlovLobby_GetMemberTeam_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8E50
//		Name   -> Function Pavlov.PavlovLobby.GetLocalUserIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPavlovLobby::GetLocalUserIndex()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.GetLocalUserIndex");

	UPavlovLobby_GetLocalUserIndex_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8710
//		Name   -> Function Pavlov.PavlovLobby.FindServer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovLobby::FindServer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.FindServer");

	UPavlovLobby_FindServer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8170
//		Name   -> Function Pavlov.PavlovLobby.DoesMemberWantsToStart
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovLobby::DoesMemberWantsToStart(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.DoesMemberWantsToStart");

	UPavlovLobby_DoesMemberWantsToStart_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8060
//		Name   -> Function Pavlov.PavlovLobby.CheckSessionStatus
//		Flags  -> (Final, Native, Private)
void UPavlovLobby::CheckSessionStatus()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.CheckSessionStatus");

	UPavlovLobby_CheckSessionStatus_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8040
//		Name   -> Function Pavlov.PavlovLobby.CancelServerFind
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UPavlovLobby::CancelServerFind()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovLobby.CancelServerFind");

	UPavlovLobby_CancelServerFind_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB180
//		Name   -> Function Pavlov.PavlovMovementComponent.ServerDeployParachute
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void UPavlovMovementComponent::ServerDeployParachute()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovMovementComponent.ServerDeployParachute");

	UPavlovMovementComponent_ServerDeployParachute_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovMovementComponent.OnRep_PrachuteState
//		Flags  -> (Final, Native, Private)
void UPavlovMovementComponent::OnRep_PrachuteState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovMovementComponent.OnRep_PrachuteState");

	UPavlovMovementComponent_OnRep_PrachuteState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x003F3740
//		Name   -> Function Pavlov.PavlovMovementComponent.MulticastOnParachuteDeployed
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void UPavlovMovementComponent::MulticastOnParachuteDeployed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovMovementComponent.MulticastOnParachuteDeployed");

	UPavlovMovementComponent_MulticastOnParachuteDeployed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A85B0
//		Name   -> Function Pavlov.PavlovMovementComponent.EnableParachuteMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableParachuteMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovMovementComponent::EnableParachuteMode(bool bEnableParachuteMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovMovementComponent.EnableParachuteMode");

	UPavlovMovementComponent_EnableParachuteMode_Params params {};
	params.bEnableParachuteMode = bEnableParachuteMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC980
//		Name   -> Function Pavlov.PavlovPawn.WearKevlar
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bWithHelmet                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::WearKevlar(bool bWithHelmet)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.WearKevlar");

	APavlovPawn_WearKevlar_Params params {};
	params.bWithHelmet = bWithHelmet;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC960
//		Name   -> Function Pavlov.PavlovPawn.WearHelmet
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPawn::WearHelmet()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.WearHelmet");

	APavlovPawn_WearHelmet_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC920
//		Name   -> Function Pavlov.PavlovPawn.UpdateLocomotion
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPawn::UpdateLocomotion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.UpdateLocomotion");

	APavlovPawn_UpdateLocomotion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC890
//		Name   -> Function Pavlov.PavlovPawn.TryStackAmmoBoxes
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class AAmmoBox*                                    AmmoBox                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::TryStackAmmoBoxes(class AAmmoBox* AmmoBox)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.TryStackAmmoBoxes");

	APavlovPawn_TryStackAmmoBoxes_Params params {};
	params.AmmoBox = AmmoBox;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006AC800
//		Name   -> Function Pavlov.PavlovPawn.ToggleRadio
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ToggleRadio(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ToggleRadio");

	APavlovPawn_ToggleRadio_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC540
//		Name   -> Function Pavlov.PavlovPawn.TakePointDamage
//		Flags  -> (Final, Native, Private, HasDefaults)
// Parameters:
//		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ShotFromDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::TakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, const struct FName& BoneName, const struct FVector& ShotFromDirection, class UDamageType* DamageType, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.TakePointDamage");

	APavlovPawn_TakePointDamage_Params params {};
	params.DamagedActor = DamagedActor;
	params.Damage = Damage;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.HitComponent = HitComponent;
	params.BoneName = BoneName;
	params.ShotFromDirection = ShotFromDirection;
	params.DamageType = DamageType;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC490
//		Name   -> Function Pavlov.PavlovPawn.SpawnHitFeedbackSound
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EHitFeedbackType                            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAudioComponent* APavlovPawn::SpawnHitFeedbackSound(Pavlov_EHitFeedbackType Type)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SpawnHitFeedbackSound");

	APavlovPawn_SpawnHitFeedbackSound_Params params {};
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006AC2D0
//		Name   -> Function Pavlov.PavlovPawn.SpawnHeadshotEffect
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class APlayerState*                                Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitDirection                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     WorldHitLocation                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     WorldHitDirection                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::SpawnHeadshotEffect(class APlayerState* Killer, const struct FVector& HitLocation, const struct FVector& HitDirection, struct FVector* WorldHitLocation, struct FVector* WorldHitDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SpawnHeadshotEffect");

	APavlovPawn_SpawnHeadshotEffect_Params params {};
	params.Killer = Killer;
	params.HitLocation = HitLocation;
	params.HitDirection = HitDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (WorldHitLocation != nullptr)
		*WorldHitLocation = params.WorldHitLocation;
	if (WorldHitDirection != nullptr)
		*WorldHitDirection = params.WorldHitDirection;

}


// Function:
//		Offset -> 0x006AC240
//		Name   -> Function Pavlov.PavlovPawn.ShowLimitedAmmoCounter
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bCounterVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ShowLimitedAmmoCounter(bool bCounterVisible)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ShowLimitedAmmoCounter");

	APavlovPawn_ShowLimitedAmmoCounter_Params params {};
	params.bCounterVisible = bCounterVisible;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.SetupWatch
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UWatch*                                      WatchComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::SetupWatch(class UWatch* WatchComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetupWatch");

	APavlovPawn_SetupWatch_Params params {};
	params.WatchComp = WatchComp;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC1C0
//		Name   -> Function Pavlov.PavlovPawn.SetupLimitedAmmoComp
//		Flags  -> (Final, Native, Public)
// Parameters:
//		PavlovProxy_ELimitedAmmoType                       LimitedAmmoMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::SetupLimitedAmmoComp(PavlovProxy_ELimitedAmmoType LimitedAmmoMode)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetupLimitedAmmoComp");

	APavlovPawn_SetupLimitedAmmoComp_Params params {};
	params.LimitedAmmoMode = LimitedAmmoMode;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AC020
//		Name   -> Function Pavlov.PavlovPawn.SetTeamId
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::SetTeamId(int NewTeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetTeamId");

	APavlovPawn_SetTeamId_Params params {};
	params.NewTeamId = NewTeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006ABDF0
//		Name   -> Function Pavlov.PavlovPawn.SetPlayerSkin
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       PlayerSkin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::SetPlayerSkin(const struct FName& PlayerSkin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetPlayerSkin");

	APavlovPawn_SetPlayerSkin_Params params {};
	params.PlayerSkin = PlayerSkin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006ABC40
//		Name   -> Function Pavlov.PavlovPawn.SetPainkillerDetails
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Painkillers                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                NumOfPills                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              HealAmount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::SetPainkillerDetails(class AActor* Painkillers, int NumOfPills, float HealAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetPainkillerDetails");

	APavlovPawn_SetPainkillerDetails_Params params {};
	params.Painkillers = Painkillers;
	params.NumOfPills = NumOfPills;
	params.HealAmount = HealAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006ABB80
//		Name   -> Function Pavlov.PavlovPawn.SetNumOfSyringeRevives
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Syringe                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                NumOfRevives                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::SetNumOfSyringeRevives(class AActor* Syringe, int NumOfRevives)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetNumOfSyringeRevives");

	APavlovPawn_SetNumOfSyringeRevives_Params params {};
	params.Syringe = Syringe;
	params.NumOfRevives = NumOfRevives;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006ABB60
//		Name   -> Function Pavlov.PavlovPawn.SetModdingVoiceAttn
//		Flags  -> (Final, Native, Public)
void APavlovPawn::SetModdingVoiceAttn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetModdingVoiceAttn");

	APavlovPawn_SetModdingVoiceAttn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB5A0
//		Name   -> Function Pavlov.PavlovPawn.SetAvatarSkin
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      NewSkinClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       CustomMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::SetAvatarSkin(class UClass* NewSkinClass, const struct FName& CustomMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SetAvatarSkin");

	APavlovPawn_SetAvatarSkin_Params params {};
	params.NewSkinClass = NewSkinClass;
	params.CustomMesh = CustomMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB4F0
//		Name   -> Function Pavlov.PavlovPawn.ServerUpdateFingerTracking
//		Flags  -> (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
//		struct FFingerTracking                             Data                                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::ServerUpdateFingerTracking(const struct FFingerTracking& Data)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ServerUpdateFingerTracking");

	APavlovPawn_ServerUpdateFingerTracking_Params params {};
	params.Data = Data;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB440
//		Name   -> Function Pavlov.PavlovPawn.ServerSetRadioChannel
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		unsigned char                                      Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ServerSetRadioChannel(unsigned char Channel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ServerSetRadioChannel");

	APavlovPawn_ServerSetRadioChannel_Params params {};
	params.Channel = Channel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB390
//		Name   -> Function Pavlov.PavlovPawn.ServerReportFallDamage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ServerReportFallDamage(float Damage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ServerReportFallDamage");

	APavlovPawn_ServerReportFallDamage_Params params {};
	params.Damage = Damage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB2D0
//		Name   -> Function Pavlov.PavlovPawn.ServerGiveMagazine
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		bool                                               bOffHand                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ServerGiveMagazine(bool bOffHand)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ServerGiveMagazine");

	APavlovPawn_ServerGiveMagazine_Params params {};
	params.bOffHand = bOffHand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB1D0
//		Name   -> Function Pavlov.PavlovPawn.ServerGive
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       Skin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ServerGive(const struct FName& EquipmentName, const struct FName& Skin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ServerGive");

	APavlovPawn_ServerGive_Params params {};
	params.EquipmentName = EquipmentName;
	params.Skin = Skin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB130
//		Name   -> Function Pavlov.PavlovPawn.ServerDeployParachute
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPawn::ServerDeployParachute()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ServerDeployParachute");

	APavlovPawn_ServerDeployParachute_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovPawn.SanityCheck
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPawn::SanityCheck()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.SanityCheck");

	APavlovPawn_SanityCheck_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AB0E0
//		Name   -> Function Pavlov.PavlovPawn.RevivePawn
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::RevivePawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.RevivePawn");

	APavlovPawn_RevivePawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006AB110
//		Name   -> Function Pavlov.PavlovPawn.Revived_Client
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APavlovPawn::Revived_Client()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.Revived_Client");

	APavlovPawn_Revived_Client_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAFD0
//		Name   -> Function Pavlov.PavlovPawn.ReplenishPlayerAmmo
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bSpawnKnife                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ReplenishPlayerAmmo(bool bSpawnKnife)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ReplenishPlayerAmmo");

	APavlovPawn_ReplenishPlayerAmmo_Params params {};
	params.bSpawnKnife = bSpawnKnife;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAF10
//		Name   -> Function Pavlov.PavlovPawn.RemoveAmmo
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       AmmoId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                RemoveAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovPawn::RemoveAmmo(const struct FName& AmmoId, int RemoveAmount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.RemoveAmmo");

	APavlovPawn_RemoveAmmo_Params params {};
	params.AmmoId = AmmoId;
	params.RemoveAmount = RemoveAmount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006AAE60
//		Name   -> Function Pavlov.PavlovPawn.ProxyTrigger
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bDominantController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ProxyTrigger(bool bDominantController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ProxyTrigger");

	APavlovPawn_ProxyTrigger_Params params {};
	params.bDominantController = bDominantController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AADD0
//		Name   -> Function Pavlov.PavlovPawn.ProxyGrab
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bDominantController                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ProxyGrab(bool bDominantController)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ProxyGrab");

	APavlovPawn_ProxyGrab_Params params {};
	params.bDominantController = bDominantController;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAD50
//		Name   -> Function Pavlov.PavlovPawn.OverrideVoiceAttn
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class USoundAttenuation*                           NewAttn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::OverrideVoiceAttn(class USoundAttenuation* NewAttn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OverrideVoiceAttn");

	APavlovPawn_OverrideVoiceAttn_Params params {};
	params.NewAttn = NewAttn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAD30
//		Name   -> Function Pavlov.PavlovPawn.OnWW2AvatarLoaded_Owner
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void APavlovPawn::OnWW2AvatarLoaded_Owner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnWW2AvatarLoaded_Owner");

	APavlovPawn_OnWW2AvatarLoaded_Owner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAD10
//		Name   -> Function Pavlov.PavlovPawn.OnTeamIdChanged
//		Flags  -> (Native, Event, Protected, BlueprintEvent)
void APavlovPawn::OnTeamIdChanged()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnTeamIdChanged");

	APavlovPawn_OnTeamIdChanged_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAB80
//		Name   -> Function Pavlov.PavlovPawn.OnRevive
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::OnRevive(class AActor* OwnerActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRevive");

	APavlovPawn_OnRevive_Params params {};
	params.OwnerActor = OwnerActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAB60
//		Name   -> Function Pavlov.PavlovPawn.OnRep_TeamId
//		Flags  -> (Native, Protected)
void APavlovPawn::OnRep_TeamId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_TeamId");

	APavlovPawn_OnRep_TeamId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAB40
//		Name   -> Function Pavlov.PavlovPawn.OnRep_RadioChannel
//		Flags  -> (Final, Native, Private)
void APavlovPawn::OnRep_RadioChannel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_RadioChannel");

	APavlovPawn_OnRep_RadioChannel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAB20
//		Name   -> Function Pavlov.PavlovPawn.OnRep_PlayerProxy
//		Flags  -> (Native, Public)
void APavlovPawn::OnRep_PlayerProxy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_PlayerProxy");

	APavlovPawn_OnRep_PlayerProxy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAB00
//		Name   -> Function Pavlov.PavlovPawn.OnRep_LastTeleport
//		Flags  -> (Final, Native, Public)
void APavlovPawn::OnRep_LastTeleport()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_LastTeleport");

	APavlovPawn_OnRep_LastTeleport_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAAE0
//		Name   -> Function Pavlov.PavlovPawn.OnRep_HelmetArmour
//		Flags  -> (Final, Native, Private)
void APavlovPawn::OnRep_HelmetArmour()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_HelmetArmour");

	APavlovPawn_OnRep_HelmetArmour_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAAC0
//		Name   -> Function Pavlov.PavlovPawn.OnRep_AvatarSkinInfo
//		Flags  -> (Final, Native, Private)
void APavlovPawn::OnRep_AvatarSkinInfo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_AvatarSkinInfo");

	APavlovPawn_OnRep_AvatarSkinInfo_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AAAA0
//		Name   -> Function Pavlov.PavlovPawn.OnRep_Armour
//		Flags  -> (Final, Native, Private)
void APavlovPawn::OnRep_Armour()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnRep_Armour");

	APavlovPawn_OnRep_Armour_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x003F3740
//		Name   -> Function Pavlov.PavlovPawn.OnPawnRevived
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void APavlovPawn::OnPawnRevived()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnPawnRevived");

	APavlovPawn_OnPawnRevived_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA870
//		Name   -> Function Pavlov.PavlovPawn.OnKill
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class AActor*                                      OwnerActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::OnKill(class AActor* OwnerActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnKill");

	APavlovPawn_OnKill_Params params {};
	params.OwnerActor = OwnerActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.OnImpactDamage
//		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		struct FImpactDamage                               ImpactDamage                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::OnImpactDamage(const struct FImpactDamage& ImpactDamage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnImpactDamage");

	APavlovPawn_OnImpactDamage_Params params {};
	params.ImpactDamage = ImpactDamage;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.OnHitByTazer
//		Flags  -> (Event, Public, BlueprintEvent)
void APavlovPawn::OnHitByTazer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnHitByTazer");

	APavlovPawn_OnHitByTazer_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.OnHitByGun
//		Flags  -> (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		class UClass*                                      GunClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 HitInstigator                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::OnHitByGun(class UClass* GunClass, class AController* HitInstigator, const struct FVector& HitLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnHitByGun");

	APavlovPawn_OnHitByGun_Params params {};
	params.GunClass = GunClass;
	params.HitInstigator = HitInstigator;
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA750
//		Name   -> Function Pavlov.PavlovPawn.OnDismember
//		Flags  -> (Final, Native, Public, HasOutParms)
// Parameters:
//		struct FWoundInfo                                  WoundInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
//		struct FPreBakedWound                              PreBakedWound                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void APavlovPawn::OnDismember(const struct FWoundInfo& WoundInfo, const struct FPreBakedWound& PreBakedWound)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnDismember");

	APavlovPawn_OnDismember_Params params {};
	params.WoundInfo = WoundInfo;
	params.PreBakedWound = PreBakedWound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.OnCameraClipChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bClipping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::OnCameraClipChanged(bool bClipping)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.OnCameraClipChanged");

	APavlovPawn_OnCameraClipChanged_Params params {};
	params.bClipping = bClipping;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA730
//		Name   -> Function Pavlov.PavlovPawn.NotifyProxySkinChanged
//		Flags  -> (Final, Native, Public)
void APavlovPawn::NotifyProxySkinChanged()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.NotifyProxySkinChanged");

	APavlovPawn_NotifyProxySkinChanged_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA590
//		Name   -> Function Pavlov.PavlovPawn.MulticastTeleportTo
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
//		struct FVector                                     DestLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FRotator                                    DestRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastTeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastTeleportTo");

	APavlovPawn_MulticastTeleportTo_Params params {};
	params.DestLocation = DestLocation;
	params.DestRotation = DestRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA570
//		Name   -> Function Pavlov.PavlovPawn.MulticastResetPawn
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void APavlovPawn::MulticastResetPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastResetPawn");

	APavlovPawn_MulticastResetPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA550
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnZombieHit
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APavlovPawn::MulticastOnZombieHit()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnZombieHit");

	APavlovPawn_MulticastOnZombieHit_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA530
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnWearArmour
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APavlovPawn::MulticastOnWearArmour()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnWearArmour");

	APavlovPawn_MulticastOnWearArmour_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA4A0
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnRadialDeath
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FVector_NetQuantize                         Origin                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastOnRadialDeath(const struct FVector_NetQuantize& Origin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnRadialDeath");

	APavlovPawn_MulticastOnRadialDeath_Params params {};
	params.Origin = Origin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA410
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnMagazineGrabbed
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bDominant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastOnMagazineGrabbed(bool bDominant)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnMagazineGrabbed");

	APavlovPawn_MulticastOnMagazineGrabbed_Params params {};
	params.bDominant = bDominant;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA350
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnImpactDamage
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FImpactDamage                               ImpactDamage                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastOnImpactDamage(const struct FImpactDamage& ImpactDamage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnImpactDamage");

	APavlovPawn_MulticastOnImpactDamage_Params params {};
	params.ImpactDamage = ImpactDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA330
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnHitSlow
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void APavlovPawn::MulticastOnHitSlow()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnHitSlow");

	APavlovPawn_MulticastOnHitSlow_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA1A0
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnHit
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
//		struct FVector_NetQuantizeNormal                   Normal                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
//		class APlayerState*                                Shooter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bOnArmor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastOnHit(const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& Normal, class APlayerState* Shooter, bool bOnArmor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnHit");

	APavlovPawn_MulticastOnHit_Params params {};
	params.Location = Location;
	params.Normal = Normal;
	params.Shooter = Shooter;
	params.bOnArmor = bOnArmor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA0C0
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnHelmetHit
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
//		struct FVector_NetQuantizeNormal                   Direction                                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastOnHelmetHit(const struct FVector_NetQuantize& Location, const struct FVector_NetQuantizeNormal& Direction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnHelmetHit");

	APavlovPawn_MulticastOnHelmetHit_Params params {};
	params.Location = Location;
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AA0A0
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnHelmetBlownoff
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APavlovPawn::MulticastOnHelmetBlownoff()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnHelmetBlownoff");

	APavlovPawn_MulticastOnHelmetBlownoff_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9F20
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnHeadshot
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
//		class APlayerState*                                Killer                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitDirection                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      WoundRate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastOnHeadshot(class APlayerState* Killer, const struct FVector& HitLocation, const struct FVector& HitDirection, unsigned char WoundRate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnHeadshot");

	APavlovPawn_MulticastOnHeadshot_Params params {};
	params.Killer = Killer;
	params.HitLocation = HitLocation;
	params.HitDirection = HitDirection;
	params.WoundRate = WoundRate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9F00
//		Name   -> Function Pavlov.PavlovPawn.MulticastOnFallDamage
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APavlovPawn::MulticastOnFallDamage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastOnFallDamage");

	APavlovPawn_MulticastOnFallDamage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9E80
//		Name   -> Function Pavlov.PavlovPawn.MulticastAdjustAvatarScale
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		float                                              PlayerHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::MulticastAdjustAvatarScale(float PlayerHeight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.MulticastAdjustAvatarScale");

	APavlovPawn_MulticastAdjustAvatarScale_Params params {};
	params.PlayerHeight = PlayerHeight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9E30
//		Name   -> Function Pavlov.PavlovPawn.ModKitLeaveVehicle
//		Flags  -> (Final, Native, Public)
void APavlovPawn::ModKitLeaveVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ModKitLeaveVehicle");

	APavlovPawn_ModKitLeaveVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9E50
//		Name   -> Function Pavlov.PavlovPawn.ModkitIsInVehicle
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::ModkitIsInVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ModkitIsInVehicle");

	APavlovPawn_ModkitIsInVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9D60
//		Name   -> Function Pavlov.PavlovPawn.LoadEquipment
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FEquipmentDefinition                        definition                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void APavlovPawn::LoadEquipment(const struct FEquipmentDefinition& definition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.LoadEquipment");

	APavlovPawn_LoadEquipment_Params params {};
	params.definition = definition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9C60
//		Name   -> Function Pavlov.PavlovPawn.KillByDamageType
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      DamageType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 KilledByInstigator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      KilledBy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::KillByDamageType(class UClass* DamageType, class AController* KilledByInstigator, class AActor* KilledBy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.KillByDamageType");

	APavlovPawn_KillByDamageType_Params params {};
	params.DamageType = DamageType;
	params.KilledByInstigator = KilledByInstigator;
	params.KilledBy = KilledBy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9BA0
//		Name   -> Function Pavlov.PavlovPawn.IsSprinting
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsSprinting()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsSprinting");

	APavlovPawn_IsSprinting_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9AB0
//		Name   -> Function Pavlov.PavlovPawn.IsPickupDisabled
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsPickupDisabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsPickupDisabled");

	APavlovPawn_IsPickupDisabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A99C0
//		Name   -> Function Pavlov.PavlovPawn.IsLobbyLeaderModkit
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsLobbyLeaderModkit()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsLobbyLeaderModkit");

	APavlovPawn_IsLobbyLeaderModkit_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9990
//		Name   -> Function Pavlov.PavlovPawn.IsDead
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsDead()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsDead");

	APavlovPawn_IsDead_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9960
//		Name   -> Function Pavlov.PavlovPawn.IsCarryingBomb
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsCarryingBomb()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsCarryingBomb");

	APavlovPawn_IsCarryingBomb_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9940
//		Name   -> Function Pavlov.PavlovPawn.IsCameraClipping
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsCameraClipping()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsCameraClipping");

	APavlovPawn_IsCameraClipping_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A98B0
//		Name   -> Function Pavlov.PavlovPawn.IsArmExploiting
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::IsArmExploiting(bool bRight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.IsArmExploiting");

	APavlovPawn_IsArmExploiting_Params params {};
	params.bRight = bRight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A97E0
//		Name   -> Function Pavlov.PavlovPawn.HealEffect
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		float                                              HealTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UMaterialInterface*                          HealMaterial                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::HealEffect(float HealTime, class UMaterialInterface* HealMaterial)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.HealEffect");

	APavlovPawn_HealEffect_Params params {};
	params.HealTime = HealTime;
	params.HealMaterial = HealMaterial;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9750
//		Name   -> Function Pavlov.PavlovPawn.HasItem
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FName                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AActor* APavlovPawn::HasItem(const struct FName& Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.HasItem");

	APavlovPawn_HasItem_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9690
//		Name   -> Function Pavlov.PavlovPawn.GorePawn
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FImpactDamage                               Impact                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPawn::GorePawn(const struct FImpactDamage& Impact)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GorePawn");

	APavlovPawn_GorePawn_Params params {};
	params.Impact = Impact;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A95E0
//		Name   -> Function Pavlov.PavlovPawn.GiveItemInventory
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FGiveItemInventoryParams                    Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
//		class AVRItem*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AVRItem* APavlovPawn::GiveItemInventory(const struct FGiveItemInventoryParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GiveItemInventory");

	APavlovPawn_GiveItemInventory_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9530
//		Name   -> Function Pavlov.PavlovPawn.GiveItem
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FGiveItemParams                             Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
//		class AVRItem*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AVRItem* APavlovPawn::GiveItem(const struct FGiveItemParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GiveItem");

	APavlovPawn_GiveItem_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A94B0
//		Name   -> Function Pavlov.PavlovPawn.GiveBomb
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class ABomb*                                       Bomb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::GiveBomb(class ABomb* Bomb)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GiveBomb");

	APavlovPawn_GiveBomb_Params params {};
	params.Bomb = Bomb;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9360
//		Name   -> Function Pavlov.PavlovPawn.Give
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       Skin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bWithAmmo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bByBuyMenu                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::Give(const struct FName& EquipmentName, const struct FName& Skin, bool bWithAmmo, bool bByBuyMenu)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.Give");

	APavlovPawn_Give_Params params {};
	params.EquipmentName = EquipmentName;
	params.Skin = Skin;
	params.bWithAmmo = bWithAmmo;
	params.bByBuyMenu = bByBuyMenu;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A9280
//		Name   -> Function Pavlov.PavlovPawn.GetWeaponAttachments
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<struct FName>                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FName> APavlovPawn::GetWeaponAttachments(class AActor* Weapon)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetWeaponAttachments");

	APavlovPawn_GetWeaponAttachments_Params params {};
	params.Weapon = Weapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A91F0
//		Name   -> Function Pavlov.PavlovPawn.GetWeaponAmmoType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class AActor*                                      Weapon                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName APavlovPawn::GetWeaponAmmoType(class AActor* Weapon)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetWeaponAmmoType");

	APavlovPawn_GetWeaponAmmoType_Params params {};
	params.Weapon = Weapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A91C0
//		Name   -> Function Pavlov.PavlovPawn.GetWatch
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UWatch*                                      ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UWatch* APavlovPawn::GetWatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetWatch");

	APavlovPawn_GetWatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9190
//		Name   -> Function Pavlov.PavlovPawn.GetVehicleOccupant
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UVehicleOccupant*                            ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVehicleOccupant* APavlovPawn::GetVehicleOccupant()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetVehicleOccupant");

	APavlovPawn_GetVehicleOccupant_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A9160
//		Name   -> Function Pavlov.PavlovPawn.GetSkinSkeleton
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class USkeletalMeshComponent*                      ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USkeletalMeshComponent* APavlovPawn::GetSkinSkeleton()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetSkinSkeleton");

	APavlovPawn_GetSkinSkeleton_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetSideWeaponHolster
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UHolsterComponent*                           ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UHolsterComponent* APavlovPawn::GetSideWeaponHolster()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetSideWeaponHolster");

	APavlovPawn_GetSideWeaponHolster_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8FA0
//		Name   -> Function Pavlov.PavlovPawn.GetNumOfSyringeRevives
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Syringe                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovPawn::GetNumOfSyringeRevives(class AActor* Syringe)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetNumOfSyringeRevives");

	APavlovPawn_GetNumOfSyringeRevives_Params params {};
	params.Syringe = Syringe;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8F10
//		Name   -> Function Pavlov.PavlovPawn.GetNumOfPainkillerPills
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Painkillers                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovPawn::GetNumOfPainkillerPills(class AActor* Painkillers)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetNumOfPainkillerPills");

	APavlovPawn_GetNumOfPainkillerPills_Params params {};
	params.Painkillers = Painkillers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetMainWeaponHolster
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UHolsterComponent*                           ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UHolsterComponent* APavlovPawn::GetMainWeaponHolster()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetMainWeaponHolster");

	APavlovPawn_GetMainWeaponHolster_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8E20
//		Name   -> Function Pavlov.PavlovPawn.GetLimitedAmmoComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class ULimitedAmmoComponent*                       ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class ULimitedAmmoComponent* APavlovPawn::GetLimitedAmmoComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetLimitedAmmoComponent");

	APavlovPawn_GetLimitedAmmoComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetKnifeHolster
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UHolsterComponent*                           ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UHolsterComponent* APavlovPawn::GetKnifeHolster()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetKnifeHolster");

	APavlovPawn_GetKnifeHolster_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8D10
//		Name   -> Function Pavlov.PavlovPawn.GetItemOfClass
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      ItemClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bSkipHands                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bSubClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AVRItem*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AVRItem* APavlovPawn::GetItemOfClass(class UClass* ItemClass, bool bSkipHands, bool bSubClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetItemOfClass");

	APavlovPawn_GetItemOfClass_Params params {};
	params.ItemClass = ItemClass;
	params.bSkipHands = bSkipHands;
	params.bSubClass = bSubClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8CE0
//		Name   -> Function Pavlov.PavlovPawn.GetInventorySlotsVis
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::GetInventorySlotsVis()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetInventorySlotsVis");

	APavlovPawn_GetInventorySlotsVis_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8C50
//		Name   -> Function Pavlov.PavlovPawn.GetHoldingItemByName
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AVRItem*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AVRItem* APavlovPawn::GetHoldingItemByName(const struct FName& ItemName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetHoldingItemByName");

	APavlovPawn_GetHoldingItemByName_Params params {};
	params.ItemName = ItemName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8C20
//		Name   -> Function Pavlov.PavlovPawn.GetHealth
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float APavlovPawn::GetHealth()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetHealth");

	APavlovPawn_GetHealth_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8A90
//		Name   -> Function Pavlov.PavlovPawn.GetHeadSpaceHitVectors
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HeadSpaceHitLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HeadSpaceHitDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::GetHeadSpaceHitVectors(const struct FVector& HitLocation, const struct FVector& HitDirection, struct FVector* HeadSpaceHitLocation, struct FVector* HeadSpaceHitDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetHeadSpaceHitVectors");

	APavlovPawn_GetHeadSpaceHitVectors_Params params {};
	params.HitLocation = HitLocation;
	params.HitDirection = HitDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (HeadSpaceHitLocation != nullptr)
		*HeadSpaceHitLocation = params.HeadSpaceHitLocation;
	if (HeadSpaceHitDirection != nullptr)
		*HeadSpaceHitDirection = params.HeadSpaceHitDirection;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetGrenadeHolsters
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TArray<class UHolsterComponent*>                   ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
TArray<class UHolsterComponent*> APavlovPawn::GetGrenadeHolsters()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetGrenadeHolsters");

	APavlovPawn_GetGrenadeHolsters_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetEquipmentByName
//		Flags  -> (Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FEquipmentDefinition                        definition                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::GetEquipmentByName(const struct FName& EquipmentName, struct FEquipmentDefinition* definition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetEquipmentByName");

	APavlovPawn_GetEquipmentByName_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (definition != nullptr)
		*definition = params.definition;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8900
//		Name   -> Function Pavlov.PavlovPawn.GetCompatibleSlot
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FName                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
unsigned char APavlovPawn::GetCompatibleSlot(const struct FName& Item)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetCompatibleSlot");

	APavlovPawn_GetCompatibleSlot_Params params {};
	params.Item = Item;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetBombHolster
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UHolsterComponent*                           ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UHolsterComponent* APavlovPawn::GetBombHolster()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetBombHolster");

	APavlovPawn_GetBombHolster_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A88E0
//		Name   -> Function Pavlov.PavlovPawn.GetAvatarSkin
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UAvatarSkin*                                 ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAvatarSkin* APavlovPawn::GetAvatarSkin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetAvatarSkin");

	APavlovPawn_GetAvatarSkin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8850
//		Name   -> Function Pavlov.PavlovPawn.GetAmmoTypeName
//		Flags  -> (Final, Native, Public)
// Parameters:
//		VRFramework_EAmmoType                              AmmoType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName APavlovPawn::GetAmmoTypeName(VRFramework_EAmmoType AmmoType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetAmmoTypeName");

	APavlovPawn_GetAmmoTypeName_Params params {};
	params.AmmoType = AmmoType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovPawn.GetAmmoPocket
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class UVRPocketComponent*                          ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVRPocketComponent* APavlovPawn::GetAmmoPocket()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetAmmoPocket");

	APavlovPawn_GetAmmoPocket_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A87C0
//		Name   -> Function Pavlov.PavlovPawn.GetAmmoAmount
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       AmmoId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovPawn::GetAmmoAmount(const struct FName& AmmoId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.GetAmmoAmount");

	APavlovPawn_GetAmmoAmount_Params params {};
	params.AmmoId = AmmoId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A8750
//		Name   -> Function Pavlov.PavlovPawn.FinishExitVehicleServer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPawn::FinishExitVehicleServer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.FinishExitVehicleServer");

	APavlovPawn_FinishExitVehicleServer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8730
//		Name   -> Function Pavlov.PavlovPawn.FinishExitVehicleClient
//		Flags  -> (Final, Native, Public)
void APavlovPawn::FinishExitVehicleClient()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.FinishExitVehicleClient");

	APavlovPawn_FinishExitVehicleClient_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8680
//		Name   -> Function Pavlov.PavlovPawn.ExitVehicle
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
//		struct FVector                                     ExitLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::ExitVehicle(const struct FVector& ExitLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ExitVehicle");

	APavlovPawn_ExitVehicle_Params params {};
	params.ExitLocation = ExitLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8660
//		Name   -> Function Pavlov.PavlovPawn.EnableVehicleCollisionRecenter
//		Flags  -> (Final, Native, Public)
void APavlovPawn::EnableVehicleCollisionRecenter()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.EnableVehicleCollisionRecenter");

	APavlovPawn_EnableVehicleCollisionRecenter_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8640
//		Name   -> Function Pavlov.PavlovPawn.EnableVehicleCollision
//		Flags  -> (Final, Native, Public)
void APavlovPawn::EnableVehicleCollision()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.EnableVehicleCollision");

	APavlovPawn_EnableVehicleCollision_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8520
//		Name   -> Function Pavlov.PavlovPawn.EnableItemUse
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnableUse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::EnableItemUse(bool bEnableUse)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.EnableItemUse");

	APavlovPawn_EnableItemUse_Params params {};
	params.bEnableUse = bEnableUse;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8410
//		Name   -> Function Pavlov.PavlovPawn.DropItem
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FName                                       Item                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bDestroy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromHandsOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::DropItem(const struct FName& Item, bool bDestroy, bool bFromHandsOnly)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.DropItem");

	APavlovPawn_DropItem_Params params {};
	params.Item = Item;
	params.bDestroy = bDestroy;
	params.bFromHandsOnly = bFromHandsOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A82F0
//		Name   -> Function Pavlov.PavlovPawn.DropHeldItems
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bDominant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bBoth                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bDestroyItem                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::DropHeldItems(bool bDominant, bool bBoth, bool bDestroyItem)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.DropHeldItems");

	APavlovPawn_DropHeldItems_Params params {};
	params.bDominant = bDominant;
	params.bBoth = bBoth;
	params.bDestroyItem = bDestroyItem;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A82D0
//		Name   -> Function Pavlov.PavlovPawn.DropEquipment
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPawn::DropEquipment()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.DropEquipment");

	APavlovPawn_DropEquipment_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8200
//		Name   -> Function Pavlov.PavlovPawn.DropAllItems
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bDestroyItems                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bInventoryOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::DropAllItems(bool bDestroyItems, bool bInventoryOnly)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.DropAllItems");

	APavlovPawn_DropAllItems_Params params {};
	params.bDestroyItems = bDestroyItems;
	params.bInventoryOnly = bInventoryOnly;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A80E0
//		Name   -> Function Pavlov.PavlovPawn.DisablePickup
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bDisabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::DisablePickup(bool bDisabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.DisablePickup");

	APavlovPawn_DisablePickup_Params params {};
	params.bDisabled = bDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E100
//		Name   -> Function Pavlov.PavlovPawn.ClientSanityCheck
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APavlovPawn::ClientSanityCheck()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ClientSanityCheck");

	APavlovPawn_ClientSanityCheck_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A80C0
//		Name   -> Function Pavlov.PavlovPawn.ClientOnExplosionDamage
//		Flags  -> (Net, Native, Event, Public, NetClient)
void APavlovPawn::ClientOnExplosionDamage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ClientOnExplosionDamage");

	APavlovPawn_ClientOnExplosionDamage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A8010
//		Name   -> Function Pavlov.PavlovPawn.CanRevive
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::CanRevive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.CanRevive");

	APavlovPawn_CanRevive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A7FE0
//		Name   -> Function Pavlov.PavlovPawn.CanListenToRadio
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPawn::CanListenToRadio()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.CanListenToRadio");

	APavlovPawn_CanListenToRadio_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006A7FC0
//		Name   -> Function Pavlov.PavlovPawn.BlowHelmetOff
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void APavlovPawn::BlowHelmetOff()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.BlowHelmetOff");

	APavlovPawn_BlowHelmetOff_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A7FA0
//		Name   -> Function Pavlov.PavlovPawn.ApplyDelayedWound
//		Flags  -> (Final, Native, Private)
void APavlovPawn::ApplyDelayedWound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ApplyDelayedWound");

	APavlovPawn_ApplyDelayedWound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A7F80
//		Name   -> Function Pavlov.PavlovPawn.AddWatch
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APavlovPawn::AddWatch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.AddWatch");

	APavlovPawn_AddWatch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A7F60
//		Name   -> Function Pavlov.PavlovPawn.AddHitSlow
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPawn::AddHitSlow()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.AddHitSlow");

	APavlovPawn_AddHitSlow_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006A7EA0
//		Name   -> Function Pavlov.PavlovPawn.AddAmmo
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       AmmoId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Amount                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPawn::AddAmmo(const struct FName& AmmoId, int Amount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.AddAmmo");

	APavlovPawn_AddAmmo_Params params {};
	params.AmmoId = AmmoId;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovPawn.ActivateCameraClip
//		Flags  -> (Final, Native, Private)
void APavlovPawn::ActivateCameraClip()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPawn.ActivateCameraClip");

	APavlovPawn_ActivateCameraClip_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2AA0
//		Name   -> Function Pavlov.PavlovPlayerController.UnBoardVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerController::UnBoardVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.UnBoardVehicle");

	APavlovPlayerController_UnBoardVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2A80
//		Name   -> Function Pavlov.PavlovPlayerController.TryRestoreEquipmentBySnapshot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerController::TryRestoreEquipmentBySnapshot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.TryRestoreEquipmentBySnapshot");

	APavlovPlayerController_TryRestoreEquipmentBySnapshot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2A60
//		Name   -> Function Pavlov.PavlovPlayerController.TestTeamKill
//		Flags  -> (Final, Exec, Native, Public)
void APavlovPlayerController::TestTeamKill()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.TestTeamKill");

	APavlovPlayerController_TestTeamKill_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2A40
//		Name   -> Function Pavlov.PavlovPlayerController.TakeEquipmentSnapshot
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerController::TakeEquipmentSnapshot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.TakeEquipmentSnapshot");

	APavlovPlayerController_TakeEquipmentSnapshot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2A20
//		Name   -> Function Pavlov.PavlovPlayerController.SwitchToSpectator
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerController::SwitchToSpectator()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SwitchToSpectator");

	APavlovPlayerController_SwitchToSpectator_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2A00
//		Name   -> Function Pavlov.PavlovPlayerController.SwitchTeam
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
void APavlovPlayerController::SwitchTeam()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SwitchTeam");

	APavlovPlayerController_SwitchTeam_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B29E0
//		Name   -> Function Pavlov.PavlovPlayerController.SwapControllers
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
void APavlovPlayerController::SwapControllers()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SwapControllers");

	APavlovPlayerController_SwapControllers_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B29C0
//		Name   -> Function Pavlov.PavlovPlayerController.Suicide
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
void APavlovPlayerController::Suicide()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.Suicide");

	APavlovPlayerController_Suicide_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0CF0
//		Name   -> Function Pavlov.PavlovPlayerController.SNDPreGameSpawnTimer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerController::SNDPreGameSpawnTimer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SNDPreGameSpawnTimer");

	APavlovPlayerController_SNDPreGameSpawnTimer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2530
//		Name   -> Function Pavlov.PavlovPlayerController.SetServerTickRate
//		Flags  -> (Final, Exec, Native, Public)
// Parameters:
//		int                                                Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::SetServerTickRate(int Rate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SetServerTickRate");

	APavlovPlayerController_SetServerTickRate_Params params {};
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B24B0
//		Name   -> Function Pavlov.PavlovPlayerController.SetHeadMountedDisplayScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::SetHeadMountedDisplayScale(float Scale)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SetHeadMountedDisplayScale");

	APavlovPlayerController_SetHeadMountedDisplayScale_Params params {};
	params.Scale = Scale;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B23F0
//		Name   -> Function Pavlov.PavlovPlayerController.SetBuyingEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ForDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              BuyZoneMaxDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::SetBuyingEnabled(float ForDuration, float BuyZoneMaxDistance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SetBuyingEnabled");

	APavlovPlayerController_SetBuyingEnabled_Params params {};
	params.ForDuration = ForDuration;
	params.BuyZoneMaxDistance = BuyZoneMaxDistance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B23D0
//		Name   -> Function Pavlov.PavlovPlayerController.SetBuyingDisabled
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void APavlovPlayerController::SetBuyingDisabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SetBuyingDisabled");

	APavlovPlayerController_SetBuyingDisabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2340
//		Name   -> Function Pavlov.PavlovPlayerController.SetBlackScreen
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::SetBlackScreen(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.SetBlackScreen");

	APavlovPlayerController_SetBlackScreen_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2240
//		Name   -> Function Pavlov.PavlovPlayerController.ServerVote
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
//		class AVote*                                       Vote                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bYes                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerVote(class AVote* Vote, bool bYes)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerVote");

	APavlovPlayerController_ServerVote_Params params {};
	params.Vote = Vote;
	params.bYes = bYes;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B20A0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerUnBoardVehicle
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPlayerController::ServerUnBoardVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerUnBoardVehicle");

	APavlovPlayerController_ServerUnBoardVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2050
//		Name   -> Function Pavlov.PavlovPlayerController.ServerTestTeamKill
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPlayerController::ServerTestTeamKill()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerTestTeamKill");

	APavlovPlayerController_ServerTestTeamKill_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2000
//		Name   -> Function Pavlov.PavlovPlayerController.ServerSwitchTeam
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPlayerController::ServerSwitchTeam()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerSwitchTeam");

	APavlovPlayerController_ServerSwitchTeam_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1FB0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerSuicide
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPlayerController::ServerSuicide()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerSuicide");

	APavlovPlayerController_ServerSuicide_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1EF0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerSetServerTickRate
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		int                                                Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerSetServerTickRate(int Rate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerSetServerTickRate");

	APavlovPlayerController_ServerSetServerTickRate_Params params {};
	params.Rate = Rate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1E20
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportZombieBulletHit
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FClientZombieBulletHit                      Hit                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportZombieBulletHit(const struct FClientZombieBulletHit& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportZombieBulletHit");

	APavlovPlayerController_ServerReportZombieBulletHit_Params params {};
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1D60
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportVirtualStockChange
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportVirtualStockChange(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportVirtualStockChange");

	APavlovPlayerController_ServerReportVirtualStockChange_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1C10
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportTrigger
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class AGun*                                        Gun                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bTrigger                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<unsigned char>                              GunState                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportTrigger(class AGun* Gun, bool bTrigger, TArray<unsigned char> GunState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportTrigger");

	APavlovPlayerController_ServerReportTrigger_Params params {};
	params.Gun = Gun;
	params.bTrigger = bTrigger;
	params.GunState = GunState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1AA0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportShatter
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class ADestructible*                               Destructible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector_NetQuantizeNormal                   Normal                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
//		struct FVector_NetQuantize                         Location                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportShatter(class ADestructible* Destructible, const struct FVector_NetQuantizeNormal& Normal, const struct FVector_NetQuantize& Location)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportShatter");

	APavlovPlayerController_ServerReportShatter_Params params {};
	params.Destructible = Destructible;
	params.Normal = Normal;
	params.Location = Location;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1930
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportKnifeDamage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FClientKnifeDamage                          Info                                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportKnifeDamage(const struct FClientKnifeDamage& Info)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportKnifeDamage");

	APavlovPlayerController_ServerReportKnifeDamage_Params params {};
	params.Info = Info;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1870
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportHandenessChange
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		bool                                               bRightHanded                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportHandenessChange(bool bRightHanded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportHandenessChange");

	APavlovPlayerController_ServerReportHandenessChange_Params params {};
	params.bRightHanded = bRightHanded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1770
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportCorpseHitByClass
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class APavlovPawn*                                 PawnCorpse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      GunClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportCorpseHitByClass(class APavlovPawn* PawnCorpse, class UClass* GunClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportCorpseHitByClass");

	APavlovPlayerController_ServerReportCorpseHitByClass_Params params {};
	params.PawnCorpse = PawnCorpse;
	params.GunClass = GunClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1670
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportCorpseHit
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class APavlovPawn*                                 PawnCorpse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FImpactDamage                               ImpactDamage                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportCorpseHit(class APavlovPawn* PawnCorpse, const struct FImpactDamage& ImpactDamage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportCorpseHit");

	APavlovPlayerController_ServerReportCorpseHit_Params params {};
	params.PawnCorpse = PawnCorpse;
	params.ImpactDamage = ImpactDamage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1560
//		Name   -> Function Pavlov.PavlovPlayerController.ServerReportBulletHit
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FClientBulletHit                            Hit                                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerReportBulletHit(const struct FClientBulletHit& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerReportBulletHit");

	APavlovPlayerController_ServerReportBulletHit_Params params {};
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1510
//		Name   -> Function Pavlov.PavlovPlayerController.ServerProcessZombieDamage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void APavlovPlayerController::ServerProcessZombieDamage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerProcessZombieDamage");

	APavlovPlayerController_ServerProcessZombieDamage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B13E0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerKnockZombie
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class AZAICharacter*                               Zombie                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Z_EZKnockBackDirection                             Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerKnockZombie(class AZAICharacter* Zombie, Z_EZKnockBackDirection Direction, unsigned char Flags)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerKnockZombie");

	APavlovPlayerController_ServerKnockZombie_Params params {};
	params.Zombie = Zombie;
	params.Direction = Direction;
	params.Flags = Flags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1290
//		Name   -> Function Pavlov.PavlovPlayerController.ServerInstigateVote
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
//		class UClass*                                      VoteClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Param1                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Param2                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerInstigateVote(class UClass* VoteClass, const struct FString& Param1, int Param2)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerInstigateVote");

	APavlovPlayerController_ServerInstigateVote_Params params {};
	params.VoteClass = VoteClass;
	params.Param1 = Param1;
	params.Param2 = Param2;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1190
//		Name   -> Function Pavlov.PavlovPlayerController.ServerEnterVehicle
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class APavlovVehicle*                              Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerEnterVehicle(class APavlovVehicle* Vehicle, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerEnterVehicle");

	APavlovPlayerController_ServerEnterVehicle_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1090
//		Name   -> Function Pavlov.PavlovPlayerController.ServerEnterDigit
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class ABomb*                                       Bomb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerEnterDigit(class ABomb* Bomb, int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerEnterDigit");

	APavlovPlayerController_ServerEnterDigit_Params params {};
	params.Bomb = Bomb;
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0FB0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerBuy
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerBuy(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerBuy");

	APavlovPlayerController_ServerBuy_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0EB0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerBoardVehicle
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class APavlovWheeledVehicle*                       Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerBoardVehicle(class APavlovWheeledVehicle* Vehicle, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerBoardVehicle");

	APavlovPlayerController_ServerBoardVehicle_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0DF0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerAuthenticate
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
//		struct FString                                     HexTicket                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ServerAuthenticate(const struct FString& HexTicket)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerAuthenticate");

	APavlovPlayerController_ServerAuthenticate_Params params {};
	params.HexTicket = HexTicket;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0DA0
//		Name   -> Function Pavlov.PavlovPlayerController.ServerAbstainToVote
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
void APavlovPlayerController::ServerAbstainToVote()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ServerAbstainToVote");

	APavlovPlayerController_ServerAbstainToVote_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0CD0
//		Name   -> Function Pavlov.PavlovPlayerController.ResetPlayerHeight
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void APavlovPlayerController::ResetPlayerHeight()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ResetPlayerHeight");

	APavlovPlayerController_ResetPlayerHeight_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0CB0
//		Name   -> Function Pavlov.PavlovPlayerController.ResetPlayerEffects
//		Flags  -> (Final, Native, Public)
void APavlovPlayerController::ResetPlayerEffects()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ResetPlayerEffects");

	APavlovPlayerController_ResetPlayerEffects_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0BA0
//		Name   -> Function Pavlov.PavlovPlayerController.PunishTeamKiller
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
void APavlovPlayerController::PunishTeamKiller()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.PunishTeamKiller");

	APavlovPlayerController_PunishTeamKiller_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0AA0
//		Name   -> Function Pavlov.PavlovPlayerController.OnZombieClientKnock
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AZAICharacter*                               Zombie                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Z_EZKnockBackDirection                             Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		unsigned char                                      Flags                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::OnZombieClientKnock(class AZAICharacter* Zombie, Z_EZKnockBackDirection Direction, unsigned char Flags)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.OnZombieClientKnock");

	APavlovPlayerController_OnZombieClientKnock_Params params {};
	params.Zombie = Zombie;
	params.Direction = Direction;
	params.Flags = Flags;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B09B0
//		Name   -> Function Pavlov.PavlovPlayerController.OnMenuUniverseChanged
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::OnMenuUniverseChanged(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.OnMenuUniverseChanged");

	APavlovPlayerController_OnMenuUniverseChanged_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0990
//		Name   -> Function Pavlov.PavlovPlayerController.OnAuthTimedout
//		Flags  -> (Final, Native, Protected)
void APavlovPlayerController::OnAuthTimedout()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.OnAuthTimedout");

	APavlovPlayerController_OnAuthTimedout_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0860
//		Name   -> Function Pavlov.PavlovPlayerController.OnAuthTicketReceived
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     HexAuthTicket                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::OnAuthTicketReceived(bool bSucceed, const struct FString& HexAuthTicket)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.OnAuthTicketReceived");

	APavlovPlayerController_OnAuthTicketReceived_Params params {};
	params.bSucceed = bSucceed;
	params.HexAuthTicket = HexAuthTicket;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0770
//		Name   -> Function Pavlov.PavlovPlayerController.MulticastDebugPoint
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Text                                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::MulticastDebugPoint(const struct FVector& Location, const struct FString& Text)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.MulticastDebugPoint");

	APavlovPlayerController_MulticastDebugPoint_Params params {};
	params.Location = Location;
	params.Text = Text;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0750
//		Name   -> Function Pavlov.PavlovPlayerController.LeaveVehicle
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
void APavlovPlayerController::LeaveVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.LeaveVehicle");

	APavlovPlayerController_LeaveVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B06C0
//		Name   -> Function Pavlov.PavlovPlayerController.KilledInVehicle
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class APavlovVehicle*                              Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::KilledInVehicle(class APavlovVehicle* Vehicle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.KilledInVehicle");

	APavlovPlayerController_KilledInVehicle_Params params {};
	params.Vehicle = Vehicle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0690
//		Name   -> Function Pavlov.PavlovPlayerController.IsInVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPlayerController::IsInVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.IsInVehicle");

	APavlovPlayerController_IsInVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0380
//		Name   -> Function Pavlov.PavlovPlayerController.GetHeadMountedDisplayScale
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float APavlovPlayerController::GetHeadMountedDisplayScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.GetHeadMountedDisplayScale");

	APavlovPlayerController_GetHeadMountedDisplayScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0300
//		Name   -> Function Pavlov.PavlovPlayerController.ForgiveTeamKiller
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
void APavlovPlayerController::ForgiveTeamKiller()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ForgiveTeamKiller");

	APavlovPlayerController_ForgiveTeamKiller_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B01E0
//		Name   -> Function Pavlov.PavlovPlayerController.ExecuteRconCommand
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
//		struct FRconCommand                                RconCommand                                                (Parm, NativeAccessSpecifierPublic)
void APavlovPlayerController::ExecuteRconCommand(const struct FRconCommand& RconCommand)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ExecuteRconCommand");

	APavlovPlayerController_ExecuteRconCommand_Params params {};
	params.RconCommand = RconCommand;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0120
//		Name   -> Function Pavlov.PavlovPlayerController.EnterVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovVehicle*                              Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::EnterVehicle(class APavlovVehicle* Vehicle, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.EnterVehicle");

	APavlovPlayerController_EnterVehicle_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0070
//		Name   -> Function Pavlov.PavlovPlayerController.ClientSetBuying
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientSetBuying(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientSetBuying");

	APavlovPlayerController_ClientSetBuying_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFFA0
//		Name   -> Function Pavlov.PavlovPlayerController.ClientServerConnect
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FServerConnectParams                        Params                                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientServerConnect(const struct FServerConnectParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientServerConnect");

	APavlovPlayerController_ClientServerConnect_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFF80
//		Name   -> Function Pavlov.PavlovPlayerController.ClientReportMatchEnd
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
void APavlovPlayerController::ClientReportMatchEnd()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientReportMatchEnd");

	APavlovPlayerController_ClientReportMatchEnd_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFF60
//		Name   -> Function Pavlov.PavlovPlayerController.ClientPlayKillPing
//		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
void APavlovPlayerController::ClientPlayKillPing()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientPlayKillPing");

	APavlovPlayerController_ClientPlayKillPing_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFED0
//		Name   -> Function Pavlov.PavlovPlayerController.ClientOnTeamKilled
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class APavlovPlayerState*                          CulpritTeamKiller                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientOnTeamKilled(class APavlovPlayerState* CulpritTeamKiller)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientOnTeamKilled");

	APavlovPlayerController_ClientOnTeamKilled_Params params {};
	params.CulpritTeamKiller = CulpritTeamKiller;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFE00
//		Name   -> Function Pavlov.PavlovPlayerController.ClientInstigateFlashVision
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ViewAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientInstigateFlashVision(float Seconds, float ViewAlpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientInstigateFlashVision");

	APavlovPlayerController_ClientInstigateFlashVision_Params params {};
	params.Seconds = Seconds;
	params.ViewAlpha = ViewAlpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFD30
//		Name   -> Function Pavlov.PavlovPlayerController.ClientInstigateFlash
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
//		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ViewAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientInstigateFlash(float Seconds, float ViewAlpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientInstigateFlash");

	APavlovPlayerController_ClientInstigateFlash_Params params {};
	params.Seconds = Seconds;
	params.ViewAlpha = ViewAlpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFC90
//		Name   -> Function Pavlov.PavlovPlayerController.ClientDisplayMessage
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FString                                     Message                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientDisplayMessage(const struct FString& Message)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientDisplayMessage");

	APavlovPlayerController_ClientDisplayMessage_Params params {};
	params.Message = Message;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFBF0
//		Name   -> Function Pavlov.PavlovPlayerController.ClientConnectTo
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FString                                     ConnectURL                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::ClientConnectTo(const struct FString& ConnectURL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientConnectTo");

	APavlovPlayerController_ClientConnectTo_Params params {};
	params.ConnectURL = ConnectURL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFBD0
//		Name   -> Function Pavlov.PavlovPlayerController.ClientAuthenticate
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
void APavlovPlayerController::ClientAuthenticate()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ClientAuthenticate");

	APavlovPlayerController_ClientAuthenticate_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFB50
//		Name   -> Function Pavlov.PavlovPlayerController.Buy
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::Buy(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.Buy");

	APavlovPlayerController_Buy_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFA90
//		Name   -> Function Pavlov.PavlovPlayerController.BoardVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovWheeledVehicle*                       Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerController::BoardVehicle(class APavlovWheeledVehicle* Vehicle, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.BoardVehicle");

	APavlovPlayerController_BoardVehicle_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AFA70
//		Name   -> Function Pavlov.PavlovPlayerController.ApplySkippedHeadMountedDisplayScale
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerController::ApplySkippedHeadMountedDisplayScale()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerController.ApplySkippedHeadMountedDisplayScale");

	APavlovPlayerController_ApplySkippedHeadMountedDisplayScale_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0D10
//		Name   -> Function Pavlov.PavlovPlayerState.SendJoinDataToClient
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UJsonUtilsObj*                               JsonObj                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPlayerState::SendJoinDataToClient(class UJsonUtilsObj* JsonObj)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.SendJoinDataToClient");

	APavlovPlayerState_SendJoinDataToClient_Params params {};
	params.JsonObj = JsonObj;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0C90
//		Name   -> Function Pavlov.PavlovPlayerState.Reset
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerState::Reset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.Reset");

	APavlovPlayerState_Reset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0BF0
//		Name   -> Function Pavlov.PavlovPlayerState.ReceiveJoinJsonData
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		TArray<unsigned char>                              JoinData                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
void APavlovPlayerState::ReceiveJoinJsonData(TArray<unsigned char> JoinData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.ReceiveJoinJsonData");

	APavlovPlayerState_ReceiveJoinJsonData_Params params {};
	params.JoinData = JoinData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0A80
//		Name   -> Function Pavlov.PavlovPlayerState.OnRep_HasPlayerProxy
//		Flags  -> (Native, Public)
void APavlovPlayerState::OnRep_HasPlayerProxy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.OnRep_HasPlayerProxy");

	APavlovPlayerState_OnRep_HasPlayerProxy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0A60
//		Name   -> Function Pavlov.PavlovPlayerState.OnRep_Flair
//		Flags  -> (Native, Public)
void APavlovPlayerState::OnRep_Flair()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.OnRep_Flair");

	APavlovPlayerState_OnRep_Flair_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0A40
//		Name   -> Function Pavlov.PavlovPlayerState.OnRep_Cash
//		Flags  -> (Native, Public)
void APavlovPlayerState::OnRep_Cash()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.OnRep_Cash");

	APavlovPlayerState_OnRep_Cash_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00218BE0
//		Name   -> Function Pavlov.PavlovPlayerState.LoadEquippedSkins
//		Flags  -> (Final, Native, Public)
void APavlovPlayerState::LoadEquippedSkins()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.LoadEquippedSkins");

	APavlovPlayerState_LoadEquippedSkins_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B0600
//		Name   -> Function Pavlov.PavlovPlayerState.IsAbleToBuy
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       EquipmentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPlayerState::IsAbleToBuy(const struct FName& EquipmentName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.IsAbleToBuy");

	APavlovPlayerState_IsAbleToBuy_Params params {};
	params.EquipmentName = EquipmentName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B05D0
//		Name   -> Function Pavlov.PavlovPlayerState.HasSkinOverride
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPlayerState::HasSkinOverride()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.HasSkinOverride");

	APavlovPlayerState_HasSkinOverride_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0540
//		Name   -> Function Pavlov.PavlovPlayerState.HasSkinEquipped
//		Flags  -> (Final, Native, Public, Const)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovPlayerState::HasSkinEquipped(const struct FName& ItemName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.HasSkinEquipped");

	APavlovPlayerState_HasSkinEquipped_Params params {};
	params.ItemName = ItemName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0510
//		Name   -> Function Pavlov.PavlovPlayerState.GetVRDevice
//		Flags  -> (Final, Native, Public)
// Parameters:
//		PavlovProxy_EVRDevice                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
PavlovProxy_EVRDevice APavlovPlayerState::GetVRDevice()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.GetVRDevice");

	APavlovPlayerState_GetVRDevice_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B04E0
//		Name   -> Function Pavlov.PavlovPlayerState.GetTeamId
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovPlayerState::GetTeamId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.GetTeamId");

	APavlovPlayerState_GetTeamId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0460
//		Name   -> Function Pavlov.PavlovPlayerState.GetStringId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString APavlovPlayerState::GetStringId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.GetStringId");

	APavlovPlayerState_GetStringId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B03D0
//		Name   -> Function Pavlov.PavlovPlayerState.GetSkinId
//		Flags  -> (Final, Native, Public, Const)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovPlayerState::GetSkinId(const struct FName& ItemName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.GetSkinId");

	APavlovPlayerState_GetSkinId_Params params {};
	params.ItemName = ItemName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B0100
//		Name   -> Function Pavlov.PavlovPlayerState.DisableFallSound
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovPlayerState::DisableFallSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.DisableFallSound");

	APavlovPlayerState_DisableFallSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AF9B0
//		Name   -> Function Pavlov.PavlovPlayerState.AddEquippedSkinByFamily
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_ESkinFamily                                 SkinFamily                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerState::AddEquippedSkinByFamily(const struct FName& ItemName, Pavlov_ESkinFamily SkinFamily)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.AddEquippedSkinByFamily");

	APavlovPlayerState_AddEquippedSkinByFamily_Params params {};
	params.ItemName = ItemName;
	params.SkinFamily = SkinFamily;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006AF8F0
//		Name   -> Function Pavlov.PavlovPlayerState.AddEquippedSkin
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                SkinId                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovPlayerState::AddEquippedSkin(const struct FName& ItemName, int SkinId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovPlayerState.AddEquippedSkin");

	APavlovPlayerState_AddEquippedSkin_Params params {};
	params.ItemName = ItemName;
	params.SkinId = SkinId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2AC0
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.UpdateWheels
//		Flags  -> (Native, Protected, HasOutParms)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FReplicatedWheelState                       WheelUpdate                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::UpdateWheels(bool bRight, const struct FReplicatedWheelState& WheelUpdate)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.UpdateWheels");

	UPavlovSimpleVehicleMovement_UpdateWheels_Params params {};
	params.bRight = bRight;
	params.WheelUpdate = WheelUpdate;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B28F0
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.SetWheelInfo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FReplicatedWheelState                       WheelsState                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::SetWheelInfo(bool bRight, const struct FReplicatedWheelState& WheelsState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.SetWheelInfo");

	UPavlovSimpleVehicleMovement_SetWheelInfo_Params params {};
	params.bRight = bRight;
	params.WheelsState = WheelsState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2820
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.SetWheelDriveTorque
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              DriveTorque                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::SetWheelDriveTorque(bool bRight, float DriveTorque)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.SetWheelDriveTorque");

	UPavlovSimpleVehicleMovement_SetWheelDriveTorque_Params params {};
	params.bRight = bRight;
	params.DriveTorque = DriveTorque;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2720
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.SetWheelDriveAndBrakeTorque
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              DriveTorque                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              BrakeTorque                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::SetWheelDriveAndBrakeTorque(bool bRight, float DriveTorque, float BrakeTorque)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.SetWheelDriveAndBrakeTorque");

	UPavlovSimpleVehicleMovement_SetWheelDriveAndBrakeTorque_Params params {};
	params.bRight = bRight;
	params.DriveTorque = DriveTorque;
	params.BrakeTorque = BrakeTorque;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B2650
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.SetWheelBrakingTorque
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              BrakeTorque                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::SetWheelBrakingTorque(bool bRight, float BrakeTorque)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.SetWheelBrakingTorque");

	UPavlovSimpleVehicleMovement_SetWheelBrakingTorque_Params params {};
	params.bRight = bRight;
	params.BrakeTorque = BrakeTorque;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B25D0
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.SetTurnTorque
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              TurningTorque                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::SetTurnTorque(float TurningTorque)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.SetTurnTorque");

	UPavlovSimpleVehicleMovement_SetTurnTorque_Params params {};
	params.TurningTorque = TurningTorque;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B20F0
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.ServerUpdateWheels
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
//		struct FReplicatedWheelState                       LeftWheelInput                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
//		struct FReplicatedWheelState                       RightWheelInput                                            (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
//		float                                              TurnTorque                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovSimpleVehicleMovement::ServerUpdateWheels(const struct FReplicatedWheelState& LeftWheelInput, const struct FReplicatedWheelState& RightWheelInput, float TurnTorque)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.ServerUpdateWheels");

	UPavlovSimpleVehicleMovement_ServerUpdateWheels_Params params {};
	params.LeftWheelInput = LeftWheelInput;
	params.RightWheelInput = RightWheelInput;
	params.TurnTorque = TurnTorque;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B1070
//		Name   -> Function Pavlov.PavlovSimpleVehicleMovement.ServerEBrake
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public)
void UPavlovSimpleVehicleMovement::ServerEBrake()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSimpleVehicleMovement.ServerEBrake");

	UPavlovSimpleVehicleMovement_ServerEBrake_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7A60
//		Name   -> Function Pavlov.PavlovSpectatorPawn.ScrubToLive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void APavlovSpectatorPawn::ScrubToLive()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.ScrubToLive");

	APavlovSpectatorPawn_ScrubToLive_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B79E0
//		Name   -> Function Pavlov.PavlovSpectatorPawn.ScrubRelative
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovSpectatorPawn::ScrubRelative(float Seconds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.ScrubRelative");

	APavlovSpectatorPawn_ScrubRelative_Params params {};
	params.Seconds = Seconds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7960
//		Name   -> Function Pavlov.PavlovSpectatorPawn.ScrubNormalized
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              NormalizedTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovSpectatorPawn::ScrubNormalized(float NormalizedTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.ScrubNormalized");

	APavlovSpectatorPawn_ScrubNormalized_Params params {};
	params.NormalizedTime = NormalizedTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B78E0
//		Name   -> Function Pavlov.PavlovSpectatorPawn.Scrub
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovSpectatorPawn::Scrub(float Time)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.Scrub");

	APavlovSpectatorPawn_Scrub_Params params {};
	params.Time = Time;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovSpectatorPawn.OnScrubChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bScrubing                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovSpectatorPawn::OnScrubChanged(bool bScrubing)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.OnScrubChanged");

	APavlovSpectatorPawn_OnScrubChanged_Params params {};
	params.bScrubing = bScrubing;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002B3D20
//		Name   -> Function Pavlov.PavlovSpectatorPawn.OnGotoTime
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               bWasSuccessful                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovSpectatorPawn::OnGotoTime(bool bWasSuccessful)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.OnGotoTime");

	APavlovSpectatorPawn_OnGotoTime_Params params {};
	params.bWasSuccessful = bWasSuccessful;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovSpectatorPawn.OnDemoPlaybackError
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TEnumAsByte<Engine_EDemoPlayFailure>               FailureType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ErrorString                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovSpectatorPawn::OnDemoPlaybackError(TEnumAsByte<Engine_EDemoPlayFailure> FailureType, const struct FString& ErrorString)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.OnDemoPlaybackError");

	APavlovSpectatorPawn_OnDemoPlaybackError_Params params {};
	params.FailureType = FailureType;
	params.ErrorString = ErrorString;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B5A60
//		Name   -> Function Pavlov.PavlovSpectatorPawn.GetNormalizedScrubTime
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float APavlovSpectatorPawn::GetNormalizedScrubTime()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovSpectatorPawn.GetNormalizedScrubTime");

	APavlovSpectatorPawn_GetNormalizedScrubTime_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B80B0
//		Name   -> Function Pavlov.PavlovStatics.SwapHands
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SwapHands(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SwapHands");

	UPavlovStatics_SwapHands_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B8080
//		Name   -> Function Pavlov.PavlovStatics.SupportsGripForce
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_SupportsGripForce()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SupportsGripForce");

	UPavlovStatics_SupportsGripForce_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B7FB0
//		Name   -> Function Pavlov.PavlovStatics.SpawnLocalSound2DByPawn
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SpawnLocalSound2DByPawn(class APawn* Pawn, class USoundBase* Sound)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SpawnLocalSound2DByPawn");

	UPavlovStatics_SpawnLocalSound2DByPawn_Params params {};
	params.Pawn = Pawn;
	params.Sound = Sound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7F00
//		Name   -> Function Pavlov.PavlovStatics.SpawnLocalSound2D
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SpawnLocalSound2D(class APlayerController* Controller, class USoundBase* Sound)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SpawnLocalSound2D");

	UPavlovStatics_SpawnLocalSound2D_Params params {};
	params.Controller = Controller;
	params.Sound = Sound;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7E50
//		Name   -> Function Pavlov.PavlovStatics.SpawnHitFeedbackSound
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EHitFeedbackType                            Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SpawnHitFeedbackSound(class UObject* WorldContextObject, Pavlov_EHitFeedbackType Type)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SpawnHitFeedbackSound");

	UPavlovStatics_SpawnHitFeedbackSound_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7D00
//		Name   -> Function Pavlov.PavlovStatics.SetPlayerEffectsDisabled
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bDisabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SetPlayerEffectsDisabled(class UObject* WorldContextObject, bool bDisabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SetPlayerEffectsDisabled");

	UPavlovStatics_SetPlayerEffectsDisabled_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.bDisabled = bDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7C40
//		Name   -> Function Pavlov.PavlovStatics.SetPavlovSplash
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture*                                    SplashTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SetPavlovSplash(bool bVisible, class UTexture* SplashTexture)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SetPavlovSplash");

	UPavlovStatics_SetPavlovSplash_Params params {};
	params.bVisible = bVisible;
	params.SplashTexture = SplashTexture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7B00
//		Name   -> Function Pavlov.PavlovStatics.SetActorNetDormancy
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TEnumAsByte<Engine_ENetDormancy>                   Dormancy                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_SetActorNetDormancy(class AActor* Actor, TEnumAsByte<Engine_ENetDormancy> Dormancy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.SetActorNetDormancy");

	UPavlovStatics_SetActorNetDormancy_Params params {};
	params.Actor = Actor;
	params.Dormancy = Dormancy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7870
//		Name   -> Function Pavlov.PavlovStatics.ResetVoiceCaptureDevice
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_ResetVoiceCaptureDevice(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.ResetVoiceCaptureDevice");

	UPavlovStatics_ResetVoiceCaptureDevice_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B74D0
//		Name   -> Function Pavlov.PavlovStatics.PropRadialDamage
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              MinimumDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              DamageInnerRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              DamageOuterRadius                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              DamageFalloff                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<class AActor*>                              IgnoreActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 InstigatedByController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TEnumAsByte<Engine_ECollisionChannel>              DamagePreventionChannel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_PropRadialDamage(class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const struct FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<Engine_ECollisionChannel> DamagePreventionChannel)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.PropRadialDamage");

	UPavlovStatics_PropRadialDamage_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.BaseDamage = BaseDamage;
	params.MinimumDamage = MinimumDamage;
	params.Origin = Origin;
	params.DamageInnerRadius = DamageInnerRadius;
	params.DamageOuterRadius = DamageOuterRadius;
	params.DamageFalloff = DamageFalloff;
	params.DamageTypeClass = DamageTypeClass;
	params.IgnoreActors = IgnoreActors;
	params.DamageCauser = DamageCauser;
	params.InstigatedByController = InstigatedByController;
	params.DamagePreventionChannel = DamagePreventionChannel;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7210
//		Name   -> Function Pavlov.PavlovStatics.OpenPavlovMapById
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Options                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bNoDelay                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_OpenPavlovMapById(class UObject* WorldContextObject, const struct FString& ID, const struct FString& Options, bool bNoDelay)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.OpenPavlovMapById");

	UPavlovStatics_OpenPavlovMapById_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.ID = ID;
	params.Options = Options;
	params.bNoDelay = bNoDelay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B6F70
//		Name   -> Function Pavlov.PavlovStatics.IsXmas
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsXmas(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsXmas");

	UPavlovStatics_IsXmas_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6E00
//		Name   -> Function Pavlov.PavlovStatics.IsReplay
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsReplay(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsReplay");

	UPavlovStatics_IsReplay_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x003510D0
//		Name   -> Function Pavlov.PavlovStatics.IsQuestServer
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsQuestServer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsQuestServer");

	UPavlovStatics_IsQuestServer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x003510D0
//		Name   -> Function Pavlov.PavlovStatics.IsQuest
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsQuest()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsQuest");

	UPavlovStatics_IsQuest_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6D80
//		Name   -> Function Pavlov.PavlovStatics.IsPlayingOnlineGame
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsPlayingOnlineGame(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsPlayingOnlineGame");

	UPavlovStatics_IsPlayingOnlineGame_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6D50
//		Name   -> Function Pavlov.PavlovStatics.IsOculusTouch
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsOculusTouch()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsOculusTouch");

	UPavlovStatics_IsOculusTouch_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6C10
//		Name   -> Function Pavlov.PavlovStatics.IsInEntry
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsInEntry(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsInEntry");

	UPavlovStatics_IsInEntry_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6B90
//		Name   -> Function Pavlov.PavlovStatics.IsHalloween
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsHalloween(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsHalloween");

	UPavlovStatics_IsHalloween_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x003510D0
//		Name   -> Function Pavlov.PavlovStatics.IsEditor
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsEditor()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsEditor");

	UPavlovStatics_IsEditor_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6A80
//		Name   -> Function Pavlov.PavlovStatics.IsCompetitiveMode
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsCompetitiveMode(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsCompetitiveMode");

	UPavlovStatics_IsCompetitiveMode_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6A00
//		Name   -> Function Pavlov.PavlovStatics.IsBombDropped
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsBombDropped(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsBombDropped");

	UPavlovStatics_IsBombDropped_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6980
//		Name   -> Function Pavlov.PavlovStatics.IsAprilFools
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_IsAprilFools(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.IsAprilFools");

	UPavlovStatics_IsAprilFools_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6950
//		Name   -> Function Pavlov.PavlovStatics.HasGunOptimizations
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_HasGunOptimizations()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.HasGunOptimizations");

	UPavlovStatics_HasGunOptimizations_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B68B0
//		Name   -> Function Pavlov.PavlovStatics.GoToStartUpMap
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_GoToStartUpMap(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GoToStartUpMap");

	UPavlovStatics_GoToStartUpMap_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B6840
//		Name   -> Function Pavlov.PavlovStatics.GoToEntry
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_GoToEntry(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GoToEntry");

	UPavlovStatics_GoToEntry_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B67C0
//		Name   -> Function Pavlov.PavlovStatics.GetWorkshop
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UWorkshop*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UWorkshop* UPavlovStatics::STATIC_GetWorkshop(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetWorkshop");

	UPavlovStatics_GetWorkshop_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6730
//		Name   -> Function Pavlov.PavlovStatics.GetVoiceLevelPeak
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPavlovStatics::STATIC_GetVoiceLevelPeak(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetVoiceLevelPeak");

	UPavlovStatics_GetVoiceLevelPeak_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B65D0
//		Name   -> Function Pavlov.PavlovStatics.GetUserId
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovStatics::STATIC_GetUserId(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetUserId");

	UPavlovStatics_GetUserId_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6550
//		Name   -> Function Pavlov.PavlovStatics.GetUIManager
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UUIManager*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UUIManager* UPavlovStatics::STATIC_GetUIManager(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetUIManager");

	UPavlovStatics_GetUIManager_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B64D0
//		Name   -> Function Pavlov.PavlovStatics.GetTutorial
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTutorial*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTutorial* UPavlovStatics::STATIC_GetTutorial(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetTutorial");

	UPavlovStatics_GetTutorial_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6450
//		Name   -> Function Pavlov.PavlovStatics.GetSpectatorTVCamera
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class ASpectatorTVCamera*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class ASpectatorTVCamera* UPavlovStatics::STATIC_GetSpectatorTVCamera(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetSpectatorTVCamera");

	UPavlovStatics_GetSpectatorTVCamera_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6420
//		Name   -> Function Pavlov.PavlovStatics.GetShackQualityLevel
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPavlovStatics::STATIC_GetShackQualityLevel()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetShackQualityLevel");

	UPavlovStatics_GetShackQualityLevel_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B63F0
//		Name   -> Function Pavlov.PavlovStatics.GetShackDeviceType
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_EShackDeviceType                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EShackDeviceType UPavlovStatics::STATIC_GetShackDeviceType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetShackDeviceType");

	UPavlovStatics_GetShackDeviceType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6180
//		Name   -> Function Pavlov.PavlovStatics.GetRefPoseBoneTransform
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USkeletalMeshComponent*                      SkelMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform UPavlovStatics::STATIC_GetRefPoseBoneTransform(class USkeletalMeshComponent* SkelMesh, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetRefPoseBoneTransform");

	UPavlovStatics_GetRefPoseBoneTransform_Params params {};
	params.SkelMesh = SkelMesh;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B60B0
//		Name   -> Function Pavlov.PavlovStatics.GetPlayerUniqueIdAsString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovStatics::STATIC_GetPlayerUniqueIdAsString(class APlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPlayerUniqueIdAsString");

	UPavlovStatics_GetPlayerUniqueIdAsString_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5F80
//		Name   -> Function Pavlov.PavlovStatics.GetPlayerEquipment
//		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       Primary                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<struct FName>                               Secondary                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_GetPlayerEquipment(class APlayerState* PlayerState, struct FName* Primary, TArray<struct FName>* Secondary)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPlayerEquipment");

	UPavlovStatics_GetPlayerEquipment_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Primary != nullptr)
		*Primary = params.Primary;
	if (Secondary != nullptr)
		*Secondary = params.Secondary;

}


// Function:
//		Offset -> 0x006B5F00
//		Name   -> Function Pavlov.PavlovStatics.GetPlayerEffects
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AGlobalPlayerEffects*                        ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AGlobalPlayerEffects* UPavlovStatics::STATIC_GetPlayerEffects(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPlayerEffects");

	UPavlovStatics_GetPlayerEffects_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5E40
//		Name   -> Function Pavlov.PavlovStatics.GetPawnByPlayerState
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPawn* UPavlovStatics::STATIC_GetPawnByPlayerState(class UObject* WorldContextObject, class APlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPawnByPlayerState");

	UPavlovStatics_GetPawnByPlayerState_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5D70
//		Name   -> Function Pavlov.PavlovStatics.GetPavlovVersionString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UPavlovStatics::STATIC_GetPavlovVersionString(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPavlovVersionString");

	UPavlovStatics_GetPavlovVersionString_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5CF0
//		Name   -> Function Pavlov.PavlovStatics.GetPavlovLobby
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPavlovLobby*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UPavlovLobby* UPavlovStatics::STATIC_GetPavlovLobby(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPavlovLobby");

	UPavlovStatics_GetPavlovLobby_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5CC0
//		Name   -> Function Pavlov.PavlovStatics.GetPavlovGameUserSettings
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UPavlovGameUserSettings*                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UPavlovGameUserSettings* UPavlovStatics::STATIC_GetPavlovGameUserSettings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPavlovGameUserSettings");

	UPavlovStatics_GetPavlovGameUserSettings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5C40
//		Name   -> Function Pavlov.PavlovStatics.GetPavlovGameInstance
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPavlovGameInstance*                         ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UPavlovGameInstance* UPavlovStatics::STATIC_GetPavlovGameInstance(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetPavlovGameInstance");

	UPavlovStatics_GetPavlovGameInstance_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5950
//		Name   -> Function Pavlov.PavlovStatics.GetMeshMaterials
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UStaticMesh*                                 StaticMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<class UMaterialInterface*>                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<class UMaterialInterface*> UPavlovStatics::STATIC_GetMeshMaterials(class UStaticMesh* StaticMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetMeshMaterials");

	UPavlovStatics_GetMeshMaterials_Params params {};
	params.StaticMesh = StaticMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B58D0
//		Name   -> Function Pavlov.PavlovStatics.GetMenuUniverseInstance
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AMenuUniverse*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AMenuUniverse* UPavlovStatics::STATIC_GetMenuUniverseInstance(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetMenuUniverseInstance");

	UPavlovStatics_GetMenuUniverseInstance_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5850
//		Name   -> Function Pavlov.PavlovStatics.GetMatchmaking
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UMatchmaking*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UMatchmaking* UPavlovStatics::STATIC_GetMatchmaking(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetMatchmaking");

	UPavlovStatics_GetMatchmaking_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B57D0
//		Name   -> Function Pavlov.PavlovStatics.GetLocalPlayerState
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPlayerState*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPlayerState* UPavlovStatics::STATIC_GetLocalPlayerState(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetLocalPlayerState");

	UPavlovStatics_GetLocalPlayerState_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5710
//		Name   -> Function Pavlov.PavlovStatics.GetLocalPlayerCameraTransform
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform UPavlovStatics::STATIC_GetLocalPlayerCameraTransform(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetLocalPlayerCameraTransform");

	UPavlovStatics_GetLocalPlayerCameraTransform_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5690
//		Name   -> Function Pavlov.PavlovStatics.GetHoliday
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EHolidays                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EHolidays UPavlovStatics::STATIC_GetHoliday(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetHoliday");

	UPavlovStatics_GetHoliday_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5570
//		Name   -> Function Pavlov.PavlovStatics.GetFriendsUserId
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<struct FString>                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FString> UPavlovStatics::STATIC_GetFriendsUserId(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetFriendsUserId");

	UPavlovStatics_GetFriendsUserId_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5410
//		Name   -> Function Pavlov.PavlovStatics.GetDefaultObject
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      ObjectClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UObject*                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UObject* UPavlovStatics::STATIC_GetDefaultObject(class UClass* ObjectClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetDefaultObject");

	UPavlovStatics_GetDefaultObject_Params params {};
	params.ObjectClass = ObjectClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5390
//		Name   -> Function Pavlov.PavlovStatics.GetControllerByPlayerState
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AController* UPavlovStatics::STATIC_GetControllerByPlayerState(class APlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetControllerByPlayerState");

	UPavlovStatics_GetControllerByPlayerState_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5290
//		Name   -> Function Pavlov.PavlovStatics.GetBoneTransform
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class USkeletalMeshComponent*                      SkelMesh                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform UPavlovStatics::STATIC_GetBoneTransform(class USkeletalMeshComponent* SkelMesh, const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetBoneTransform");

	UPavlovStatics_GetBoneTransform_Params params {};
	params.SkelMesh = SkelMesh;
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5210
//		Name   -> Function Pavlov.PavlovStatics.GetBombInstance
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class ABomb*                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class ABomb* UPavlovStatics::STATIC_GetBombInstance(class UObject* WorldContextObject)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.GetBombInstance");

	UPavlovStatics_GetBombInstance_Params params {};
	params.WorldContextObject = WorldContextObject;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B51A0
//		Name   -> Function Pavlov.PavlovStatics.ForceNoSoundOcclusion
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class UAudioComponent*                             AudioComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_ForceNoSoundOcclusion(class UAudioComponent* AudioComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.ForceNoSoundOcclusion");

	UPavlovStatics_ForceNoSoundOcclusion_Params params {};
	params.AudioComp = AudioComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B5130
//		Name   -> Function Pavlov.PavlovStatics.FlushActorNetDormancy
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
//		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPavlovStatics::STATIC_FlushActorNetDormancy(class AActor* Actor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.FlushActorNetDormancy");

	UPavlovStatics_FlushActorNetDormancy_Params params {};
	params.Actor = Actor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B5030
//		Name   -> Function Pavlov.PavlovStatics.FindClosestBombPlantSpot
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     RefLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class ABombPlantSpot*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class ABombPlantSpot* UPavlovStatics::STATIC_FindClosestBombPlantSpot(class UObject* WorldContextObject, const struct FVector& RefLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.FindClosestBombPlantSpot");

	UPavlovStatics_FindClosestBombPlantSpot_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.RefLocation = RefLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B4C80
//		Name   -> Function Pavlov.PavlovStatics.ArePawnsHostile
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APawn*                                       A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APawn*                                       B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPavlovStatics::STATIC_ArePawnsHostile(class UObject* WorldContextObject, class APawn* A, class APawn* B)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovStatics.ArePawnsHostile");

	UPavlovStatics_ArePawnsHostile_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.A = A;
	params.B = B;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B87A0
//		Name   -> Function Pavlov.PavlovVehicle.ZombieHit_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Protected)
// Parameters:
//		struct FVector_NetQuantize                         HitLocation                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
void APavlovVehicle::ZombieHit_Multi(const struct FVector_NetQuantize& HitLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.ZombieHit_Multi");

	APavlovVehicle_ZombieHit_Multi_Params params {};
	params.HitLocation = HitLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B8710
//		Name   -> Function Pavlov.PavlovVehicle.VehicleSoundSetup
//		Flags  -> (Native, Public)
// Parameters:
//		bool                                               bEntered                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::VehicleSoundSetup(bool bEntered)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.VehicleSoundSetup");

	APavlovVehicle_VehicleSoundSetup_Params params {};
	params.bEntered = bEntered;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00675A90
//		Name   -> Function Pavlov.PavlovVehicle.VehicleKilled_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Protected)
void APavlovVehicle::VehicleKilled_Multi()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.VehicleKilled_Multi");

	APavlovVehicle_VehicleKilled_Multi_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B86F0
//		Name   -> Function Pavlov.PavlovVehicle.TryFlipVehicle
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void APavlovVehicle::TryFlipVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.TryFlipVehicle");

	APavlovVehicle_TryFlipVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B83C0
//		Name   -> Function Pavlov.PavlovVehicle.TakeRadialDamage
//		Flags  -> (Final, Native, Protected, HasDefaults)
// Parameters:
//		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  HitInfo                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
//		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::TakeRadialDamage(class AActor* DamagedActor, float Damage, class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.TakeRadialDamage");

	APavlovVehicle_TakeRadialDamage_Params params {};
	params.DamagedActor = DamagedActor;
	params.Damage = Damage;
	params.DamageType = DamageType;
	params.Origin = Origin;
	params.HitInfo = HitInfo;
	params.InstigatedBy = InstigatedBy;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B8120
//		Name   -> Function Pavlov.PavlovVehicle.TakePointDamage
//		Flags  -> (Final, Native, Protected, HasDefaults)
// Parameters:
//		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ShotFromDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::TakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, const struct FName& BoneName, const struct FVector& ShotFromDirection, class UDamageType* DamageType, class AActor* DamageCauser)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.TakePointDamage");

	APavlovVehicle_TakePointDamage_Params params {};
	params.DamagedActor = DamagedActor;
	params.Damage = Damage;
	params.InstigatedBy = InstigatedBy;
	params.HitLocation = HitLocation;
	params.HitComponent = HitComponent;
	params.BoneName = BoneName;
	params.ShotFromDirection = ShotFromDirection;
	params.DamageType = DamageType;
	params.DamageCauser = DamageCauser;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B8060
//		Name   -> Function Pavlov.PavlovVehicle.StartVehicleDespawnTimer
//		Flags  -> (Final, Native, Public)
void APavlovVehicle::StartVehicleDespawnTimer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.StartVehicleDespawnTimer");

	APavlovVehicle_StartVehicleDespawnTimer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7DC0
//		Name   -> Function Pavlov.PavlovVehicle.SetVehicleOccupied
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bOccupied                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::SetVehicleOccupied(bool bOccupied)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.SetVehicleOccupied");

	APavlovVehicle_SetVehicleOccupied_Params params {};
	params.bOccupied = bOccupied;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7BB0
//		Name   -> Function Pavlov.PavlovVehicle.SetEngineState
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bStart                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::SetEngineState(bool bStart)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.SetEngineState");

	APavlovVehicle_SetEngineState_Params params {};
	params.bStart = bStart;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7A80
//		Name   -> Function Pavlov.PavlovVehicle.SeatVehicleTeamID
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                NewTeamId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::SeatVehicleTeamID(int NewTeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.SeatVehicleTeamID");

	APavlovVehicle_SeatVehicleTeamID_Params params {};
	params.NewTeamId = NewTeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7840
//		Name   -> Function Pavlov.PavlovVehicle.RepairVehicle
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::RepairVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.RepairVehicle");

	APavlovVehicle_RepairVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00675AD0
//		Name   -> Function Pavlov.PavlovVehicle.PlayRepairSound_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Protected)
// Parameters:
//		bool                                               bFullyRepaired                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::PlayRepairSound_Multi(bool bFullyRepaired)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.PlayRepairSound_Multi");

	APavlovVehicle_PlayRepairSound_Multi_Params params {};
	params.bFullyRepaired = bFullyRepaired;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7400
//		Name   -> Function Pavlov.PavlovVehicle.PlayerEnterExit_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bEntered                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::PlayerEnterExit_Multi(bool bEntered, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.PlayerEnterExit_Multi");

	APavlovVehicle_PlayerEnterExit_Multi_Params params {};
	params.bEntered = bEntered;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7370
//		Name   -> Function Pavlov.PavlovVehicle.OutOfBounds
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bOut                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::OutOfBounds(bool bOut)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.OutOfBounds");

	APavlovVehicle_OutOfBounds_Params params {};
	params.bOut = bOut;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7180
//		Name   -> Function Pavlov.PavlovVehicle.OnVehicleCritical
//		Flags  -> (Native, Protected)
// Parameters:
//		bool                                               bCritical                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::OnVehicleCritical(bool bCritical)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.OnVehicleCritical");

	APavlovVehicle_OnVehicleCritical_Params params {};
	params.bCritical = bCritical;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B7100
//		Name   -> Function Pavlov.PavlovVehicle.OnRep_VehicleDamageState
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		Pavlov_EVehicleDamageState                         OldVehicleDamageState                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::OnRep_VehicleDamageState(Pavlov_EVehicleDamageState OldVehicleDamageState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.OnRep_VehicleDamageState");

	APavlovVehicle_OnRep_VehicleDamageState_Params params {};
	params.OldVehicleDamageState = OldVehicleDamageState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B70E0
//		Name   -> Function Pavlov.PavlovVehicle.OnRep_Occupied
//		Flags  -> (Final, Native, Protected)
void APavlovVehicle::OnRep_Occupied()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.OnRep_Occupied");

	APavlovVehicle_OnRep_Occupied_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B70C0
//		Name   -> Function Pavlov.PavlovVehicle.OnRep_EngineOn
//		Flags  -> (Final, Native, Protected)
void APavlovVehicle::OnRep_EngineOn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.OnRep_EngineOn");

	APavlovVehicle_OnRep_EngineOn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B6FF0
//		Name   -> Function Pavlov.PavlovVehicle.OnEngineChanged
//		Flags  -> (Net, Native, Event, NetMulticast, Protected)
// Parameters:
//		bool                                               bOn                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bDisabled                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::OnEngineChanged(bool bOn, bool bDisabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.OnEngineChanged");

	APavlovVehicle_OnEngineChanged_Params params {};
	params.bOn = bOn;
	params.bDisabled = bDisabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B6F40
//		Name   -> Function Pavlov.PavlovVehicle.IsVehicleEmpty
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::IsVehicleEmpty()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.IsVehicleEmpty");

	APavlovVehicle_IsVehicleEmpty_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6F10
//		Name   -> Function Pavlov.PavlovVehicle.IsVehicleDisabled
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::IsVehicleDisabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.IsVehicleDisabled");

	APavlovVehicle_IsVehicleDisabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6E80
//		Name   -> Function Pavlov.PavlovVehicle.IsSeatEmpty
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::IsSeatEmpty(int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.IsSeatEmpty");

	APavlovVehicle_IsSeatEmpty_Params params {};
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6D20
//		Name   -> Function Pavlov.PavlovVehicle.IsLocalPlayerInVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::IsLocalPlayerInVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.IsLocalPlayerInVehicle");

	APavlovVehicle_IsLocalPlayerInVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6C90
//		Name   -> Function Pavlov.PavlovVehicle.IsLocalPlayerInSeat
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::IsLocalPlayerInSeat(int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.IsLocalPlayerInSeat");

	APavlovVehicle_IsLocalPlayerInSeat_Params params {};
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6B00
//		Name   -> Function Pavlov.PavlovVehicle.IsDriver
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UVehicleOccupant*                            Occupant                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::IsDriver(class UVehicleOccupant* Occupant)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.IsDriver");

	APavlovVehicle_IsDriver_Params params {};
	params.Occupant = Occupant;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6920
//		Name   -> Function Pavlov.PavlovVehicle.HasDriver
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::HasDriver()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.HasDriver");

	APavlovVehicle_HasDriver_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B66A0
//		Name   -> Function Pavlov.PavlovVehicle.GetVehicleInterior
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* APavlovVehicle::GetVehicleInterior(int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetVehicleInterior");

	APavlovVehicle_GetVehicleInterior_Params params {};
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovVehicle.GetVehicleEngineAudioComponents
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TArray<class UAudioComponent*>                     ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
TArray<class UAudioComponent*> APavlovVehicle::GetVehicleEngineAudioComponents()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetVehicleEngineAudioComponents");

	APavlovVehicle_GetVehicleEngineAudioComponents_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovVehicle.GetVehicleAudioComponents
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TArray<class UAudioComponent*>                     ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
TArray<class UAudioComponent*> APavlovVehicle::GetVehicleAudioComponents()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetVehicleAudioComponents");

	APavlovVehicle_GetVehicleAudioComponents_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00375C70
//		Name   -> Function Pavlov.PavlovVehicle.GetTeamId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovVehicle::GetTeamId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetTeamId");

	APavlovVehicle_GetTeamId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6310
//		Name   -> Function Pavlov.PavlovVehicle.GetSeatExitLocation
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ExitLocation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::GetSeatExitLocation(bool bRight, struct FVector* ExitLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetSeatExitLocation");

	APavlovVehicle_GetSeatExitLocation_Params params {};
	params.bRight = bRight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (ExitLocation != nullptr)
		*ExitLocation = params.ExitLocation;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B6280
//		Name   -> Function Pavlov.PavlovVehicle.GetSeat
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UVehicleSeat*                                ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVehicleSeat* APavlovVehicle::GetSeat(int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetSeat");

	APavlovVehicle_GetSeat_Params params {};
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5B20
//		Name   -> Function Pavlov.PavlovVehicle.GetOccupantSeat
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UVehicleOccupant*                            Occupant                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovVehicle::GetOccupantSeat(class UVehicleOccupant* Occupant)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetOccupantSeat");

	APavlovVehicle_GetOccupantSeat_Params params {};
	params.Occupant = Occupant;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5BC0
//		Name   -> Function Pavlov.PavlovVehicle.GetOccupants
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<class UVehicleOccupant*>                    ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
TArray<class UVehicleOccupant*> APavlovVehicle::GetOccupants()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetOccupants");

	APavlovVehicle_GetOccupants_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5A90
//		Name   -> Function Pavlov.PavlovVehicle.GetOccupant
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UVehicleOccupant*                            ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVehicleOccupant* APavlovVehicle::GetOccupant(int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetOccupant");

	APavlovVehicle_GetOccupant_Params params {};
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5A20
//		Name   -> Function Pavlov.PavlovVehicle.GetMovmentVelocity
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector APavlovVehicle::GetMovmentVelocity()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetMovmentVelocity");

	APavlovVehicle_GetMovmentVelocity_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B54C0
//		Name   -> Function Pavlov.PavlovVehicle.GetExitLocation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		bool                                               bRight                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector APavlovVehicle::GetExitLocation(bool bRight)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetExitLocation");

	APavlovVehicle_GetExitLocation_Params params {};
	params.bRight = bRight;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5490
//		Name   -> Function Pavlov.PavlovVehicle.GetDriverSeat
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovVehicle::GetDriverSeat()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetDriverSeat");

	APavlovVehicle_GetDriverSeat_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x0067E380
//		Name   -> Function Pavlov.PavlovVehicle.GetDriver
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UVehicleOccupant*                            ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UVehicleOccupant* APavlovVehicle::GetDriver()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.GetDriver");

	APavlovVehicle_GetDriver_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5100
//		Name   -> Function Pavlov.PavlovVehicle.FindEmptySeat
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APavlovVehicle::FindEmptySeat()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.FindEmptySeat");

	APavlovVehicle_FindEmptySeat_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B5010
//		Name   -> Function Pavlov.PavlovVehicle.EnteredKillVolume
//		Flags  -> (Final, Native, Public)
void APavlovVehicle::EnteredKillVolume()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.EnteredKillVolume");

	APavlovVehicle_EnteredKillVolume_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B4F80
//		Name   -> Function Pavlov.PavlovVehicle.DoesSeatExitRight
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::DoesSeatExitRight(int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.DoesSeatExitRight");

	APavlovVehicle_DoesSeatExitRight_Params params {};
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006B4F60
//		Name   -> Function Pavlov.PavlovVehicle.DelayEngineOffSound
//		Flags  -> (Final, Native, Protected)
void APavlovVehicle::DelayEngineOffSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.DelayEngineOffSound");

	APavlovVehicle_DelayEngineOffSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B4EE0
//		Name   -> Function Pavlov.PavlovVehicle.ClearBumpers_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		float                                              Direction                                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::ClearBumpers_Multi(float Direction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.ClearBumpers_Multi");

	APavlovVehicle_ClearBumpers_Multi_Params params {};
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B4E40
//		Name   -> Function Pavlov.PavlovVehicle.ClearBumpers
//		Flags  -> (BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		float                                              Direction                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle::ClearBumpers(float Direction)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.ClearBumpers");

	APavlovVehicle_ClearBumpers_Params params {};
	params.Direction = Direction;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006B4D70
//		Name   -> Function Pavlov.PavlovVehicle.CanEnterVehicle
//		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APavlovPawn*                                 PavlovPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle::CanEnterVehicle(class APavlovPawn* PavlovPawn, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle.CanEnterVehicle");

	APavlovVehicle_CanEnterVehicle_Params params {};
	params.PavlovPawn = PavlovPawn;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PavlovVehicle_Tank.UpdateSeatWidget
//		Flags  -> (Event, Public, BlueprintEvent)
void APavlovVehicle_Tank::UpdateSeatWidget()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.UpdateSeatWidget");

	APavlovVehicle_Tank_UpdateSeatWidget_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC760
//		Name   -> Function Pavlov.PavlovVehicle_Tank.TurretMoving_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bIsTurretMoving                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle_Tank::TurretMoving_Multi(bool bIsTurretMoving)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.TurretMoving_Multi");

	APavlovVehicle_Tank_TurretMoving_Multi_Params params {};
	params.bIsTurretMoving = bIsTurretMoving;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC740
//		Name   -> Function Pavlov.PavlovVehicle_Tank.TurretFired_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APavlovVehicle_Tank::TurretFired_Multi()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.TurretFired_Multi");

	APavlovVehicle_Tank_TurretFired_Multi_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC700
//		Name   -> Function Pavlov.PavlovVehicle_Tank.StopGunnerFire
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void APavlovVehicle_Tank::StopGunnerFire()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.StopGunnerFire");

	APavlovVehicle_Tank_StopGunnerFire_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC6D0
//		Name   -> Function Pavlov.PavlovVehicle_Tank.StartGunnerFire
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle_Tank::StartGunnerFire()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.StartGunnerFire");

	APavlovVehicle_Tank_StartGunnerFire_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BC650
//		Name   -> Function Pavlov.PavlovVehicle_Tank.SetTurretTurnRate
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              FOVAlpha                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle_Tank::SetTurretTurnRate(float FOVAlpha)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.SetTurretTurnRate");

	APavlovVehicle_Tank_SetTurretTurnRate_Params params {};
	params.FOVAlpha = FOVAlpha;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC5D0
//		Name   -> Function Pavlov.PavlovVehicle_Tank.SetTurretInput
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FVector2D                                   AddRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovVehicle_Tank::SetTurretInput(const struct FVector2D& AddRotation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.SetTurretInput");

	APavlovVehicle_Tank_SetTurretInput_Params params {};
	params.AddRotation = AddRotation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC340
//		Name   -> Function Pavlov.PavlovVehicle_Tank.SetMachineGunRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    MGRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void APavlovVehicle_Tank::SetMachineGunRotation(const struct FRotator& MGRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.SetMachineGunRotation");

	APavlovVehicle_Tank_SetMachineGunRotation_Params params {};
	params.MGRot = MGRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC010
//		Name   -> Function Pavlov.PavlovVehicle_Tank.OnRep_Overheating
//		Flags  -> (Final, Native, Protected)
void APavlovVehicle_Tank::OnRep_Overheating()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.OnRep_Overheating");

	APavlovVehicle_Tank_OnRep_Overheating_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBA80
//		Name   -> Function Pavlov.PavlovVehicle_Tank.IsTurretPitchLimitReached
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              TurretPitchInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle_Tank::IsTurretPitchLimitReached(float TurretPitchInput)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.IsTurretPitchLimitReached");

	APavlovVehicle_Tank_IsTurretPitchLimitReached_Params params {};
	params.TurretPitchInput = TurretPitchInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BBA50
//		Name   -> Function Pavlov.PavlovVehicle_Tank.IsTurretMoving
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle_Tank::IsTurretMoving()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.IsTurretMoving");

	APavlovVehicle_Tank_IsTurretMoving_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BBA20
//		Name   -> Function Pavlov.PavlovVehicle_Tank.IsGunnerOverheated
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle_Tank::IsGunnerOverheated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.IsGunnerOverheated");

	APavlovVehicle_Tank_IsGunnerOverheated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x002AA760
//		Name   -> Function Pavlov.PavlovVehicle_Tank.GunnerFired_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APavlovVehicle_Tank::GunnerFired_Multi()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.GunnerFired_Multi");

	APavlovVehicle_Tank_GunnerFired_Multi_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBA00
//		Name   -> Function Pavlov.PavlovVehicle_Tank.GunnerFireBullet
//		Flags  -> (Final, Native, Public)
void APavlovVehicle_Tank::GunnerFireBullet()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.GunnerFireBullet");

	APavlovVehicle_Tank_GunnerFireBullet_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB9E0
//		Name   -> Function Pavlov.PavlovVehicle_Tank.GunnerCooldownTick
//		Flags  -> (Final, Native, Public)
void APavlovVehicle_Tank::GunnerCooldownTick()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.GunnerCooldownTick");

	APavlovVehicle_Tank_GunnerCooldownTick_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB9A0
//		Name   -> Function Pavlov.PavlovVehicle_Tank.GetTurretRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FVector2D                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FVector2D APavlovVehicle_Tank::GetTurretRotation()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.GetTurretRotation");

	APavlovVehicle_Tank_GetTurretRotation_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB800
//		Name   -> Function Pavlov.PavlovVehicle_Tank.FireTankTurret
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle_Tank::FireTankTurret()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.FireTankTurret");

	APavlovVehicle_Tank_FireTankTurret_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB7E0
//		Name   -> Function Pavlov.PavlovVehicle_Tank.DeactivateGunnerFireFX
//		Flags  -> (Final, Native, Public)
void APavlovVehicle_Tank::DeactivateGunnerFireFX()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.DeactivateGunnerFireFX");

	APavlovVehicle_Tank_DeactivateGunnerFireFX_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB770
//		Name   -> Function Pavlov.PavlovVehicle_Tank.CanFireTurret
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APavlovVehicle_Tank::CanFireTurret()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.CanFireTurret");

	APavlovVehicle_Tank_CanFireTurret_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB680
//		Name   -> Function Pavlov.PavlovVehicle_Tank.AddHeatBuildup
//		Flags  -> (Final, Native, Public)
void APavlovVehicle_Tank::AddHeatBuildup()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovVehicle_Tank.AddHeatBuildup");

	APavlovVehicle_Tank_AddHeatBuildup_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC550
//		Name   -> Function Pavlov.PavlovWheeledVehicle.SetSteeringInput
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Input                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APavlovWheeledVehicle::SetSteeringInput(float Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PavlovWheeledVehicle.SetSteeringInput");

	APavlovWheeledVehicle_SetSteeringInput_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB890
//		Name   -> Function Pavlov.PlayerCycler.GetNext
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 Pawn                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPlayerCycler::GetNext(class APavlovPlayerState** PlayerState, class APavlovPawn** Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayerCycler.GetNext");

	UPlayerCycler_GetNext_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PlayerState != nullptr)
		*PlayerState = params.PlayerState;
	if (Pawn != nullptr)
		*Pawn = params.Pawn;

}


// Function:
//		Offset -> 0x006BF220
//		Name   -> Function Pavlov.PushPlayerDialog.GetRandomChantIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPushPlayerDialog::GetRandomChantIndex()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDialog.GetRandomChantIndex");

	UPushPlayerDialog_GetRandomChantIndex_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEDE0
//		Name   -> Function Pavlov.PushPlayerDialog.GetDialogPriority
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EPushDialog                                 DialogType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPushPlayerDialog::GetDialogPriority(Pavlov_EPushDialog DialogType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDialog.GetDialogPriority");

	UPushPlayerDialog_GetDialogPriority_Params params {};
	params.DialogType = DialogType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BED50
//		Name   -> Function Pavlov.PushPlayerDialog.GetDialogByType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_EPushDialog                                 DialogType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USoundCue*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundCue* UPushPlayerDialog::GetDialogByType(Pavlov_EPushDialog DialogType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDialog.GetDialogByType");

	UPushPlayerDialog_GetDialogByType_Params params {};
	params.DialogType = DialogType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BECC0
//		Name   -> Function Pavlov.PushPlayerDialog.GetDialogBuffer
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EPushDialog                                 DialogType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UPushPlayerDialog::GetDialogBuffer(Pavlov_EPushDialog DialogType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDialog.GetDialogBuffer");

	UPushPlayerDialog_GetDialogBuffer_Params params {};
	params.DialogType = DialogType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEC20
//		Name   -> Function Pavlov.PushPlayerDialog.GetChantByIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ChantIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FPushChant                                  ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
struct FPushChant UPushPlayerDialog::GetChantByIndex(int ChantIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDialog.GetChantByIndex");

	UPushPlayerDialog_GetChantByIndex_Params params {};
	params.ChantIndex = ChantIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BFC40
//		Name   -> Function Pavlov.PushPlayerStateComponent.PlayerRevived
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UClass*                                      PushPlayerDataClass                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FName                                       FallbackWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerStateComponent::PlayerRevived(class APavlovPawn* PavPawn, class UClass* PushPlayerDataClass, const struct FName& FallbackWeapon)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerStateComponent.PlayerRevived");

	UPushPlayerStateComponent_PlayerRevived_Params params {};
	params.PavPawn = PavPawn;
	params.PushPlayerDataClass = PushPlayerDataClass;
	params.FallbackWeapon = FallbackWeapon;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4CC0
//		Name   -> Function Pavlov.Rat.OnRevive
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class AActor*                                      ActorOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ARat::OnRevive(class AActor* ActorOwner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Rat.OnRevive");

	ARat_OnRevive_Params params {};
	params.ActorOwner = ActorOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4B70
//		Name   -> Function Pavlov.Rat.OnKill
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class AActor*                                      ActorOwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ARat::OnKill(class AActor* ActorOwner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Rat.OnKill");

	ARat_OnKill_Params params {};
	params.ActorOwner = ActorOwner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C3D30
//		Name   -> Function Pavlov.Rat.ApplyImpact
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ARat::ApplyImpact()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Rat.ApplyImpact");

	ARat_ApplyImpact_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBC80
//		Name   -> Function Pavlov.PlayOfflineView.OnMapBrowserCommit
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void APlayOfflineView::OnMapBrowserCommit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PlayOfflineView.OnMapBrowserCommit");

	APlayOfflineView_OnMapBrowserCommit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC1C0
//		Name   -> Function Pavlov.Pliers.ServerReportCut
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		class ABomb*                                       Bomb                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                WireIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APliers::ServerReportCut(class ABomb* Bomb, int WireIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Pliers.ServerReportCut");

	APliers_ServerReportCut_Params params {};
	params.Bomb = Bomb;
	params.WireIndex = WireIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00671370
//		Name   -> Function Pavlov.Pliers.MulticastOnCut
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
void APliers::MulticastOnCut()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Pliers.MulticastOnCut");

	APliers_MulticastOnCut_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC2C0
//		Name   -> Function Pavlov.PushBomb.SetBombState
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EBombState                                  State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBomb::SetBombState(Pavlov_EBombState State)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBomb.SetBombState");

	APushBomb_SetBombState_Params params {};
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBF90
//		Name   -> Function Pavlov.PushBomb.OnRep_BombState
//		Flags  -> (Final, Native, Public)
void APushBomb::OnRep_BombState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBomb.OnRep_BombState");

	APushBomb_OnRep_BombState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBB30
//		Name   -> Function Pavlov.PushBomb.OnBombStateChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		Pavlov_EBombState                                  State                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBomb::OnBombStateChanged(Pavlov_EBombState State)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBomb.OnBombStateChanged");

	APushBomb_OnBombStateChanged_Params params {};
	params.State = State;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB7A0
//		Name   -> Function Pavlov.PushBomb.CheckSiteOverlap
//		Flags  -> (Final, Native, Public)
void APushBomb::CheckSiteOverlap()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBomb.CheckSiteOverlap");

	APushBomb_CheckSiteOverlap_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC720
//		Name   -> Function Pavlov.PushBombObjective.TickBombTimer
//		Flags  -> (Final, Native, Public)
void APushBombObjective::TickBombTimer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.TickBombTimer");

	APushBombObjective_TickBombTimer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC4D0
//		Name   -> Function Pavlov.PushBombObjective.SetPushObjectiveProxy
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlov_PushBombObjective*                   PushBombProxy                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::SetPushObjectiveProxy(class APavlov_PushBombObjective* PushBombProxy)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.SetPushObjectiveProxy");

	APushBombObjective_SetPushObjectiveProxy_Params params {};
	params.PushBombProxy = PushBombProxy;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC450
//		Name   -> Function Pavlov.PushBombObjective.SetObjectiveState
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		PavlovProxy_EPushObjectiveState                    PushObjectiveState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::SetObjectiveState(PavlovProxy_EPushObjectiveState PushObjectiveState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.SetObjectiveState");

	APushBombObjective_SetObjectiveState_Params params {};
	params.PushObjectiveState = PushObjectiveState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC3D0
//		Name   -> Function Pavlov.PushBombObjective.SetObjectiveMarker
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		PavlovProxy_EObjectiveMarker                       Marker                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::SetObjectiveMarker(PavlovProxy_EObjectiveMarker Marker)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.SetObjectiveMarker");

	APushBombObjective_SetObjectiveMarker_Params params {};
	params.Marker = Marker;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC1A0
//		Name   -> Function Pavlov.PushBombObjective.ResetObjective
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void APushBombObjective::ResetObjective()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.ResetObjective");

	APushBombObjective_ResetObjective_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC180
//		Name   -> Function Pavlov.PushBombObjective.RemoveBomb
//		Flags  -> (Final, Native, Protected)
void APushBombObjective::RemoveBomb()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.RemoveBomb");

	APushBombObjective_RemoveBomb_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC100
//		Name   -> Function Pavlov.PushBombObjective.PushObjectiveStateChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		PavlovProxy_EPushObjectiveState                    CurrentState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::PushObjectiveStateChanged(PavlovProxy_EPushObjectiveState CurrentState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.PushObjectiveStateChanged");

	APushBombObjective_PushObjectiveStateChanged_Params params {};
	params.CurrentState = CurrentState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC070
//		Name   -> Function Pavlov.PushBombObjective.PlantPushBomb
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APushBomb*                                   PushBomb                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushBombObjective::PlantPushBomb(class APushBomb* PushBomb)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.PlantPushBomb");

	APushBombObjective_PlantPushBomb_Params params {};
	params.PushBomb = PushBomb;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00671370
//		Name   -> Function Pavlov.PushBombObjective.OnTeamsSwitched
//		Flags  -> (BlueprintAuthorityOnly, Native, Event, Public, BlueprintCallable, BlueprintEvent)
void APushBombObjective::OnTeamsSwitched()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnTeamsSwitched");

	APushBombObjective_OnTeamsSwitched_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BC030
//		Name   -> Function Pavlov.PushBombObjective.OnRep_PushObjectiveProxy
//		Flags  -> (Final, Native, Public)
void APushBombObjective::OnRep_PushObjectiveProxy()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnRep_PushObjectiveProxy");

	APushBombObjective_OnRep_PushObjectiveProxy_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBFF0
//		Name   -> Function Pavlov.PushBombObjective.OnRep_ObjectiveState
//		Flags  -> (Final, Native, Public)
void APushBombObjective::OnRep_ObjectiveState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnRep_ObjectiveState");

	APushBombObjective_OnRep_ObjectiveState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBFD0
//		Name   -> Function Pavlov.PushBombObjective.OnRep_ObjectiveMarker
//		Flags  -> (Final, Native, Public)
void APushBombObjective::OnRep_ObjectiveMarker()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnRep_ObjectiveMarker");

	APushBombObjective_OnRep_ObjectiveMarker_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BBFB0
//		Name   -> Function Pavlov.PushBombObjective.OnRep_BombTimerAlpha
//		Flags  -> (Final, Native, Public)
void APushBombObjective::OnRep_BombTimerAlpha()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnRep_BombTimerAlpha");

	APushBombObjective_OnRep_BombTimerAlpha_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> DelegateFunction Pavlov.PushBombObjective.OnPushBombObjectiveStateChanged__DelegateSignature
//		Flags  -> (MulticastDelegate, Public, Delegate)
// Parameters:
//		class APushBombObjective*                          PushBombObjective                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		PavlovProxy_EPushObjectiveState                    ObjectiveState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::OnPushBombObjectiveStateChanged__DelegateSignature(class APushBombObjective* PushBombObjective, PavlovProxy_EPushObjectiveState ObjectiveState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("DelegateFunction Pavlov.PushBombObjective.OnPushBombObjectiveStateChanged__DelegateSignature");

	APushBombObjective_OnPushBombObjectiveStateChanged__DelegateSignature_Params params {};
	params.PushBombObjective = PushBombObjective;
	params.ObjectiveState = ObjectiveState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002A50B0
//		Name   -> Function Pavlov.PushBombObjective.OnObjectiveMarkerChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		PavlovProxy_EObjectiveMarker                       Marker                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::OnObjectiveMarkerChanged(PavlovProxy_EObjectiveMarker Marker)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnObjectiveMarkerChanged");

	APushBombObjective_OnObjectiveMarkerChanged_Params params {};
	params.Marker = Marker;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E1A0
//		Name   -> Function Pavlov.PushBombObjective.OnBombTimerAlphaChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void APushBombObjective::OnBombTimerAlphaChanged()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnBombTimerAlphaChanged");

	APushBombObjective_OnBombTimerAlphaChanged_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00682E70
//		Name   -> Function Pavlov.PushBombObjective.OnBombOverlap
//		Flags  -> (Final, Native, Public, HasOutParms)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void APushBombObjective::OnBombOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnBombOverlap");

	APushBombObjective_OnBombOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0067E7D0
//		Name   -> Function Pavlov.PushBombObjective.OnBombExplosion_Server
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void APushBombObjective::OnBombExplosion_Server()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.OnBombExplosion_Server");

	APushBombObjective_OnBombExplosion_Server_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00687210
//		Name   -> Function Pavlov.PushBombObjective.IsLowQuality
//		Flags  -> (Final, Native, Protected, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushBombObjective::IsLowQuality()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.IsLowQuality");

	APushBombObjective_IsLowQuality_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB970
//		Name   -> Function Pavlov.PushBombObjective.GetObjectiveState
//		Flags  -> (Final, Native, Public)
// Parameters:
//		PavlovProxy_EPushObjectiveState                    ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
PavlovProxy_EPushObjectiveState APushBombObjective::GetObjectiveState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.GetObjectiveState");

	APushBombObjective_GetObjectiveState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB860
//		Name   -> Function Pavlov.PushBombObjective.GetBombMarker
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class UPrimitiveComponent*                         ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UPrimitiveComponent* APushBombObjective::GetBombMarker()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.GetBombMarker");

	APushBombObjective_GetBombMarker_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB830
//		Name   -> Function Pavlov.PushBombObjective.GetActiveObjectiveID
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int APushBombObjective::GetActiveObjectiveID()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.GetActiveObjectiveID");

	APushBombObjective_GetActiveObjectiveID_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BB7C0
//		Name   -> Function Pavlov.PushBombObjective.CleanupDestroyFX
//		Flags  -> (Final, Native, Protected)
void APushBombObjective::CleanupDestroyFX()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.CleanupDestroyFX");

	APushBombObjective_CleanupDestroyFX_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AA610
//		Name   -> Function Pavlov.PushBombObjective.BombExplosion_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
void APushBombObjective::BombExplosion_Multi()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.BombExplosion_Multi");

	APushBombObjective_BombExplosion_Multi_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB750
//		Name   -> Function Pavlov.PushBombObjective.BombExplosion
//		Flags  -> (Final, Native, Public)
void APushBombObjective::BombExplosion()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.BombExplosion");

	APushBombObjective_BombExplosion_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB730
//		Name   -> Function Pavlov.PushBombObjective.BombDefused
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void APushBombObjective::BombDefused()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.BombDefused");

	APushBombObjective_BombDefused_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BB6A0
//		Name   -> Function Pavlov.PushBombObjective.AttachPushBomb_Multi
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		class APushBomb*                                   PushBomb                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushBombObjective::AttachPushBomb_Multi(class APushBomb* PushBomb)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushBombObjective.AttachPushBomb_Multi");

	APushBombObjective_AttachPushBomb_Multi_Params params {};
	params.PushBomb = PushBomb;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C0650
//		Name   -> Function Pavlov.PushLoadout.UpdateLoadouts
//		Flags  -> (Final, Native, Public)
void APushLoadout::UpdateLoadouts()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.UpdateLoadouts");

	APushLoadout_UpdateLoadouts_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C0510
//		Name   -> Function Pavlov.PushLoadout.SpawnLoadoutEquipment
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       LoadoutSlot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLoadout::SpawnLoadoutEquipment(const struct FName& LoadoutSlot, class APavlovPawn* PavPawn, int ObjectiveId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.SpawnLoadoutEquipment");

	APushLoadout_SpawnLoadoutEquipment_Params params {};
	params.LoadoutSlot = LoadoutSlot;
	params.PavPawn = PavPawn;
	params.ObjectiveId = ObjectiveId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C0270
//		Name   -> Function Pavlov.PushLoadout.SetTeamId
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                LoadoutTeamId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLoadout::SetTeamId(int LoadoutTeamId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.SetTeamId");

	APushLoadout_SetTeamId_Params params {};
	params.LoadoutTeamId = LoadoutTeamId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C00B0
//		Name   -> Function Pavlov.PushLoadout.SetLockerAvailability
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                LoadoutIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                NumOfLoadoutsAvailable                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                MaxLoadouts                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLoadout::SetLockerAvailability(int LoadoutIndex, int NumOfLoadoutsAvailable, int MaxLoadouts)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.SetLockerAvailability");

	APushLoadout_SetLockerAvailability_Params params {};
	params.LoadoutIndex = LoadoutIndex;
	params.NumOfLoadoutsAvailable = NumOfLoadoutsAvailable;
	params.MaxLoadouts = MaxLoadouts;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BFB70
//		Name   -> Function Pavlov.PushLoadout.PlayerLoadoutTaken
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bTPToPlay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLoadout::PlayerLoadoutTaken(class APavlovPawn* PavPawn, bool bTPToPlay)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.PlayerLoadoutTaken");

	APushLoadout_PlayerLoadoutTaken_Params params {};
	params.PavPawn = PavPawn;
	params.bTPToPlay = bTPToPlay;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF7C0
//		Name   -> Function Pavlov.PushLoadout.OnRep_Loadouts
//		Flags  -> (Final, Native, Public)
void APushLoadout::OnRep_Loadouts()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.OnRep_Loadouts");

	APushLoadout_OnRep_Loadouts_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.PushLoadout.IsAttackersRoom
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLoadout::IsAttackersRoom()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.IsAttackersRoom");

	APushLoadout_IsAttackersRoom_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BF4F0
//		Name   -> Function Pavlov.PushLoadout.InitializePushLoadout
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlov_PushLoadoutProxy*                    LoadoutProxy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bWW2Items                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLoadout::InitializePushLoadout(class APavlov_PushLoadoutProxy* LoadoutProxy, bool bWW2Items)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.InitializePushLoadout");

	APushLoadout_InitializePushLoadout_Params params {};
	params.LoadoutProxy = LoadoutProxy;
	params.bWW2Items = bWW2Items;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF100
//		Name   -> Function Pavlov.PushLoadout.GetLootLocker
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                LootLockerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APushLootLocker*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APushLootLocker* APushLoadout::GetLootLocker(int LootLockerIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.GetLootLocker");

	APushLoadout_GetLootLocker_Params params {};
	params.LootLockerIndex = LootLockerIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BF040
//		Name   -> Function Pavlov.PushLoadout.GetLockerSpawnTransform
//		Flags  -> (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		int                                                LockerNum                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform APushLoadout::GetLockerSpawnTransform(int LockerNum)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.GetLockerSpawnTransform");

	APushLoadout_GetLockerSpawnTransform_Params params {};
	params.LockerNum = LockerNum;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEFD0
//		Name   -> Function Pavlov.PushLoadout.GetLoadoutSpawnTransform
//		Flags  -> (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform APushLoadout::GetLoadoutSpawnTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.GetLoadoutSpawnTransform");

	APushLoadout_GetLoadoutSpawnTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEE70
//		Name   -> Function Pavlov.PushLoadout.GetLoadoutByName
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       LoadoutId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FPushLoadoutEquipment                       LoadoutEquipment                                           (Parm, OutParm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLoadout::GetLoadoutByName(const struct FName& LoadoutId, struct FPushLoadoutEquipment* LoadoutEquipment)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.GetLoadoutByName");

	APushLoadout_GetLoadoutByName_Params params {};
	params.LoadoutId = LoadoutId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (LoadoutEquipment != nullptr)
		*LoadoutEquipment = params.LoadoutEquipment;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEB90
//		Name   -> Function Pavlov.PushLoadout.DoesPlayerHaveLoadout
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLoadout::DoesPlayerHaveLoadout(class APavlovPawn* PavPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.DoesPlayerHaveLoadout");

	APushLoadout_DoesPlayerHaveLoadout_Params params {};
	params.PavPawn = PavPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEB00
//		Name   -> Function Pavlov.PushLoadout.DeleteUnusedLockers
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		int                                                CurrentLockers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLoadout::DeleteUnusedLockers(int CurrentLockers)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLoadout.DeleteUnusedLockers");

	APushLoadout_DeleteUnusedLockers_Params params {};
	params.CurrentLockers = CurrentLockers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C0440
//		Name   -> Function Pavlov.PushLootLocker.SetupMesh
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		struct FName                                       ItemName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USkeletalMeshComponent*                      SKComp                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLootLocker::SetupMesh(const struct FName& ItemName, class USkeletalMeshComponent* SKComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.SetupMesh");

	APushLootLocker_SetupMesh_Params params {};
	params.ItemName = ItemName;
	params.SKComp = SKComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C01B0
//		Name   -> Function Pavlov.PushLootLocker.SetNumOfLoadoutsAvailable
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                NumAvailable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                MaxLoadouts                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLootLocker::SetNumOfLoadoutsAvailable(int NumAvailable, int MaxLoadouts)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.SetNumOfLoadoutsAvailable");

	APushLootLocker_SetNumOfLoadoutsAvailable_Params params {};
	params.NumAvailable = NumAvailable;
	params.MaxLoadouts = MaxLoadouts;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF7A0
//		Name   -> Function Pavlov.PushLootLocker.OnRep_LoadoutCount
//		Flags  -> (Final, Native, Public)
void APushLootLocker::OnRep_LoadoutCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.OnRep_LoadoutCount");

	APushLootLocker_OnRep_LoadoutCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x0020E7C0
//		Name   -> Function Pavlov.PushLootLocker.OnLockerStateChanged
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bOpen                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void APushLootLocker::OnLockerStateChanged(bool bOpen)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.OnLockerStateChanged");

	APushLootLocker_OnLockerStateChanged_Params params {};
	params.bOpen = bOpen;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF250
//		Name   -> Function Pavlov.PushLootLocker.GrabLocker
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLootLocker::GrabLocker(class APavlovPawn* PavPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.GrabLocker");

	APushLootLocker_GrabLocker_Params params {};
	params.PavPawn = PavPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEFA0
//		Name   -> Function Pavlov.PushLootLocker.GetLoadoutRoom
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APushLoadout*                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APushLoadout* APushLootLocker::GetLoadoutRoom()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.GetLoadoutRoom");

	APushLootLocker_GetLoadoutRoom_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BE9E0
//		Name   -> Function Pavlov.PushLootLocker.CanGrabLocker
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool APushLootLocker::CanGrabLocker()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushLootLocker.CanGrabLocker");

	APushLootLocker_CanGrabLocker_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C0670
//		Name   -> Function Pavlov.PushManagerComponent.UpdateOOBGracePeriod
//		Flags  -> (Final, Native, Protected)
void UPushManagerComponent::UpdateOOBGracePeriod()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.UpdateOOBGracePeriod");

	UPushManagerComponent_UpdateOOBGracePeriod_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C0610
//		Name   -> Function Pavlov.PushManagerComponent.SwappedSides
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void UPushManagerComponent::SwappedSides()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.SwappedSides");

	UPushManagerComponent_SwappedSides_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C03C0
//		Name   -> Function Pavlov.PushManagerComponent.SetWinCondition
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EPushWinCondition                           PushWinCondition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushManagerComponent::SetWinCondition(Pavlov_EPushWinCondition PushWinCondition)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.SetWinCondition");

	UPushManagerComponent_SetWinCondition_Params params {};
	params.PushWinCondition = PushWinCondition;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C02F0
//		Name   -> Function Pavlov.PushManagerComponent.SetTickets
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bAttackers                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Tickets                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPushManagerComponent::SetTickets(bool bAttackers, int Tickets)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.SetTickets");

	UPushManagerComponent_SetTickets_Params params {};
	params.bAttackers = bAttackers;
	params.Tickets = Tickets;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BFFB0
//		Name   -> Function Pavlov.PushManagerComponent.SetGracePeriod
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              GraceTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushManagerComponent::SetGracePeriod(float GraceTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.SetGracePeriod");

	UPushManagerComponent_SetGracePeriod_Params params {};
	params.GraceTime = GraceTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BFEB0
//		Name   -> Function Pavlov.PushManagerComponent.SetActiveObjectiveId
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushManagerComponent::SetActiveObjectiveId(int ObjectiveId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.SetActiveObjectiveId");

	UPushManagerComponent_SetActiveObjectiveId_Params params {};
	params.ObjectiveId = ObjectiveId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BFD40
//		Name   -> Function Pavlov.PushManagerComponent.RemoveTicket
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bAttackers                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPushManagerComponent::RemoveTicket(bool bAttackers)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.RemoveTicket");

	UPushManagerComponent_RemoveTicket_Params params {};
	params.bAttackers = bAttackers;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BF5C0
//		Name   -> Function Pavlov.PushManagerComponent.IsSpawnGracePeriod
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UPushManagerComponent::IsSpawnGracePeriod()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.IsSpawnGracePeriod");

	UPushManagerComponent_IsSpawnGracePeriod_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BF300
//		Name   -> Function Pavlov.PushManagerComponent.InitializePush
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ObjectiveId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                AttackTickets                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                DefendTickets                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                MaxAttackTickets                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                WaveTickets                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APushLoadout*                                Team0LoadoutRoom                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APushLoadout*                                Team1LoadoutRoom                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushManagerComponent::InitializePush(int ObjectiveId, int AttackTickets, int DefendTickets, int MaxAttackTickets, int WaveTickets, class APushLoadout* Team0LoadoutRoom, class APushLoadout* Team1LoadoutRoom)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.InitializePush");

	UPushManagerComponent_InitializePush_Params params {};
	params.ObjectiveId = ObjectiveId;
	params.AttackTickets = AttackTickets;
	params.DefendTickets = DefendTickets;
	params.MaxAttackTickets = MaxAttackTickets;
	params.WaveTickets = WaveTickets;
	params.Team0LoadoutRoom = Team0LoadoutRoom;
	params.Team1LoadoutRoom = Team1LoadoutRoom;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BEA10
//		Name   -> Function Pavlov.PushManagerComponent.CheckLoadoutAvailability
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void UPushManagerComponent::CheckLoadoutAvailability()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.CheckLoadoutAvailability");

	UPushManagerComponent_CheckLoadoutAvailability_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BE9B0
//		Name   -> Function Pavlov.PushManagerComponent.AwardAttackersTicketsPerWave
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UPushManagerComponent::AwardAttackersTicketsPerWave()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushManagerComponent.AwardAttackersTicketsPerWave");

	UPushManagerComponent_AwardAttackersTicketsPerWave_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C0630
//		Name   -> Function Pavlov.PushPlayerDataComponent.TakePushSnapshot
//		Flags  -> (Final, Native, Public)
void UPushPlayerDataComponent::TakePushSnapshot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.TakePushSnapshot");

	UPushPlayerDataComponent_TakePushSnapshot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C0030
//		Name   -> Function Pavlov.PushPlayerDataComponent.SetHipSlotType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		PavlovProxy_EPushHipSlot                           HipSlot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::SetHipSlotType(PavlovProxy_EPushHipSlot HipSlot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.SetHipSlotType");

	UPushPlayerDataComponent_SetHipSlotType_Params params {};
	params.HipSlot = HipSlot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BFF30
//		Name   -> Function Pavlov.PushPlayerDataComponent.SetDialogAsset
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
//		class UPushPlayerDialog*                           Dialog                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::SetDialogAsset(class UPushPlayerDialog* Dialog)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.SetDialogAsset");

	UPushPlayerDataComponent_SetDialogAsset_Params params {};
	params.Dialog = Dialog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BFDF0
//		Name   -> Function Pavlov.PushPlayerDataComponent.RestorePushSnapshot
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FName                                       FallbackWeapon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPushPlayerStateComponent*                   PushPlayerStateComp                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::RestorePushSnapshot(const struct FName& FallbackWeapon, class UPushPlayerStateComponent* PushPlayerStateComp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.RestorePushSnapshot");

	UPushPlayerDataComponent_RestorePushSnapshot_Params params {};
	params.FallbackWeapon = FallbackWeapon;
	params.PushPlayerStateComp = PushPlayerStateComp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BFDD0
//		Name   -> Function Pavlov.PushPlayerDataComponent.RespawnHipSlot
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::RespawnHipSlot()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.RespawnHipSlot");

	UPushPlayerDataComponent_RespawnHipSlot_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BFA40
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayDialogReplicated
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
//		Pavlov_EPushDialog                                 PushDialog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::PlayDialogReplicated(Pavlov_EPushDialog PushDialog)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayDialogReplicated");

	UPushPlayerDataComponent_PlayDialogReplicated_Params params {};
	params.PushDialog = PushDialog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF9B0
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayDialogFromHead
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USoundCue*                                   DialogCue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UAudioComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAudioComponent* UPushPlayerDataComponent::PlayDialogFromHead(class USoundCue* DialogCue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayDialogFromHead");

	UPushPlayerDataComponent_PlayDialogFromHead_Params params {};
	params.DialogCue = DialogCue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BFAF0
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayDialog_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		Pavlov_EPushDialog                                 PushDialog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::PlayDialog_Multi(Pavlov_EPushDialog PushDialog)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayDialog_Multi");

	UPushPlayerDataComponent_PlayDialog_Multi_Params params {};
	params.PushDialog = PushDialog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF930
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayDialog
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EPushDialog                                 PushDialog                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::PlayDialog(Pavlov_EPushDialog PushDialog)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayDialog");

	UPushPlayerDataComponent_PlayDialog_Params params {};
	params.PushDialog = PushDialog;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF8A0
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayChantResponse_Multi
//		Flags  -> (Net, Native, Event, NetMulticast, Protected)
// Parameters:
//		int                                                ChantIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::PlayChantResponse_Multi(int ChantIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayChantResponse_Multi");

	UPushPlayerDataComponent_PlayChantResponse_Multi_Params params {};
	params.ChantIndex = ChantIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF880
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayChantResponse
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::PlayChantResponse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayChantResponse");

	UPushPlayerDataComponent_PlayChantResponse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF800
//		Name   -> Function Pavlov.PushPlayerDataComponent.PlayChant
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                ChantIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::PlayChant(int ChantIndex)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.PlayChant");

	UPushPlayerDataComponent_PlayChant_Params params {};
	params.ChantIndex = ChantIndex;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF7E0
//		Name   -> Function Pavlov.PushPlayerDataComponent.OwnerKilled
//		Flags  -> (Final, Native, Public)
void UPushPlayerDataComponent::OwnerKilled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OwnerKilled");

	UPushPlayerDataComponent_OwnerKilled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF780
//		Name   -> Function Pavlov.PushPlayerDataComponent.OnRep_HipSlotType
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::OnRep_HipSlotType()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OnRep_HipSlotType");

	UPushPlayerDataComponent_OnRep_HipSlotType_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF760
//		Name   -> Function Pavlov.PushPlayerDataComponent.OnOwnerDamaged
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::OnOwnerDamaged()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OnOwnerDamaged");

	UPushPlayerDataComponent_OnOwnerDamaged_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF740
//		Name   -> Function Pavlov.PushPlayerDataComponent.OnLowHealth
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::OnLowHealth()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OnLowHealth");

	UPushPlayerDataComponent_OnLowHealth_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF720
//		Name   -> Function Pavlov.PushPlayerDataComponent.OnLowAmmo
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::OnLowAmmo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OnLowAmmo");

	UPushPlayerDataComponent_OnLowAmmo_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF6A0
//		Name   -> Function Pavlov.PushPlayerDataComponent.OnGrenadeCooked
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AGrenade*                                    Grenade                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::OnGrenadeCooked(class AGrenade* Grenade)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OnGrenadeCooked");

	UPushPlayerDataComponent_OnGrenadeCooked_Params params {};
	params.Grenade = Grenade;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF680
//		Name   -> Function Pavlov.PushPlayerDataComponent.OnBufferTimeComplete
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::OnBufferTimeComplete()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.OnBufferTimeComplete");

	UPushPlayerDataComponent_OnBufferTimeComplete_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF5F0
//		Name   -> Function Pavlov.PushPlayerDataComponent.LoadDialogAsset
//		Flags  -> (Native, Event, Protected, BlueprintEvent)
// Parameters:
//		struct FName                                       PlayerSkin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::LoadDialogAsset(const struct FName& PlayerSkin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.LoadDialogAsset");

	UPushPlayerDataComponent_LoadDialogAsset_Params params {};
	params.PlayerSkin = PlayerSkin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00217B10
//		Name   -> Function Pavlov.PushPlayerDataComponent.Init_Client
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetClient)
void UPushPlayerDataComponent::Init_Client()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.Init_Client");

	UPushPlayerDataComponent_Init_Client_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF2E0
//		Name   -> Function Pavlov.PushPlayerDataComponent.HipSlotUsed
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void UPushPlayerDataComponent::HipSlotUsed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.HipSlotUsed");

	UPushPlayerDataComponent_HipSlotUsed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BF1A0
//		Name   -> Function Pavlov.PushPlayerDataComponent.GetPushPlayerData
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPushPlayerDataComponent*                    ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UPushPlayerDataComponent* UPushPlayerDataComponent::STATIC_GetPushPlayerData(class APawn* Pawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.GetPushPlayerData");

	UPushPlayerDataComponent_GetPushPlayerData_Params params {};
	params.Pawn = Pawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006BEA30
//		Name   -> Function Pavlov.PushPlayerDataComponent.ClearQueue
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bFadeCurrent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bChantInQueue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UPushPlayerDataComponent::ClearQueue(bool bFadeCurrent, bool bChantInQueue)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.ClearQueue");

	UPushPlayerDataComponent_ClearQueue_Params params {};
	params.bFadeCurrent = bFadeCurrent;
	params.bChantInQueue = bChantInQueue;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006BE990
//		Name   -> Function Pavlov.PushPlayerDataComponent.AskForMeds
//		Flags  -> (Final, Native, Protected)
void UPushPlayerDataComponent::AskForMeds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.PushPlayerDataComponent.AskForMeds");

	UPushPlayerDataComponent_AskForMeds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB840
//		Name   -> Function Pavlov.ShootingRangeTargetComponent.TargetHit
//		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults)
// Parameters:
//		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void UShootingRangeTargetComponent::TargetHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ShootingRangeTargetComponent.TargetHit");

	UShootingRangeTargetComponent_TargetHit_Params params {};
	params.HitComponent = HitComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.NormalImpulse = NormalImpulse;
	params.Hit = Hit;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB6C0
//		Name   -> Function Pavlov.SkinFamily.SkinIntToSkinFamily
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                SkinFamilyInt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_ESkinFamily                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_ESkinFamily USkinFamily::STATIC_SkinIntToSkinFamily(int SkinFamilyInt)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SkinFamily.SkinIntToSkinFamily");

	USkinFamily_SkinIntToSkinFamily_Params params {};
	params.SkinFamilyInt = SkinFamilyInt;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CB600
//		Name   -> Function Pavlov.SkinFamily.SkinFamilyToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_ESkinFamily                                 SkinFamily                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString USkinFamily::STATIC_SkinFamilyToString(Pavlov_ESkinFamily SkinFamily)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SkinFamily.SkinFamilyToString");

	USkinFamily_SkinFamilyToString_Params params {};
	params.SkinFamily = SkinFamily;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CB580
//		Name   -> Function Pavlov.SkinFamily.SkinFamilyToInt
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_ESkinFamily                                 SkinFamily                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int USkinFamily::STATIC_SkinFamilyToInt(Pavlov_ESkinFamily SkinFamily)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SkinFamily.SkinFamilyToInt");

	USkinFamily_SkinFamilyToInt_Params params {};
	params.SkinFamily = SkinFamily;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CB4C0
//		Name   -> Function Pavlov.SkinFamily.SkinFamilyIdToString
//		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                SkinFamilyId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString USkinFamily::STATIC_SkinFamilyIdToString(int SkinFamilyId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SkinFamily.SkinFamilyIdToString");

	USkinFamily_SkinFamilyIdToString_Params params {};
	params.SkinFamilyId = SkinFamilyId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CB3F0
//		Name   -> Function Pavlov.SoundMixingSettings.SetVolumeByChannelName
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void USoundMixingSettings::SetVolumeByChannelName(const struct FName& Name, float Volume)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.SetVolumeByChannelName");

	USoundMixingSettings_SetVolumeByChannelName_Params params {};
	params.Name = Name;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB320
//		Name   -> Function Pavlov.SoundMixingSettings.SetVolumeByChannelIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void USoundMixingSettings::SetVolumeByChannelIndex(int Index, float Volume)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.SetVolumeByChannelIndex");

	USoundMixingSettings_SetVolumeByChannelIndex_Params params {};
	params.Index = Index;
	params.Volume = Volume;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CADD0
//		Name   -> Function Pavlov.SoundMixingSettings.Save
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USoundMixingSettings::Save()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.Save");

	USoundMixingSettings_Save_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CADB0
//		Name   -> Function Pavlov.SoundMixingSettings.RestoreDefaults
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USoundMixingSettings::RestoreDefaults()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.RestoreDefaults");

	USoundMixingSettings_RestoreDefaults_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CA8C0
//		Name   -> Function Pavlov.SoundMixingSettings.Load
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USoundMixingSettings::Load()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.Load");

	USoundMixingSettings_Load_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CA6D0
//		Name   -> Function Pavlov.SoundMixingSettings.GetVolumeByChannelName
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       Name                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float USoundMixingSettings::GetVolumeByChannelName(const struct FName& Name)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.GetVolumeByChannelName");

	USoundMixingSettings_GetVolumeByChannelName_Params params {};
	params.Name = Name;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA640
//		Name   -> Function Pavlov.SoundMixingSettings.GetVolumeByChannelIndex
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                Index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float USoundMixingSettings::GetVolumeByChannelIndex(int Index)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.GetVolumeByChannelIndex");

	USoundMixingSettings_GetVolumeByChannelIndex_Params params {};
	params.Index = Index;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9510
//		Name   -> Function Pavlov.SoundMixingSettings.ApplyAndSave
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USoundMixingSettings::ApplyAndSave()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.ApplyAndSave");

	USoundMixingSettings_ApplyAndSave_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C94F0
//		Name   -> Function Pavlov.SoundMixingSettings.Apply
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void USoundMixingSettings::Apply()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SoundMixingSettings.Apply");

	USoundMixingSettings_Apply_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.SpectatorTag.OnFadeOut
//		Flags  -> (Event, Public, BlueprintEvent)
void ASpectatorTag::OnFadeOut()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SpectatorTag.OnFadeOut");

	ASpectatorTag_OnFadeOut_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C9E80
//		Name   -> Function Pavlov.SpectatorTag.GetPlayerState
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class APavlovPlayerState*                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPlayerState* ASpectatorTag::GetPlayerState()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SpectatorTag.GetPlayerState");

	ASpectatorTag_GetPlayerState_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.SpectatorTVCamera.OnAttachedToFocusedPawn
//		Flags  -> (Event, Public, BlueprintEvent)
void ASpectatorTVCamera::OnAttachedToFocusedPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SpectatorTVCamera.OnAttachedToFocusedPawn");

	ASpectatorTVCamera_OnAttachedToFocusedPawn_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.SpectatorTVCamera.GetSceneCapture
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class USceneCaptureComponent2D*                    ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USceneCaptureComponent2D* ASpectatorTVCamera::GetSceneCapture()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SpectatorTVCamera.GetSceneCapture");

	ASpectatorTVCamera_GetSceneCapture_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9A70
//		Name   -> Function Pavlov.SpectatorTVCamera.Cycle
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void ASpectatorTVCamera::Cycle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SpectatorTVCamera.Cycle");

	ASpectatorTVCamera_Cycle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C9470
//		Name   -> Function Pavlov.SpectatorTVCamera.AddYawInput
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void ASpectatorTVCamera::AddYawInput(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SpectatorTVCamera.AddYawInput");

	ASpectatorTVCamera_AddYawInput_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB1F0
//		Name   -> Function Pavlov.StatsManager.SetStat
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EPlayerStats                                OptionStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Amount                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStatsManager::SetStat(const struct FString& UniqueID, Pavlov_EPlayerStats OptionStat, int Amount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.SetStat");

	UStatsManager_SetStat_Params params {};
	params.UniqueID = UniqueID;
	params.OptionStat = OptionStat;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CAD00
//		Name   -> Function Pavlov.StatsManager.PostStats
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FString                                     URL                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UStatsManager::PostStats(const struct FString& URL)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.PostStats");

	UStatsManager_PostStats_Params params {};
	params.URL = URL;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA860
//		Name   -> Function Pavlov.StatsManager.HasAuthority
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UStatsManager::HasAuthority()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.HasAuthority");

	UStatsManager_HasAuthority_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA770
//		Name   -> Function Pavlov.StatsManager.GetXPForStat
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		Pavlov_EPlayerStats                                StatType                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Amount                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UStatsManager::GetXPForStat(Pavlov_EPlayerStats StatType, int Amount)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetXPForStat");

	UStatsManager_GetXPForStat_Params params {};
	params.StatType = StatType;
	params.Amount = Amount;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA5B0
//		Name   -> Function Pavlov.StatsManager.GetTransformedEloRatings
//		Flags  -> (Final, Native, Public)
// Parameters:
//		float                                              Elo                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UStatsManager::GetTransformedEloRatings(float Elo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetTransformedEloRatings");

	UStatsManager_GetTransformedEloRatings_Params params {};
	params.Elo = Elo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA580
//		Name   -> Function Pavlov.StatsManager.GetStatsAsJson
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class UJsonUtilsObj*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UJsonUtilsObj* UStatsManager::GetStatsAsJson()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetStatsAsJson");

	UStatsManager_GetStatsAsJson_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA100
//		Name   -> Function Pavlov.StatsManager.GetProbabilityOfWinning
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              CurrentElo                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              OpponentElo                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UStatsManager::GetProbabilityOfWinning(float CurrentElo, float OpponentElo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetProbabilityOfWinning");

	UStatsManager_GetProbabilityOfWinning_Params params {};
	params.CurrentElo = CurrentElo;
	params.OpponentElo = OpponentElo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9EB0
//		Name   -> Function Pavlov.StatsManager.GetPlayerStats
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FPlayerStats                                PlayerStatistics                                           (Parm, OutParm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UStatsManager::GetPlayerStats(const struct FString& UniqueID, struct FPlayerStats* PlayerStatistics)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetPlayerStats");

	UStatsManager_GetPlayerStats_Params params {};
	params.UniqueID = UniqueID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PlayerStatistics != nullptr)
		*PlayerStatistics = params.PlayerStatistics;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9FE0
//		Name   -> Function Pavlov.StatsManager.GetPlayersStats
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		TMap<struct FString, struct FPlayerStats>          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TMap<struct FString, struct FPlayerStats> UStatsManager::GetPlayersStats()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetPlayersStats");

	UStatsManager_GetPlayersStats_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9D80
//		Name   -> Function Pavlov.StatsManager.GetAllPlayersStats
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<struct FPlayerStats>                        PlayersStatistics                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UStatsManager::GetAllPlayersStats(TArray<struct FPlayerStats>* PlayersStatistics)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.GetAllPlayersStats");

	UStatsManager_GetAllPlayersStats_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (PlayersStatistics != nullptr)
		*PlayersStatistics = params.PlayersStatistics;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9C00
//		Name   -> Function Pavlov.StatsManager.FindOrCreatePlayerStats
//		Flags  -> (Final, Native, Public)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FPlayerStats                                ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
struct FPlayerStats UStatsManager::FindOrCreatePlayerStats(const struct FString& UniqueID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.FindOrCreatePlayerStats");

	UStatsManager_FindOrCreatePlayerStats_Params params {};
	params.UniqueID = UniqueID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9BC0
//		Name   -> Function Pavlov.StatsManager.DumpStatsToLog
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void UStatsManager::DumpStatsToLog()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.DumpStatsToLog");

	UStatsManager_DumpStatsToLog_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C9780
//		Name   -> Function Pavlov.StatsManager.CalulateTeamElos
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TMap<struct FString, float>                        InTeam0Elos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
//		TMap<struct FString, float>                        InTeam1Elos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
//		TMap<struct FString, float>                        OutTeam0Elos                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
//		TMap<struct FString, float>                        OutTeam1Elos                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
//		bool                                               bTeam0Won                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStatsManager::CalulateTeamElos(TMap<struct FString, float> InTeam0Elos, TMap<struct FString, float> InTeam1Elos, TMap<struct FString, float>* OutTeam0Elos, TMap<struct FString, float>* OutTeam1Elos, bool bTeam0Won)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.CalulateTeamElos");

	UStatsManager_CalulateTeamElos_Params params {};
	params.InTeam0Elos = InTeam0Elos;
	params.InTeam1Elos = InTeam1Elos;
	params.bTeam0Won = bTeam0Won;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OutTeam0Elos != nullptr)
		*OutTeam0Elos = params.OutTeam0Elos;
	if (OutTeam1Elos != nullptr)
		*OutTeam1Elos = params.OutTeam1Elos;

}


// Function:
//		Offset -> 0x006C9650
//		Name   -> Function Pavlov.StatsManager.CalculateNewElo
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              CurrentElo                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              OpponentElo                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bWin                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UStatsManager::CalculateNewElo(float CurrentElo, float OpponentElo, bool bWin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.CalculateNewElo");

	UStatsManager_CalculateNewElo_Params params {};
	params.CurrentElo = CurrentElo;
	params.OpponentElo = OpponentElo;
	params.bWin = bWin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9630
//		Name   -> Function Pavlov.StatsManager.AwardPlayersXP
//		Flags  -> (Final, Native, Private)
void UStatsManager::AwardPlayersXP()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.AwardPlayersXP");

	UStatsManager_AwardPlayersXP_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C9530
//		Name   -> Function Pavlov.StatsManager.AverageElos
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		TArray<float>                                      Elos                                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UStatsManager::AverageElos(TArray<float> Elos)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.AverageElos");

	UStatsManager_AverageElos_Params params {};
	params.Elos = Elos;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C93B0
//		Name   -> Function Pavlov.StatsManager.AddStatByUniqueId
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EPlayerStats                                OptionStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStatsManager::AddStatByUniqueId(class APavlovPlayerState* PlayerState, Pavlov_EPlayerStats OptionStat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.AddStatByUniqueId");

	UStatsManager_AddStatByUniqueId_Params params {};
	params.PlayerState = PlayerState;
	params.OptionStat = OptionStat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C92F0
//		Name   -> Function Pavlov.StatsManager.AddStat
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		class APavlovPlayerState*                          PavPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EPlayerStats                                OptionStat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStatsManager::AddStat(class APavlovPlayerState* PavPlayerState, Pavlov_EPlayerStats OptionStat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.AddStat");

	UStatsManager_AddStat_Params params {};
	params.PavPlayerState = PavPlayerState;
	params.OptionStat = OptionStat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C9250
//		Name   -> Function Pavlov.StatsManager.AddPlayer
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     UniqueID                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStatsManager::AddPlayer(const struct FString& UniqueID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StatsManager.AddPlayer");

	UStatsManager_AddPlayer_Params params {};
	params.UniqueID = UniqueID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00691650
//		Name   -> Function Pavlov.StencilSuppressionComponent.OwnerKilled
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      Owner                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStencilSuppressionComponent::OwnerKilled(class AActor* Owner)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StencilSuppressionComponent.OwnerKilled");

	UStencilSuppressionComponent_OwnerKilled_Params params {};
	params.Owner = Owner;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEF20
//		Name   -> Function Pavlov.StencilSuppressionComponent.OnMenuOpened
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UStencilSuppressionComponent::OnMenuOpened(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.StencilSuppressionComponent.OnMenuOpened");

	UStencilSuppressionComponent_OnMenuOpened_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEB00
//		Name   -> Function Pavlov.SurfaceFXAsset.GetVehicleSound
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class USoundCue*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundCue* USurfaceFXAsset::GetVehicleSound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SurfaceFXAsset.GetVehicleSound");

	USurfaceFXAsset_GetVehicleSound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CEAD0
//		Name   -> Function Pavlov.SurfaceFXAsset.GetVehicleParticleSystem
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class UParticleSystem*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UParticleSystem* USurfaceFXAsset::GetVehicleParticleSystem()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SurfaceFXAsset.GetVehicleParticleSystem");

	USurfaceFXAsset_GetVehicleParticleSystem_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE930
//		Name   -> Function Pavlov.SurfaceFXAsset.GetSoundBySurfaceType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EPhysicalSurface>               SurfaceType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USoundCue*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USoundCue* USurfaceFXAsset::GetSoundBySurfaceType(TEnumAsByte<Engine_EPhysicalSurface> SurfaceType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SurfaceFXAsset.GetSoundBySurfaceType");

	USurfaceFXAsset_GetSoundBySurfaceType_Params params {};
	params.SurfaceType = SurfaceType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE870
//		Name   -> Function Pavlov.SurfaceFXAsset.GetParticleBySurfaceType
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		TEnumAsByte<Engine_EPhysicalSurface>               SurfaceType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UParticleSystem*                             ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UParticleSystem* USurfaceFXAsset::GetParticleBySurfaceType(TEnumAsByte<Engine_EPhysicalSurface> SurfaceType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.SurfaceFXAsset.GetParticleBySurfaceType");

	USurfaceFXAsset_GetParticleBySurfaceType_Params params {};
	params.SurfaceType = SurfaceType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE7E0
//		Name   -> Function Pavlov.TankInteriorAnimInstance.GetMPH
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float UTankInteriorAnimInstance::GetMPH()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TankInteriorAnimInstance.GetMPH");

	UTankInteriorAnimInstance_GetMPH_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CF440
//		Name   -> Function Pavlov.TankVehicleMovement.ServerUpdateTankSteeringWheel
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
//		float                                              LeftThrustInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              RightThrustInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              UpdateThrottle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UTankVehicleMovement::ServerUpdateTankSteeringWheel(float LeftThrustInput, float RightThrustInput, float UpdateThrottle)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TankVehicleMovement.ServerUpdateTankSteeringWheel");

	UTankVehicleMovement_ServerUpdateTankSteeringWheel_Params params {};
	params.LeftThrustInput = LeftThrustInput;
	params.RightThrustInput = RightThrustInput;
	params.UpdateThrottle = UpdateThrottle;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF340
//		Name   -> Function Pavlov.TankVehicleMovement.ServerUpdateTankInput
//		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
//		float                                              LeftTrustInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              RightTrustInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UTankVehicleMovement::ServerUpdateTankInput(float LeftTrustInput, float RightTrustInput)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TankVehicleMovement.ServerUpdateTankInput");

	UTankVehicleMovement_ServerUpdateTankInput_Params params {};
	params.LeftTrustInput = LeftTrustInput;
	params.RightTrustInput = RightTrustInput;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CE760
//		Name   -> Function Pavlov.TankVehicleMovement.DriverLeft
//		Flags  -> (Final, Native, Public)
void UTankVehicleMovement::DriverLeft()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TankVehicleMovement.DriverLeft");

	UTankVehicleMovement_DriverLeft_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CE7B0
//		Name   -> Function Pavlov.ToolTip.GetFadeScalar
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AToolTip::GetFadeScalar()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ToolTip.GetFadeScalar");

	AToolTip_GetFadeScalar_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CFC20
//		Name   -> Function Pavlov.TTTGameInfo.TTTFlushKarma
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::TTTFlushKarma()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.TTTFlushKarma");

	UTTTGameInfo_TTTFlushKarma_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CFB80
//		Name   -> Function Pavlov.TTTGameInfo.TTTAlwaysEnableSkinMenu
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::TTTAlwaysEnableSkinMenu(bool bEnable)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.TTTAlwaysEnableSkinMenu");

	UTTTGameInfo_TTTAlwaysEnableSkinMenu_Params params {};
	params.bEnable = bEnable;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CF940
//		Name   -> Function Pavlov.TTTGameInfo.SetTTTPlayerRole
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          PavPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     TTTRole                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::SetTTTPlayerRole(class APavlovPlayerState* PavPlayerState, const struct FString& TTTRole)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.SetTTTPlayerRole");

	UTTTGameInfo_SetTTTPlayerRole_Params params {};
	params.PavPlayerState = PavPlayerState;
	params.TTTRole = TTTRole;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CF870
//		Name   -> Function Pavlov.TTTGameInfo.SetTTTKarma
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          PavPlayerState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Karma                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::SetTTTKarma(class APavlovPlayerState* PavPlayerState, int Karma)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.SetTTTKarma");

	UTTTGameInfo_SetTTTKarma_Params params {};
	params.PavPlayerState = PavPlayerState;
	params.Karma = Karma;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CF320
//		Name   -> Function Pavlov.TTTGameInfo.RetryInit
//		Flags  -> (Final, Native, Protected)
void UTTTGameInfo::RetryInit()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.RetryInit");

	UTTTGameInfo_RetryInit_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF260
//		Name   -> Function Pavlov.TTTGameInfo.PauseTTTTimer
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::PauseTTTTimer(bool bPaused)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.PauseTTTTimer");

	UTTTGameInfo_PauseTTTTimer_Params params {};
	params.bPaused = bPaused;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.TTTGameInfo.GetTTTPlayerInfo
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APlayerState*                                PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FTTTPlayerInfo                              ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
struct FTTTPlayerInfo UTTTGameInfo::GetTTTPlayerInfo(class APlayerState* PlayerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.GetTTTPlayerInfo");

	UTTTGameInfo_GetTTTPlayerInfo_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE9C0
//		Name   -> Function Pavlov.TTTGameInfo.GetTTTKarma
//		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          PlayerState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Karma                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::GetTTTKarma(class APavlovPlayerState* PlayerState, int* Karma)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.GetTTTKarma");

	UTTTGameInfo_GetTTTKarma_Params params {};
	params.PlayerState = PlayerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (Karma != nullptr)
		*Karma = params.Karma;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.TTTGameInfo.GetAllTTTPlayersInfo
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TArray<struct FTTTPlayerInfo>                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FTTTPlayerInfo> UTTTGameInfo::GetAllTTTPlayersInfo()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.GetAllTTTPlayersInfo");

	UTTTGameInfo_GetAllTTTPlayersInfo_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE780
//		Name   -> Function Pavlov.TTTGameInfo.EndTTTRound
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTTTGameInfo::EndTTTRound()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.TTTGameInfo.EndTTTRound");

	UTTTGameInfo_EndTTTRound_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CFC50
//		Name   -> Function Pavlov.Tutorial.TerminateToolTip
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UTutorial::TerminateToolTip(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Tutorial.TerminateToolTip");

	UTutorial_TerminateToolTip_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CFA70
//		Name   -> Function Pavlov.Tutorial.ShowToolTip
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UObject*                                     Context                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     ContextLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UTutorial::ShowToolTip(const struct FName& ID, class UObject* Context, const struct FVector& ContextLocation)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Tutorial.ShowToolTip");

	UTutorial_ShowToolTip_Params params {};
	params.ID = ID;
	params.Context = Context;
	params.ContextLocation = ContextLocation;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF300
//		Name   -> Function Pavlov.Tutorial.Reset
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UTutorial::Reset()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Tutorial.Reset");

	UTutorial_Reset_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEDA0
//		Name   -> Function Pavlov.Tutorial.MarkToolTipAsComplete
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UTutorial::MarkToolTipAsComplete(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Tutorial.MarkToolTipAsComplete");

	UTutorial_MarkToolTipAsComplete_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEC20
//		Name   -> Function Pavlov.Tutorial.IsToolTipCompleted
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UTutorial::IsToolTipCompleted(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Tutorial.IsToolTipCompleted");

	UTutorial_IsToolTipCompleted_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CEAA0
//		Name   -> Function Pavlov.Tutorial.GetToolTipInstanceCount
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UTutorial::GetToolTipInstanceCount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Tutorial.GetToolTipInstanceCount");

	UTutorial_GetToolTipInstanceCount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CFA50
//		Name   -> Function Pavlov.UIManager.ShowMenuUniverse
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UUIManager::ShowMenuUniverse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.ShowMenuUniverse");

	UUIManager_ShowMenuUniverse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CFA30
//		Name   -> Function Pavlov.UIManager.ShowMatchmaking
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UUIManager::ShowMatchmaking()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.ShowMatchmaking");

	UUIManager_ShowMatchmaking_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF7B0
//		Name   -> Function Pavlov.UIManager.SetSideInterface
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EUserInterfaceType                          PrimaryInterface                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		Pavlov_EUserInterfaceType                          NewInterface                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::SetSideInterface(Pavlov_EUserInterfaceType PrimaryInterface, Pavlov_EUserInterfaceType NewInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.SetSideInterface");

	UUIManager_SetSideInterface_Params params {};
	params.PrimaryInterface = PrimaryInterface;
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF720
//		Name   -> Function Pavlov.UIManager.SetMenuUniverse
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::SetMenuUniverse(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.SetMenuUniverse");

	UUIManager_SetMenuUniverse_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF690
//		Name   -> Function Pavlov.UIManager.SetMatchmakingMode
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::SetMatchmakingMode(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.SetMatchmakingMode");

	UUIManager_SetMatchmakingMode_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF610
//		Name   -> Function Pavlov.UIManager.SetInterface
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EUserInterfaceType                          NewInterface                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::SetInterface(Pavlov_EUserInterfaceType NewInterface)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.SetInterface");

	UUIManager_SetInterface_Params params {};
	params.NewInterface = NewInterface;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF1B0
//		Name   -> Function Pavlov.UIManager.OnVotePromptCommit
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UUIManager::OnVotePromptCommit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnVotePromptCommit");

	UUIManager_OnVotePromptCommit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF190
//		Name   -> Function Pavlov.UIManager.OnPinPromptDestroyed
//		Flags  -> (Final, Native, Protected)
void UUIManager::OnPinPromptDestroyed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnPinPromptDestroyed");

	UUIManager_OnPinPromptDestroyed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF0E0
//		Name   -> Function Pavlov.UIManager.OnPinPromptCommit
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		struct FModalCommitParams                          Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UUIManager::OnPinPromptCommit(const struct FModalCommitParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnPinPromptCommit");

	UUIManager_OnPinPromptCommit_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CF0C0
//		Name   -> Function Pavlov.UIManager.OnPartyCreated
//		Flags  -> (Final, Native, Protected)
void UUIManager::OnPartyCreated()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnPartyCreated");

	UUIManager_OnPartyCreated_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEFB0
//		Name   -> Function Pavlov.UIManager.OnOnlineError
//		Flags  -> (Final, Native, Protected, HasOutParms)
// Parameters:
//		Pavlov_EOnlineError                                Error                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FText                                       ErrorMessage                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UUIManager::OnOnlineError(Pavlov_EOnlineError Error, const struct FText& ErrorMessage)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnOnlineError");

	UUIManager_OnOnlineError_Params params {};
	params.Error = Error;
	params.ErrorMessage = ErrorMessage;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEEA0
//		Name   -> Function Pavlov.UIManager.OnMatchmakingStatusChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		Pavlov_EMatchmakingStatus                          Status                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::OnMatchmakingStatusChanged(Pavlov_EMatchmakingStatus Status)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnMatchmakingStatusChanged");

	UUIManager_OnMatchmakingStatusChanged_Params params {};
	params.Status = Status;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEE20
//		Name   -> Function Pavlov.UIManager.OnJoinServerStateChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		Pavlov_EOnlineJoinServerState                      JoinServerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::OnJoinServerStateChanged(Pavlov_EOnlineJoinServerState JoinServerState)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.OnJoinServerStateChanged");

	UUIManager_OnJoinServerStateChanged_Params params {};
	params.JoinServerState = JoinServerState;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CECC0
//		Name   -> Function Pavlov.UIManager.K2_CreateModalWithParams
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FUICreateModalParams                        Params                                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
//		class UModal*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UModal* UUIManager::K2_CreateModalWithParams(const struct FUICreateModalParams& Params)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.K2_CreateModalWithParams");

	UUIManager_K2_CreateModalWithParams_Params params {};
	params.Params = Params;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CEC00
//		Name   -> Function Pavlov.UIManager.IsMenuUniverseEnabled
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UUIManager::IsMenuUniverseEnabled()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.IsMenuUniverseEnabled");

	UUIManager_IsMenuUniverseEnabled_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CEBC0
//		Name   -> Function Pavlov.UIManager.HideMenuUniverse
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UUIManager::HideMenuUniverse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.HideMenuUniverse");

	UUIManager_HideMenuUniverse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CEB30
//		Name   -> Function Pavlov.UIManager.HideMatchmaking
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UUIManager::HideMatchmaking(bool bForce)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.HideMatchmaking");

	UUIManager_HideMatchmaking_Params params {};
	params.bForce = bForce;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CE900
//		Name   -> Function Pavlov.UIManager.GetSideInterface
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		Pavlov_EUserInterfaceType                          ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
Pavlov_EUserInterfaceType UUIManager::GetSideInterface()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.GetSideInterface");

	UUIManager_GetSideInterface_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE840
//		Name   -> Function Pavlov.UIManager.GetModalInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UModal*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UModal* UUIManager::GetModalInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.GetModalInstance");

	UUIManager_GetModalInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE810
//		Name   -> Function Pavlov.UIManager.GetMenuUniverse
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class AMenuUniverse*                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AMenuUniverse* UUIManager::GetMenuUniverse()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.GetMenuUniverse");

	UUIManager_GetMenuUniverse_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE740
//		Name   -> Function Pavlov.UIManager.DismissMOTD
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UUIManager::DismissMOTD()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.DismissMOTD");

	UUIManager_DismissMOTD_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CE620
//		Name   -> Function Pavlov.UIManager.CreateModalMessageBox
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FText                                       Message                                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
//		Pavlov_EModalMessageBoxType                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UModal*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UModal* UUIManager::CreateModalMessageBox(const struct FText& Message, Pavlov_EModalMessageBoxType Type)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.CreateModalMessageBox");

	UUIManager_CreateModalMessageBox_Params params {};
	params.Message = Message;
	params.Type = Type;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE500
//		Name   -> Function Pavlov.UIManager.CreateModal
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UClass*                                      ModalClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ModalContent                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bCreateView                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UModal*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UModal* UUIManager::CreateModal(class UClass* ModalClass, const struct FString& ModalContent, bool bCreateView)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.CreateModal");

	UUIManager_CreateModal_Params params {};
	params.ModalClass = ModalClass;
	params.ModalContent = ModalContent;
	params.bCreateView = bCreateView;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CE4E0
//		Name   -> Function Pavlov.UIManager.CreateConnectSpinnerModal
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UUIManager::CreateConnectSpinnerModal()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.CreateConnectSpinnerModal");

	UUIManager_CreateConnectSpinnerModal_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CE4C0
//		Name   -> Function Pavlov.UIManager.ClearModalInstance
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UUIManager::ClearModalInstance()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.UIManager.ClearModalInstance");

	UUIManager_ClearModalInstance_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D34A0
//		Name   -> Function Pavlov.VehicleBumper.OnBumperOverlap
//		Flags  -> (Final, Native, Public, HasOutParms)
// Parameters:
//		class UPrimitiveComponent*                         OverlappedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void UVehicleBumper::OnBumperOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleBumper.OnBumperOverlap");

	UVehicleBumper_OnBumperOverlap_Params params {};
	params.OverlappedComponent = OverlappedComponent;
	params.OtherActor = OtherActor;
	params.OtherComp = OtherComp;
	params.OtherBodyIndex = OtherBodyIndex;
	params.bFromSweep = bFromSweep;
	params.SweepResult = SweepResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3170
//		Name   -> Function Pavlov.VehicleBumper.GetVehicle
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class APavlovVehicle*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovVehicle* UVehicleBumper::GetVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleBumper.GetVehicle");

	UVehicleBumper_GetVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D2E40
//		Name   -> Function Pavlov.VehicleBumper.ClearBumper
//		Flags  -> (Final, Native, Public)
void UVehicleBumper::ClearBumper()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleBumper.ClearBumper");

	UVehicleBumper_ClearBumper_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D44C0
//		Name   -> Function Pavlov.VehicleInterior.ZoomScopeFOV
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ZoomDirection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::ZoomScopeFOV(float ZoomDirection)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.ZoomScopeFOV");

	AVehicleInterior_ZoomScopeFOV_Params params {};
	params.ZoomDirection = ZoomDirection;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D4000
//		Name   -> Function Pavlov.VehicleInterior.SetupVehicleInterior
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class APavlovVehicle*                              Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UVehicleOccupant*                            VehicleOccupant                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::SetupVehicleInterior(class APavlovVehicle* Vehicle, int Seat, class UVehicleOccupant* VehicleOccupant)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.SetupVehicleInterior");

	AVehicleInterior_SetupVehicleInterior_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;
	params.VehicleOccupant = VehicleOccupant;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3EF0
//		Name   -> Function Pavlov.VehicleInterior.SetScopeFOV
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              ScopeFOV                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::SetScopeFOV(float ScopeFOV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.SetScopeFOV");

	AVehicleInterior_SetScopeFOV_Params params {};
	params.ScopeFOV = ScopeFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3E60
//		Name   -> Function Pavlov.VehicleInterior.SetScopeActive
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bActive                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::SetScopeActive(bool bActive)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.SetScopeActive");

	AVehicleInterior_SetScopeActive_Params params {};
	params.bActive = bActive;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002A7830
//		Name   -> Function Pavlov.VehicleInterior.PlayFireHaptics
//		Flags  -> (Native, Event, Public, BlueprintEvent)
void AVehicleInterior::PlayFireHaptics()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.PlayFireHaptics");

	AVehicleInterior_PlayFireHaptics_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleInterior.OnScopeExploit
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bExploit                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::OnScopeExploit(bool bExploit)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.OnScopeExploit");

	AVehicleInterior_OnScopeExploit_Params params {};
	params.bExploit = bExploit;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleInterior.OnPassengerChanged
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bEnteredVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::OnPassengerChanged(bool bEnteredVehicle, int Seat, class APavlovPawn* PavPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.OnPassengerChanged");

	AVehicleInterior_OnPassengerChanged_Params params {};
	params.bEnteredVehicle = bEnteredVehicle;
	params.Seat = Seat;
	params.PavPawn = PavPawn;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleInterior.OnInteriorIntialized
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovVehicle*                              Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UVehicleOccupant*                            VehicleOccupant                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::OnInteriorIntialized(class APavlovVehicle* Vehicle, int Seat, class UVehicleOccupant* VehicleOccupant)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.OnInteriorIntialized");

	AVehicleInterior_OnInteriorIntialized_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;
	params.VehicleOccupant = VehicleOccupant;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3280
//		Name   -> Function Pavlov.VehicleInterior.HideActorInScope
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      HideInScope                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleInterior::HideActorInScope(class AActor* HideInScope)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.HideActorInScope");

	AVehicleInterior_HideActorInScope_Params params {};
	params.HideInScope = HideInScope;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D31D0
//		Name   -> Function Pavlov.VehicleInterior.GunnerSocketOverride
//		Flags  -> (Native, Event, Public, HasOutParms, BlueprintEvent)
// Parameters:
//		struct FName                                       OverrideSocket                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool AVehicleInterior::GunnerSocketOverride(struct FName* OverrideSocket)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.GunnerSocketOverride");

	AVehicleInterior_GunnerSocketOverride_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (OverrideSocket != nullptr)
		*OverrideSocket = params.OverrideSocket;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleInterior.GetScopeHiddenActors
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		TArray<class AActor*>                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<class AActor*> AVehicleInterior::GetScopeHiddenActors()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.GetScopeHiddenActors");

	AVehicleInterior_GetScopeHiddenActors_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3070
//		Name   -> Function Pavlov.VehicleInterior.GetScopeFOVAlpha
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AVehicleInterior::GetScopeFOVAlpha()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.GetScopeFOVAlpha");

	AVehicleInterior_GetScopeFOVAlpha_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3040
//		Name   -> Function Pavlov.VehicleInterior.GetScopeFOV
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		float                                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
float AVehicleInterior::GetScopeFOV()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.GetScopeFOV");

	AVehicleInterior_GetScopeFOV_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3010
//		Name   -> Function Pavlov.VehicleInterior.GetSceneCaptureParent
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		class USceneComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USceneComponent* AVehicleInterior::GetSceneCaptureParent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleInterior.GetSceneCaptureParent");

	AVehicleInterior_GetSceneCaptureParent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3F70
//		Name   -> Function Pavlov.VehicleOccupant.SetupInput
//		Flags  -> (Native, Public)
// Parameters:
//		class UInputComponent*                             InputComponent                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant::SetupInput(class UInputComponent* InputComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.SetupInput");

	UVehicleOccupant_SetupInput_Params params {};
	params.InputComponent = InputComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3A60
//		Name   -> Function Pavlov.VehicleOccupant.RetryHideInventory
//		Flags  -> (Final, Native, Protected)
void UVehicleOccupant::RetryHideInventory()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.RetryHideInventory");

	UVehicleOccupant_RetryHideInventory_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D39A0
//		Name   -> Function Pavlov.VehicleOccupant.RemoveVehicleInputServer
//		Flags  -> (Native, Public)
void UVehicleOccupant::RemoveVehicleInputServer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.RemoveVehicleInputServer");

	UVehicleOccupant_RemoveVehicleInputServer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3890
//		Name   -> Function Pavlov.VehicleOccupant.PassengerChanged
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		bool                                               bEnteredVehicle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class APavlovPawn*                                 PavPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant::PassengerChanged(bool bEnteredVehicle, int Seat, class APavlovPawn* PavPawn)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.PassengerChanged");

	UVehicleOccupant_PassengerChanged_Params params {};
	params.bEnteredVehicle = bEnteredVehicle;
	params.Seat = Seat;
	params.PavPawn = PavPawn;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant.OnLeaveVehicle
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UVehicleOccupant::OnLeaveVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.OnLeaveVehicle");

	UVehicleOccupant_OnLeaveVehicle_Params params {};

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant.OnEnteredVehicleClient
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovVehicle*                              Vehicle                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant::OnEnteredVehicleClient(class APavlovVehicle* Vehicle, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.OnEnteredVehicleClient");

	UVehicleOccupant_OnEnteredVehicleClient_Params params {};
	params.Vehicle = Vehicle;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D33F0
//		Name   -> Function Pavlov.VehicleOccupant.LeaveVehicleServer
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
void UVehicleOccupant::LeaveVehicleServer()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.LeaveVehicleServer");

	UVehicleOccupant_LeaveVehicleServer_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D33C0
//		Name   -> Function Pavlov.VehicleOccupant.IsDriver
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UVehicleOccupant::IsDriver()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.IsDriver");

	UVehicleOccupant_IsDriver_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3300
//		Name   -> Function Pavlov.VehicleOccupant.HideInScope
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class AActor*                                      HideActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant::HideInScope(class AActor* HideActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.HideInScope");

	UVehicleOccupant_HideInScope_Params params {};
	params.HideActor = HideActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D31A0
//		Name   -> Function Pavlov.VehicleOccupant.GetVehicle
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APavlovVehicle*                              ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovVehicle* UVehicleOccupant::GetVehicle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.GetVehicle");

	UVehicleOccupant_GetVehicle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D30D0
//		Name   -> Function Pavlov.VehicleOccupant.GetSeatTransform
//		Flags  -> (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FTransform                                  ReturnValue                                                (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
struct FTransform UVehicleOccupant::GetSeatTransform()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.GetSeatTransform");

	UVehicleOccupant_GetSeatTransform_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D30A0
//		Name   -> Function Pavlov.VehicleOccupant.GetSeat
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UVehicleOccupant::GetSeat()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.GetSeat");

	UVehicleOccupant_GetSeat_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00670FF0
//		Name   -> Function Pavlov.VehicleOccupant.GetPawn
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		class APavlovPawn*                                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class APavlovPawn* UVehicleOccupant::GetPawn()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.GetPawn");

	UVehicleOccupant_GetPawn_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D2E60
//		Name   -> Function Pavlov.VehicleOccupant.ClientEnteredVehicle
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		class APavlovVehicle*                              InVehicle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seat                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant::ClientEnteredVehicle(class APavlovVehicle* InVehicle, int Seat)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.ClientEnteredVehicle");

	UVehicleOccupant_ClientEnteredVehicle_Params params {};
	params.InVehicle = InVehicle;
	params.Seat = Seat;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D2E10
//		Name   -> Function Pavlov.VehicleOccupant.CanSendInput
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UVehicleOccupant::CanSendInput()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant.CanSendInput");

	UVehicleOccupant_CanSendInput_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Prototyping.TriggerAxisRight
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Prototyping::TriggerAxisRight(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Prototyping.TriggerAxisRight");

	UVehicleOccupant_Prototyping_TriggerAxisRight_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Prototyping.TriggerAxisLeft
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Prototyping::TriggerAxisLeft(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Prototyping.TriggerAxisLeft");

	UVehicleOccupant_Prototyping_TriggerAxisLeft_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D41F0
//		Name   -> Function Pavlov.VehicleOccupant_Prototyping.ThrottleServer
//		Flags  -> (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Prototyping::ThrottleServer(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Prototyping.ThrottleServer");

	UVehicleOccupant_Prototyping_ThrottleServer_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D4120
//		Name   -> Function Pavlov.VehicleOccupant_Prototyping.SteerServer
//		Flags  -> (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Prototyping::SteerServer(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Prototyping.SteerServer");

	UVehicleOccupant_Prototyping_SteerServer_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Prototyping.MoveX
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Prototyping::MoveX(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Prototyping.MoveX");

	UVehicleOccupant_Prototyping_MoveX_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D4420
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Driver.UpdateMovementInput
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UVehicleOccupant_Tank_Driver::UpdateMovementInput()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Driver.UpdateMovementInput");

	UVehicleOccupant_Tank_Driver_UpdateMovementInput_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Driver.TriggerAxisRight
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Driver::TriggerAxisRight(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Driver.TriggerAxisRight");

	UVehicleOccupant_Tank_Driver_TriggerAxisRight_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Driver.TriggerAxisLeft
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Driver::TriggerAxisLeft(float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Driver.TriggerAxisLeft");

	UVehicleOccupant_Tank_Driver_TriggerAxisLeft_Params params {};
	params.Value = Value;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3140
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Driver.GetTankMovementComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UTankVehicleMovement*                        ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTankVehicleMovement* UVehicleOccupant_Tank_Driver::GetTankMovementComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Driver.GetTankMovementComponent");

	UVehicleOccupant_Tank_Driver_GetTankMovementComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3DD0
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.SetMachineGunRotation
//		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		struct FRotator                                    MGRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Gunner::SetMachineGunRotation(const struct FRotator& MGRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.SetMachineGunRotation");

	UVehicleOccupant_Tank_Gunner_SetMachineGunRotation_Params params {};
	params.MGRot = MGRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3B80
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.ServerSetMGRotation
//		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
//		struct FRotator                                    MGRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Gunner::ServerSetMGRotation(const struct FRotator& MGRot)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.ServerSetMGRotation");

	UVehicleOccupant_Tank_Gunner_ServerSetMGRotation_Params params {};
	params.MGRot = MGRot;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3AA0
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.RightTriggerReleased
//		Flags  -> (Final, Native, Public)
void UVehicleOccupant_Tank_Gunner::RightTriggerReleased()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.RightTriggerReleased");

	UVehicleOccupant_Tank_Gunner_RightTriggerReleased_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3A80
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.RightTriggerPressed
//		Flags  -> (Final, Native, Public)
void UVehicleOccupant_Tank_Gunner::RightTriggerPressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.RightTriggerPressed");

	UVehicleOccupant_Tank_Gunner_RightTriggerPressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.RightTrigger
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bPressed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Gunner::RightTrigger(bool bPressed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.RightTrigger");

	UVehicleOccupant_Tank_Gunner_RightTrigger_Params params {};
	params.bPressed = bPressed;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3480
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.LeftTriggerReleased
//		Flags  -> (Final, Native, Public)
void UVehicleOccupant_Tank_Gunner::LeftTriggerReleased()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.LeftTriggerReleased");

	UVehicleOccupant_Tank_Gunner_LeftTriggerReleased_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3440
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.LeftTriggerPressed
//		Flags  -> (Final, Native, Public)
void UVehicleOccupant_Tank_Gunner::LeftTriggerPressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.LeftTriggerPressed");

	UVehicleOccupant_Tank_Gunner_LeftTriggerPressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Gunner.LeftTrigger
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bPressed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Gunner::LeftTrigger(bool bPressed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Gunner.LeftTrigger");

	UVehicleOccupant_Tank_Gunner_LeftTrigger_Params params {};
	params.bPressed = bPressed;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D43A0
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.TurretZoomInput
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		float                                              Input                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::TurretZoomInput(float Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.TurretZoomInput");

	UVehicleOccupant_Tank_Turret_TurretZoomInput_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D4320
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.TurretYawInput
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		float                                              Input                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::TurretYawInput(float Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.TurretYawInput");

	UVehicleOccupant_Tank_Turret_TurretYawInput_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D42A0
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.TurretPitchInput
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		float                                              Input                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::TurretPitchInput(float Input)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.TurretPitchInput");

	UVehicleOccupant_Tank_Turret_TurretPitchInput_Params params {};
	params.Input = Input;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3C50
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.ServerSetTurretRotation
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
//		struct FVector2D                                   TurretRot                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              ScopeFOV                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::ServerSetTurretRotation(const struct FVector2D& TurretRot, float ScopeFOV)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.ServerSetTurretRotation");

	UVehicleOccupant_Tank_Turret_ServerSetTurretRotation_Params params {};
	params.TurretRot = TurretRot;
	params.ScopeFOV = ScopeFOV;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3460
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.RightTriggerPressed
//		Flags  -> (Final, Native, Protected)
void UVehicleOccupant_Tank_Turret::RightTriggerPressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.RightTriggerPressed");

	UVehicleOccupant_Tank_Turret_RightTriggerPressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x003F34F0
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.OnAdvancedVehicleSettingsChanged
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bUseAdvanced                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::OnAdvancedVehicleSettingsChanged(bool bUseAdvanced)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.OnAdvancedVehicleSettingsChanged");

	UVehicleOccupant_Tank_Turret_OnAdvancedVehicleSettingsChanged_Params params {};
	params.bUseAdvanced = bUseAdvanced;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3460
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.LeftTriggerPressed
//		Flags  -> (Final, Native, Protected)
void UVehicleOccupant_Tank_Turret::LeftTriggerPressed()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.LeftTriggerPressed");

	UVehicleOccupant_Tank_Turret_LeftTriggerPressed_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D2D90
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.AddTurretYaw
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::AddTurretYaw(float Yaw)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.AddTurretYaw");

	UVehicleOccupant_Tank_Turret_AddTurretYaw_Params params {};
	params.Yaw = Yaw;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D2D10
//		Name   -> Function Pavlov.VehicleOccupant_Tank_Turret.AddTurretPitch
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVehicleOccupant_Tank_Turret::AddTurretPitch(float Pitch)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleOccupant_Tank_Turret.AddTurretPitch");

	UVehicleOccupant_Tank_Turret_AddTurretPitch_Params params {};
	params.Pitch = Pitch;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D4440
//		Name   -> Function Pavlov.VehicleSpawner.VehicleDestroyed
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		class AActor*                                      DestroyedActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleSpawner::VehicleDestroyed(class AActor* DestroyedActor)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleSpawner.VehicleDestroyed");

	AVehicleSpawner_VehicleDestroyed_Params params {};
	params.DestroyedActor = DestroyedActor;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D41D0
//		Name   -> Function Pavlov.VehicleSpawner.StopVehicleSpawner
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void AVehicleSpawner::StopVehicleSpawner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleSpawner.StopVehicleSpawner");

	AVehicleSpawner_StopVehicleSpawner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D4100
//		Name   -> Function Pavlov.VehicleSpawner.StartVehicleSpawner
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
void AVehicleSpawner::StartVehicleSpawner()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleSpawner.StartVehicleSpawner");

	AVehicleSpawner_StartVehicleSpawner_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3810
//		Name   -> Function Pavlov.VehicleSpawner.OnGetVehicleClass
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class UClass*                                      VehicleClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVehicleSpawner::OnGetVehicleClass(class UClass* VehicleClass)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VehicleSpawner.OnGetVehicleClass");

	AVehicleSpawner_OnGetVehicleClass_Params params {};
	params.VehicleClass = VehicleClass;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3740
//		Name   -> Function Pavlov.VoiceComponent.OnEnvelopeValue
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class USoundWave*                                  PlayingSoundWave                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              Value                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVoiceComponent::OnEnvelopeValue(class USoundWave* PlayingSoundWave, float Value)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceComponent.OnEnvelopeValue");

	UVoiceComponent_OnEnvelopeValue_Params params {};
	params.PlayingSoundWave = PlayingSoundWave;
	params.Value = Value;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4A80
//		Name   -> Function Pavlov.Rocket.OnDetonation
//		Flags  -> (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
//		struct FTransform                                  DecalTransform                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
void ARocket::OnDetonation(const struct FTransform& DecalTransform)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Rocket.OnDetonation");

	ARocket_OnDetonation_Params params {};
	params.DecalTransform = DecalTransform;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x004E1EF0
//		Name   -> Function Pavlov.Scoreboard.OnScriptingReady
//		Flags  -> (Final, Native, Private)
void AScoreboard::OnScriptingReady()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Scoreboard.OnScriptingReady");

	AScoreboard_OnScriptingReady_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x002AEA40
//		Name   -> Function Pavlov.Scoreboard.OnReadyForBindings
//		Flags  -> (Final, Native, Private)
void AScoreboard::OnReadyForBindings()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Scoreboard.OnReadyForBindings");

	AScoreboard_OnReadyForBindings_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4560
//		Name   -> Function Pavlov.Scoreboard.OnAvatarUpdated
//		Flags  -> (Final, Native, Private)
// Parameters:
//		struct FString                                     ProductId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     PlatformId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture2D*                                  AvatarTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AScoreboard::OnAvatarUpdated(const struct FString& ProductId, const struct FString& PlatformId, class UTexture2D* AvatarTexture)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Scoreboard.OnAvatarUpdated");

	AScoreboard_OnAvatarUpdated_Params params {};
	params.ProductId = ProductId;
	params.PlatformId = PlatformId;
	params.AvatarTexture = AvatarTexture;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C53A0
//		Name   -> Function Pavlov.ServerBrowser.Update
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bUpdatePings                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowser::Update(bool bUpdatePings)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowser.Update");

	UServerBrowser_Update_Params params {};
	params.bUpdatePings = bUpdatePings;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4D40
//		Name   -> Function Pavlov.ServerBrowser.OrderServerListByPlayerCount
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bDescending                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowser::OrderServerListByPlayerCount(bool bDescending)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowser.OrderServerListByPlayerCount");

	UServerBrowser_OrderServerListByPlayerCount_Params params {};
	params.bDescending = bDescending;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4080
//		Name   -> Function Pavlov.ServerBrowser.GenerateSortedCombinedList
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		TArray<struct FPavlovServerInfo>                   LobbyDetails                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
//		bool                                               bAddServerList                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bDescending                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		TArray<struct FCombinedServerList>                 ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
TArray<struct FCombinedServerList> UServerBrowser::GenerateSortedCombinedList(TArray<struct FPavlovServerInfo> LobbyDetails, bool bAddServerList, bool bDescending)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowser.GenerateSortedCombinedList");

	UServerBrowser_GenerateSortedCombinedList_Params params {};
	params.LobbyDetails = LobbyDetails;
	params.bAddServerList = bAddServerList;
	params.bDescending = bDescending;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C56C0
//		Name   -> Function Pavlov.ServerBrowserV2.UpdateRegionFilters
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EOnlineRegion                               Region                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bAdd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::UpdateRegionFilters(Pavlov_EOnlineRegion Region, bool bAdd)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.UpdateRegionFilters");

	UServerBrowserV2_UpdateRegionFilters_Params params {};
	params.Region = Region;
	params.bAdd = bAdd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5590
//		Name   -> Function Pavlov.ServerBrowserV2.UpdateGMFilters
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Filter                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bAdd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::UpdateGMFilters(const struct FString& Filter, bool bAdd)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.UpdateGMFilters");

	UServerBrowserV2_UpdateGMFilters_Params params {};
	params.Filter = Filter;
	params.bAdd = bAdd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5500
//		Name   -> Function Pavlov.ServerBrowserV2.UpdateFavoritesOnly
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::UpdateFavoritesOnly(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.UpdateFavoritesOnly");

	UServerBrowserV2_UpdateFavoritesOnly_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5430
//		Name   -> Function Pavlov.ServerBrowserV2.UpdateFavoriteServer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UServerContainer*                            ServerContainer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bAdd                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::UpdateFavoriteServer(class UServerContainer* ServerContainer, bool bAdd)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.UpdateFavoriteServer");

	UServerBrowserV2_UpdateFavoriteServer_Params params {};
	params.ServerContainer = ServerContainer;
	params.bAdd = bAdd;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5380
//		Name   -> Function Pavlov.ServerBrowserV2.SortServerList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UServerBrowserV2::SortServerList()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.SortServerList");

	UServerBrowserV2_SortServerList_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5300
//		Name   -> Function Pavlov.ServerBrowserV2.SetServerSortType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EServerSortType                             SortType                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::SetServerSortType(Pavlov_EServerSortType SortType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.SetServerSortType");

	UServerBrowserV2_SetServerSortType_Params params {};
	params.SortType = SortType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5280
//		Name   -> Function Pavlov.ServerBrowserV2.SetServerSearchType
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EServerSearchType                           SearchType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::SetServerSearchType(Pavlov_EServerSearchType SearchType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.SetServerSearchType");

	UServerBrowserV2_SetServerSearchType_Params params {};
	params.SearchType = SearchType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C50D0
//		Name   -> Function Pavlov.ServerBrowserV2.SetHidePinLockedServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bHide                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::SetHidePinLockedServers(bool bHide)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.SetHidePinLockedServers");

	UServerBrowserV2_SetHidePinLockedServers_Params params {};
	params.bHide = bHide;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C5040
//		Name   -> Function Pavlov.ServerBrowserV2.SetHideFullServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bHide                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::SetHideFullServers(bool bHide)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.SetHideFullServers");

	UServerBrowserV2_SetHideFullServers_Params params {};
	params.bHide = bHide;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4FB0
//		Name   -> Function Pavlov.ServerBrowserV2.SetHideEmptyServers
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bHide                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::SetHideEmptyServers(bool bHide)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.SetHideEmptyServers");

	UServerBrowserV2_SetHideEmptyServers_Params params {};
	params.bHide = bHide;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4E70
//		Name   -> Function Pavlov.ServerBrowserV2.RefreshList
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UServerBrowserV2::RefreshList()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.RefreshList");

	UServerBrowserV2_RefreshList_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4CA0
//		Name   -> Function Pavlov.ServerBrowserV2.OnLobbyUpdateComplete
//		Flags  -> (Final, Native, Private)
void UServerBrowserV2::OnLobbyUpdateComplete()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.OnLobbyUpdateComplete");

	UServerBrowserV2_OnLobbyUpdateComplete_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4BF0
//		Name   -> Function Pavlov.ServerBrowserV2.OnLobbyListUpdate
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		struct FLobbySearchResult                          SearchResult                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UServerBrowserV2::OnLobbyListUpdate(const struct FLobbySearchResult& SearchResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.OnLobbyListUpdate");

	UServerBrowserV2_OnLobbyListUpdate_Params params {};
	params.SearchResult = SearchResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4930
//		Name   -> Function Pavlov.ServerBrowserV2.OnCommunityServerPingListComplete
//		Flags  -> (Final, Native, Private)
void UServerBrowserV2::OnCommunityServerPingListComplete()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.OnCommunityServerPingListComplete");

	UServerBrowserV2_OnCommunityServerPingListComplete_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4690
//		Name   -> Function Pavlov.ServerBrowserV2.OnCommunityServerPingComplete
//		Flags  -> (Final, Native, Private)
// Parameters:
//		struct FServerStatusInfo                           StatusInfo                                                 (Parm, NativeAccessSpecifierPublic)
//		struct FString                                     IPAddress                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerBrowserV2::OnCommunityServerPingComplete(const struct FServerStatusInfo& StatusInfo, const struct FString& IPAddress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.OnCommunityServerPingComplete");

	UServerBrowserV2_OnCommunityServerPingComplete_Params params {};
	params.StatusInfo = StatusInfo;
	params.IPAddress = IPAddress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C4430
//		Name   -> Function Pavlov.ServerBrowserV2.JoinServer
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UServerContainer*                            ServerContainer                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Pin                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerBrowserV2::JoinServer(class UServerContainer* ServerContainer, const struct FString& Pin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.JoinServer");

	UServerBrowserV2_JoinServer_Params params {};
	params.ServerContainer = ServerContainer;
	params.Pin = Pin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C43A0
//		Name   -> Function Pavlov.ServerBrowserV2.HasRegionFilter
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		Pavlov_EOnlineRegion                               Region                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerBrowserV2::HasRegionFilter(Pavlov_EOnlineRegion Region)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.HasRegionFilter");

	UServerBrowserV2_HasRegionFilter_Params params {};
	params.Region = Region;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C42F0
//		Name   -> Function Pavlov.ServerBrowserV2.GetServerContainerById
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UServerContainer*                            ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UServerContainer* UServerBrowserV2::GetServerContainerById(const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerBrowserV2.GetServerContainerById");

	UServerBrowserV2_GetServerContainerById_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CB9F0
//		Name   -> Function Pavlov.ServerConnector.TickServerConnect
//		Flags  -> (Final, Native, Protected)
void UServerConnector::TickServerConnect()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerConnector.TickServerConnect");

	UServerConnector_TickServerConnect_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB800
//		Name   -> Function Pavlov.ServerConnector.StartConnection
//		Flags  -> (Final, Native, Protected)
void UServerConnector::StartConnection()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerConnector.StartConnection");

	UServerConnector_StartConnection_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CACE0
//		Name   -> Function Pavlov.ServerConnector.OnStatusTimeout
//		Flags  -> (Final, Native, Protected)
void UServerConnector::OnStatusTimeout()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerConnector.OnStatusTimeout");

	UServerConnector_OnStatusTimeout_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CAA40
//		Name   -> Function Pavlov.ServerConnector.OnStatusReceived
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		struct FServerStatusInfo                           StatusInfo                                                 (Parm, NativeAccessSpecifierPublic)
//		struct FString                                     IPAddress                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerConnector::OnStatusReceived(const struct FServerStatusInfo& StatusInfo, const struct FString& IPAddress)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerConnector.OnStatusReceived");

	UServerConnector_OnStatusReceived_Params params {};
	params.StatusInfo = StatusInfo;
	params.IPAddress = IPAddress;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CA910
//		Name   -> Function Pavlov.ServerConnector.OnServerConnectMapDownloaded
//		Flags  -> (Final, Native, Protected)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerConnector::OnServerConnectMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerConnector.OnServerConnectMapDownloaded");

	UServerConnector_OnServerConnectMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006C9BE0
//		Name   -> Function Pavlov.ServerConnector.FailedToConnect
//		Flags  -> (Final, Native, Protected)
void UServerConnector::FailedToConnect()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerConnector.FailedToConnect");

	UServerConnector_FailedToConnect_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CBA10
//		Name   -> Function Pavlov.ServerContainer.UpdatePing
//		Flags  -> (Final, Native, Public)
// Parameters:
//		int                                                NewPing                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UServerContainer::UpdatePing(int NewPing)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerContainer.UpdatePing");

	UServerContainer_UpdatePing_Params params {};
	params.NewPing = NewPing;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB820
//		Name   -> Function Pavlov.ServerStatusHelper.Stop
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UServerStatusHelper::Stop()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.Stop");

	UServerStatusHelper_Stop_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006CB080
//		Name   -> Function Pavlov.ServerStatusHelper.SendStringToAddress
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     SendString                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Address                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerStatusHelper::SendStringToAddress(const struct FString& SendString, const struct FString& Address)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.SendStringToAddress");

	UServerStatusHelper_SendStringToAddress_Params params {};
	params.SendString = SendString;
	params.Address = Address;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CAF10
//		Name   -> Function Pavlov.ServerStatusHelper.SendServerStatusUpdate
//		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Pin                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Address                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerStatusHelper::SendServerStatusUpdate(const struct FString& Pin, const struct FString& Address)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.SendServerStatusUpdate");

	UServerStatusHelper_SendServerStatusUpdate_Params params {};
	params.Pin = Pin;
	params.Address = Address;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CADF0
//		Name   -> Function Pavlov.ServerStatusHelper.SendDataToAddress
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FServerStatusMsg                            SendMsg                                                    (Parm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerStatusHelper::SendDataToAddress(const struct FServerStatusMsg& SendMsg)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.SendDataToAddress");

	UServerStatusHelper_SendDataToAddress_Params params {};
	params.SendMsg = SendMsg;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA890
//		Name   -> Function Pavlov.ServerStatusHelper.IsConnected
//		Flags  -> (Final, Native, Public)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerStatusHelper::IsConnected()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.IsConnected");

	UServerStatusHelper_IsConnected_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA3D0
//		Name   -> Function Pavlov.ServerStatusHelper.GetServerStatusInfo
//		Flags  -> (Final, Native, Public, HasOutParms)
// Parameters:
//		struct FString                                     Pin                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FServerStatusInfo                           StatusInfo                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerStatusHelper::GetServerStatusInfo(const struct FString& Pin, struct FServerStatusInfo* StatusInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.GetServerStatusInfo");

	UServerStatusHelper_GetServerStatusInfo_Params params {};
	params.Pin = Pin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

	if (StatusInfo != nullptr)
		*StatusInfo = params.StatusInfo;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CA1F0
//		Name   -> Function Pavlov.ServerStatusHelper.GetServerInfo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     Address                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Port                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     Pin                                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		float                                              AutoCloseTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UServerStatusHelper::GetServerInfo(const struct FString& Address, int Port, const struct FString& Pin, float AutoCloseTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.GetServerInfo");

	UServerStatusHelper_GetServerInfo_Params params {};
	params.Address = Address;
	params.Port = Port;
	params.Pin = Pin;
	params.AutoCloseTime = AutoCloseTime;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006C9A90
//		Name   -> Function Pavlov.ServerStatusHelper.DataToString
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<unsigned char>                              Data                                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
//		struct FString                                     ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FString UServerStatusHelper::DataToString(TArray<unsigned char> Data)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.ServerStatusHelper.DataToString");

	UServerStatusHelper_DataToString_Params params {};
	params.Data = Data;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006CB740
//		Name   -> Function Pavlov.Shell.SpawnHitEffect
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
void AShell::SpawnHitEffect(const struct FHitResult& HitResult)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Shell.SpawnHitEffect");

	AShell_SpawnHitEffect_Params params {};
	params.HitResult = HitResult;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3AC0
//		Name   -> Function Pavlov.VoiceRouter.ServerOnVoice
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
//		struct FPavlovVoicePacket                          VoicePacket                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
void AVoiceRouter::ServerOnVoice(const struct FPavlovVoicePacket& VoicePacket)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceRouter.ServerOnVoice");

	AVoiceRouter_ServerOnVoice_Params params {};
	params.VoicePacket = VoicePacket;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3690
//		Name   -> Function Pavlov.VoiceRouter.OnEncodedVoiceData
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		TArray<unsigned char>                              EncodedVoiceData                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
void AVoiceRouter::OnEncodedVoiceData(TArray<unsigned char> EncodedVoiceData)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceRouter.OnEncodedVoiceData");

	AVoiceRouter_OnEncodedVoiceData_Params params {};
	params.EncodedVoiceData = EncodedVoiceData;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D2F30
//		Name   -> Function Pavlov.VoiceRouter.ClientOnVoiceBunch
//		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
//		struct FVoicePacketBunch                           VoiceBunch                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
void AVoiceRouter::ClientOnVoiceBunch(const struct FVoicePacketBunch& VoiceBunch)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceRouter.ClientOnVoiceBunch");

	AVoiceRouter_ClientOnVoiceBunch_Params params {};
	params.VoiceBunch = VoiceBunch;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D3D40
//		Name   -> Function Pavlov.VoiceSource.SetCapture
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVoiceSource::SetCapture(bool bEnabled)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceSource.SetCapture");

	UVoiceSource_SetCapture_Params params {};
	params.bEnabled = bEnabled;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D39C0
//		Name   -> Function Pavlov.VoiceSource.ResetCaptureDevice
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     DeviceName                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UVoiceSource::ResetCaptureDevice(const struct FString& DeviceName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceSource.ResetCaptureDevice");

	UVoiceSource_ResetCaptureDevice_Params params {};
	params.DeviceName = DeviceName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D33A0
//		Name   -> Function Pavlov.VoiceSource.IsCapturing
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UVoiceSource::IsCapturing()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceSource.IsCapturing");

	UVoiceSource_IsCapturing_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D3380
//		Name   -> Function Pavlov.VoiceSource.IsBroadcasting
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UVoiceSource::IsBroadcasting()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.VoiceSource.IsBroadcasting");

	UVoiceSource_IsBroadcasting_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8B80
//		Name   -> Function Pavlov.Vote.OnVoteEnded
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		bool                                               bSucceeded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVote::OnVoteEnded(bool bSucceeded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Vote.OnVoteEnded");

	AVote_OnVoteEnded_Params params {};
	params.bSucceeded = bSucceeded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D88A0
//		Name   -> Function Pavlov.Vote.MulticastOnVoteEnded
//		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
//		bool                                               bSucceeded                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AVote::MulticastOnVoteEnded(bool bSucceeded)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Vote.MulticastOnVoteEnded");

	AVote_MulticastOnVoteEnded_Params params {};
	params.bSucceeded = bSucceeded;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8530
//		Name   -> Function Pavlov.Vote.GetVotePromptMessage
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		struct FText                                       ReturnValue                                                (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
struct FText AVote::GetVotePromptMessage()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Vote.GetVotePromptMessage");

	AVote_GetVotePromptMessage_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8A80
//		Name   -> Function Pavlov.Watch.OnKillfeedEntry
//		Flags  -> (Final, Native, Private, HasOutParms)
// Parameters:
//		struct FKillfeedEntry                              NewEntry                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
void UWatch::OnKillfeedEntry(const struct FKillfeedEntry& NewEntry)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Watch.OnKillfeedEntry");

	UWatch_OnKillfeedEntry_Params params {};
	params.NewEntry = NewEntry;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x00968520
//		Name   -> Function Pavlov.Watch.OnKillConfirmationPush
//		Flags  -> (Event, Public, BlueprintEvent)
// Parameters:
//		class APavlovPlayerState*                          Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWatch::OnKillConfirmationPush(class APavlovPlayerState* Victim)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Watch.OnKillConfirmationPush");

	UWatch_OnKillConfirmationPush_Params params {};
	params.Victim = Victim;

	auto flags = fn->FunctionFlags;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D85B0
//		Name   -> Function Pavlov.Watch.GetWatchAttachComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class USceneComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class USceneComponent* UWatch::GetWatchAttachComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Watch.GetWatchAttachComponent");

	UWatch_GetWatchAttachComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8350
//		Name   -> Function Pavlov.Waypoint.GetNextWaypointTo
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class AWaypoint*                                   TargetWaypoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		int                                                Seed                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AWaypoint*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AWaypoint* AWaypoint::GetNextWaypointTo(class AWaypoint* TargetWaypoint, int Seed)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Waypoint.GetNextWaypointTo");

	AWaypoint_GetNextWaypointTo_Params params {};
	params.TargetWaypoint = TargetWaypoint;
	params.Seed = Seed;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D81C0
//		Name   -> Function Pavlov.Waypoint.GetClosestWaypoint
//		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
//		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bOnlyLeaf                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bUseNavMesh                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class AWaypoint*                                   ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class AWaypoint* AWaypoint::STATIC_GetClosestWaypoint(class UObject* WorldContextObject, const struct FVector& Location, bool bOnlyLeaf, bool bUseNavMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Waypoint.GetClosestWaypoint");

	AWaypoint_GetClosestWaypoint_Params params {};
	params.WorldContextObject = WorldContextObject;
	params.Location = Location;
	params.bOnlyLeaf = bOnlyLeaf;
	params.bUseNavMesh = bUseNavMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D84F0
//		Name   -> Function Pavlov.WeaponFilterData.GetRandomRifle
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* UWeaponFilterData::GetRandomRifle()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WeaponFilterData.GetRandomRifle");

	UWeaponFilterData_GetRandomRifle_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D84B0
//		Name   -> Function Pavlov.WeaponFilterData.GetRandomPistol
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UClass*                                      ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UClass* UWeaponFilterData::GetRandomPistol()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WeaponFilterData.GetRandomPistol");

	UWeaponFilterData_GetRandomPistol_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D91D0
//		Name   -> Function Pavlov.Workshop.Vote
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               bUp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::Vote(const struct FName& ID, bool bUp)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.Vote");

	UWorkshop_Vote_Params params {};
	params.ID = ID;
	params.bUp = bUp;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D9080
//		Name   -> Function Pavlov.Workshop.Unsubscribe
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::Unsubscribe(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.Unsubscribe");

	UWorkshop_Unsubscribe_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8FF0
//		Name   -> Function Pavlov.Workshop.SubscribeTo
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::SubscribeTo(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.SubscribeTo");

	UWorkshop_SubscribeTo_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8ED0
//		Name   -> Function Pavlov.Workshop.RequestUserVote
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		struct FName                                       ID                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::RequestUserVote(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.RequestUserVote");

	UWorkshop_RequestUserVote_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8D40
//		Name   -> Function Pavlov.Workshop.QueryForSpecificCustomMaps
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		TArray<struct FName>                               UniqueIds                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
void UWorkshop::QueryForSpecificCustomMaps(TArray<struct FName> UniqueIds)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.QueryForSpecificCustomMaps");

	UWorkshop_QueryForSpecificCustomMaps_Params params {};
	params.UniqueIds = UniqueIds;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8CC0
//		Name   -> Function Pavlov.Workshop.QueryForCustomMaps
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
//		Pavlov_EWorkshopQueryType                          QueryType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::QueryForCustomMaps(Pavlov_EWorkshopQueryType QueryType)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.QueryForCustomMaps");

	UWorkshop_QueryForCustomMaps_Params params {};
	params.QueryType = QueryType;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8C90
//		Name   -> Function Pavlov.Workshop.QueryDownloadProgress
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		int                                                ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
int UWorkshop::QueryDownloadProgress()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.QueryDownloadProgress");

	UWorkshop_QueryDownloadProgress_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8950
//		Name   -> Function Pavlov.Workshop.OnCustomMapDownloaded
//		Flags  -> (Final, Native, Private)
// Parameters:
//		bool                                               bSucceed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::OnCustomMapDownloaded(bool bSucceed, const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.OnCustomMapDownloaded");

	UWorkshop_OnCustomMapDownloaded_Params params {};
	params.bSucceed = bSucceed;
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8930
//		Name   -> Function Pavlov.Workshop.OnAfterMount
//		Flags  -> (Final, Native, Private)
void UWorkshop::OnAfterMount()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.OnAfterMount");

	UWorkshop_OnAfterMount_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D86F0
//		Name   -> Function Pavlov.Workshop.IsSubscribedTo
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UWorkshop::IsSubscribedTo(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.IsSubscribedTo");

	UWorkshop_IsSubscribedTo_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D86C0
//		Name   -> Function Pavlov.Workshop.IsDownloadingMap
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UWorkshop::IsDownloadingMap()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.IsDownloadingMap");

	UWorkshop_IsDownloadingMap_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8610
//		Name   -> Function Pavlov.Workshop.IsCustomMapId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FString                                     CustomMapId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		bool                                               ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
bool UWorkshop::IsCustomMapId(const struct FString& CustomMapId)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.IsCustomMapId");

	UWorkshop_IsCustomMapId_Params params {};
	params.CustomMapId = CustomMapId;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8410
//		Name   -> Function Pavlov.Workshop.GetPreviewTexture
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
// Parameters:
//		struct FName                                       ID                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class UTexture2D*                                  ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UTexture2D* UWorkshop::GetPreviewTexture(const struct FName& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.GetPreviewTexture");

	UWorkshop_GetPreviewTexture_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8310
//		Name   -> Function Pavlov.Workshop.GetCurrentDownloadId
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName UWorkshop::GetCurrentDownloadId()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.GetCurrentDownloadId");

	UWorkshop_GetCurrentDownloadId_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8060
//		Name   -> Function Pavlov.Workshop.DownloadTest
//		Flags  -> (Final, Native, Private)
void UWorkshop::DownloadTest()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.DownloadTest");

	UWorkshop_DownloadTest_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D7FC0
//		Name   -> Function Pavlov.Workshop.DownloadCustomMap
//		Flags  -> (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
//		struct FString                                     ID                                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWorkshop::DownloadCustomMap(const struct FString& ID)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.DownloadCustomMap");

	UWorkshop_DownloadCustomMap_Params params {};
	params.ID = ID;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D7FA0
//		Name   -> Function Pavlov.Workshop.CheckForDownload
//		Flags  -> (Final, Native, Private)
void UWorkshop::CheckForDownload()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Workshop.CheckForDownload");

	UWorkshop_CheckForDownload_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D80C0
//		Name   -> Function Pavlov.WoundAux.GetAvatarSkin
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UAvatarSkin*                                 ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UAvatarSkin* AWoundAux::GetAvatarSkin()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundAux.GetAvatarSkin");

	AWoundAux_GetAvatarSkin_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D8080
//		Name   -> Function Pavlov.WoundAux.GetAttachSocket
//		Flags  -> (Native, Event, Public, BlueprintEvent)
// Parameters:
//		struct FName                                       ReturnValue                                                (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
struct FName AWoundAux::GetAttachSocket()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundAux.GetAttachSocket");

	AWoundAux_GetAttachSocket_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D9110
//		Name   -> Function Pavlov.WoundComponent.UpdateBaseMesh
//		Flags  -> (Final, Native, Public)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		class USkeletalMesh*                               UpdateMesh                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWoundComponent::UpdateBaseMesh(class USkeletalMeshComponent* MeshComponent, class USkeletalMesh* UpdateMesh)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.UpdateBaseMesh");

	UWoundComponent_UpdateBaseMesh_Params params {};
	params.MeshComponent = MeshComponent;
	params.UpdateMesh = UpdateMesh;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8F70
//		Name   -> Function Pavlov.WoundComponent.SetMasterPoseComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWoundComponent::SetMasterPoseComponent(class USkeletalMeshComponent* MeshComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.SetMasterPoseComponent");

	UWoundComponent_SetMasterPoseComponent_Params params {};
	params.MeshComponent = MeshComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8F50
//		Name   -> Function Pavlov.WoundComponent.ResetWounds
//		Flags  -> (Final, Native, Public, BlueprintCallable)
void UWoundComponent::ResetWounds()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.ResetWounds");

	UWoundComponent_ResetWounds_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8E20
//		Name   -> Function Pavlov.WoundComponent.ReportHit
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FWoundInfo                                  WoundInfo                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
void UWoundComponent::ReportHit(const struct FWoundInfo& WoundInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.ReportHit");

	UWoundComponent_ReportHit_Params params {};
	params.WoundInfo = WoundInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D80F0
//		Name   -> Function Pavlov.WoundComponent.GetBoneState
//		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
// Parameters:
//		struct FName                                       BoneName                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
//		struct FWoundBoneState                             ReturnValue                                                (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
struct FWoundBoneState UWoundComponent::GetBoneState(const struct FName& BoneName)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.GetBoneState");

	UWoundComponent_GetBoneState_Params params {};
	params.BoneName = BoneName;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D7F00
//		Name   -> Function Pavlov.WoundComponent.ApplyInheritedCustomDepthValues
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class UMeshComponent*                              MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWoundComponent::ApplyInheritedCustomDepthValues(class UMeshComponent* MeshComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.ApplyInheritedCustomDepthValues");

	UWoundComponent_ApplyInheritedCustomDepthValues_Params params {};
	params.MeshComponent = MeshComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D7E80
//		Name   -> Function Pavlov.WoundComponent.AddMesh
//		Flags  -> (Final, Native, Public, BlueprintCallable)
// Parameters:
//		class USkeletalMeshComponent*                      MeshComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void UWoundComponent::AddMesh(class USkeletalMeshComponent* MeshComponent)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.WoundComponent.AddMesh");

	UWoundComponent_AddMesh_Params params {};
	params.MeshComponent = MeshComponent;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8C10
//		Name   -> Function Pavlov.Zombie.OnWoundMaterialCreated
//		Flags  -> (Final, Native, Private)
// Parameters:
//		class UMaterialInstanceDynamic*                    MaterialInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
void AZombie::OnWoundMaterialCreated(class UMaterialInstanceDynamic* MaterialInstance)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Zombie.OnWoundMaterialCreated");

	AZombie_OnWoundMaterialCreated_Params params {};
	params.MaterialInstance = MaterialInstance;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8810
//		Name   -> Function Pavlov.Zombie.MulticastOnRadialDeath
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FVector_NetQuantize                         Origin                                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
void AZombie::MulticastOnRadialDeath(const struct FVector_NetQuantize& Origin)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Zombie.MulticastOnRadialDeath");

	AZombie_MulticastOnRadialDeath_Params params {};
	params.Origin = Origin;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D8790
//		Name   -> Function Pavlov.Zombie.MulticastOnHit
//		Flags  -> (Net, Native, Event, NetMulticast, Public)
// Parameters:
//		struct FZombieHitInfo                              HitInfo                                                    (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
void AZombie::MulticastOnHit(const struct FZombieHitInfo& HitInfo)
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Zombie.MulticastOnHit");

	AZombie_MulticastOnHit_Params params {};
	params.HitInfo = HitInfo;

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


// Function:
//		Offset -> 0x006D85E0
//		Name   -> Function Pavlov.Zombie.GetWoundComponent
//		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
//		class UWoundComponent*                             ReturnValue                                                (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
class UWoundComponent* AZombie::GetWoundComponent()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Zombie.GetWoundComponent");

	AZombie_GetWoundComponent_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;


	return params.ReturnValue;
}


// Function:
//		Offset -> 0x006D7F80
//		Name   -> Function Pavlov.Zombie.ApplyLastHitEffect
//		Flags  -> (Final, Native, Private)
void AZombie::ApplyLastHitEffect()
{
	static UFunction* fn = UObject::FindObject<UFunction>("Function Pavlov.Zombie.ApplyLastHitEffect");

	AZombie_ApplyLastHitEffect_Params params {};

	auto flags = fn->FunctionFlags;
	fn->FunctionFlags |= 0x00000400;

	UObject::ProcessEvent(fn, &params);
	fn->FunctionFlags = flags;

}


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
